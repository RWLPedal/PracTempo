/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./audio_controller.ts":
/*!*****************************!*\
  !*** ./audio_controller.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AudioController = void 0;\nclass AudioController {\n    /**\n     * @param introEndSoundEl - Audio element for intro end sound.\n     * @param intervalEndSoundEl - Audio element for interval end sound.\n     * @param metronomeAudioEl - Audio element for the standard metronome click.\n     * @param accentMetronomeAudioEl - Audio element for the accented metronome click.\n     */\n    constructor(introEndSoundEl, intervalEndSoundEl, metronomeAudioEl, accentMetronomeAudioEl) {\n        this.introEndSoundEl = introEndSoundEl;\n        this.intervalEndSoundEl = intervalEndSoundEl;\n        this.metronomeAudioEl = metronomeAudioEl;\n        this.accentMetronomeAudioEl = accentMetronomeAudioEl;\n        // Optional: Check if elements were found\n        if (!this.metronomeAudioEl)\n            console.warn(\"AudioController: Standard metronome element not provided.\");\n        if (!this.accentMetronomeAudioEl)\n            console.warn(\"AudioController: Accent metronome element not provided.\");\n    }\n    playSound(audioElement) {\n        if (audioElement) {\n            audioElement.currentTime = 0; // Rewind before playing\n            audioElement.play().catch(e => console.error(\"Audio play failed:\", e));\n        }\n        else {\n            console.warn(\"Attempted to play null audio element.\");\n        }\n    }\n    playIntroEnd() {\n        this.playSound(this.introEndSoundEl);\n    }\n    playIntervalEnd() {\n        this.playSound(this.intervalEndSoundEl);\n    }\n    playMetronomeClick() {\n        this.playSound(this.metronomeAudioEl);\n    }\n    playAccentMetronomeClick() {\n        this.playSound(this.accentMetronomeAudioEl);\n    }\n}\nexports.AudioController = AudioController;\n\n\n//# sourceURL=webpack:///./audio_controller.ts?");

/***/ }),

/***/ "./display_controller.ts":
/*!*******************************!*\
  !*** ./display_controller.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DisplayController = exports.Status = void 0;\nvar Status;\n(function (Status) {\n    Status[\"Play\"] = \"Play\";\n    Status[\"Pause\"] = \"Pause\";\n    Status[\"Stop\"] = \"Stop\";\n})(Status || (exports.Status = Status = {}));\nclass DisplayController {\n    constructor(timerEl, totalTimerEl, taskWrapperEl, taskDisplayEl, diagramEl, statusEl, upcomingEl, controlButtonEl) {\n        this.timerEl = timerEl;\n        this.totalTimerEl = totalTimerEl;\n        this.taskWrapperEl = taskWrapperEl;\n        this.taskDisplayEl = taskDisplayEl;\n        this.diagramEl = diagramEl;\n        this.statusEl = statusEl;\n        this.upcomingEl = upcomingEl;\n        this.controlButtonEl = controlButtonEl;\n    }\n    setTask(taskName, color) {\n        this.taskDisplayEl.innerText = taskName;\n    }\n    setTime(seconds) {\n        this.timerEl.innerText = this.formattedTime(seconds);\n    }\n    setStatus(status) {\n        let text = \"||\";\n        if (status === Status.Play)\n            text = \"▶\";\n        else if (status === Status.Stop)\n            text = \"■\";\n        this.statusEl.textContent = text;\n    }\n    flashOverlay() {\n        const overlay = document.getElementById(\"overlay\");\n        if (!overlay)\n            return;\n        overlay.classList.remove(\"hidden\");\n        overlay.classList.add(\"visible\");\n        setTimeout(() => {\n            overlay.classList.remove(\"visible\");\n            overlay.classList.add(\"hidden\");\n        }, 500); // Duration of flash\n    }\n    setTotalTime(seconds, totalDuration) {\n        this.totalTimerEl.innerText = `${this.formattedTime(seconds)} / ${this.formattedTime(totalDuration)}`;\n    }\n    /**\n     * Updates the upcoming tasks list.\n     * @param upcomingIntervals Array of the next intervals to display.\n     * @param isEndVisible True if the end of the schedule falls within this list's scope.\n     */\n    setUpcoming(upcomingIntervals, isEndVisible) {\n        this.clearAllChildren(this.upcomingEl);\n        // Only show placeholder if there are no intervals AND the end isn't visible yet\n        if (upcomingIntervals.length === 0 && !isEndVisible) {\n            this.upcomingEl.innerHTML = \"<li>(No upcoming tasks)</li>\"; // Adjusted placeholder\n        }\n        else {\n            // Display the upcoming intervals\n            upcomingIntervals.forEach((interval) => {\n                const intervalEl = document.createElement(\"li\");\n                const introSuffix = interval.isIntroActive() ? \" (Warmup)\" : \"\";\n                // Keep duration display concise\n                const text = `${interval.task || \"(Untitled)\"}${introSuffix} [${this.formattedTime(interval.duration)}]`;\n                intervalEl.innerText = text;\n                this.upcomingEl.appendChild(intervalEl);\n            });\n            // Add \"END\" marker if the end of the schedule is reached within this view\n            if (isEndVisible) {\n                const endLi = document.createElement(\"li\");\n                endLi.textContent = \"END\";\n                endLi.style.fontWeight = \"bold\"; // Make it stand out\n                endLi.style.color = \"#888\"; // Dim color slightly\n                endLi.style.marginTop = \"5px\"; // Add a little space before END\n                this.upcomingEl.appendChild(endLi);\n            }\n        }\n    }\n    /**\n     * Renders the feature and its views into the diagram container.\n     * Relies on the feature providing views in the desired render order.\n     * @param feature The feature instance to render.\n     * @param handedness The current handedness setting ('left' or 'right').\n     */\n    renderFeature(feature, handedness = \"right\" // Handedness is likely handled by config now\n    ) {\n        var _a;\n        console.log(`[DisplayController.renderFeature] Attempting to render feature: ${(feature === null || feature === void 0 ? void 0 : feature.typeName) || \"UNKNOWN\"}`);\n        this.clearFeature(); // Clear the main container first\n        if (!feature) {\n            console.error(\"[DisplayController.renderFeature] Cannot render null/undefined feature.\");\n            return;\n        }\n        try {\n            // Feature's render method might add headers or other base content\n            feature.render(this.diagramEl);\n            console.log(`[DisplayController.renderFeature] Successfully called feature.render() for ${feature.typeName}`);\n            // Render associated views (like Metronome) IN THE ORDER PROVIDED by the feature\n            (_a = feature.views) === null || _a === void 0 ? void 0 : _a.forEach((view) => {\n                console.log(`[DisplayController.renderFeature]   Rendering view: ${view.constructor.name}`);\n                view.render(this.diagramEl); // Append each view's content\n            });\n        }\n        catch (error) {\n            console.error(`[DisplayController.renderFeature] Error during rendering feature ${feature.typeName}:`, error);\n            this.diagramEl.innerHTML = `<p style=\"color: red; padding: 10px;\">Error rendering feature: ${feature.typeName}</p>`;\n        }\n    }\n    clearFeature() {\n        this.clearAllChildren(this.diagramEl);\n    }\n    formattedTime(totalSeconds) {\n        if (isNaN(totalSeconds) || totalSeconds < 0)\n            return \"0:00\";\n        const tsf = Math.floor(totalSeconds);\n        const s = (tsf % 60).toString().padStart(2, \"0\");\n        const tm = Math.floor(tsf / 60);\n        // No hours display needed based on previous format\n        return `${tm}:${s}`;\n    }\n    clearAllChildren(element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n    setStart() {\n        this.controlButtonEl.innerText = \"START\";\n        this.controlButtonEl.classList.remove(\"is-warning\");\n        this.controlButtonEl.classList.add(\"is-success\");\n    }\n    setPause() {\n        this.controlButtonEl.innerText = \"PAUSE\";\n        this.controlButtonEl.classList.remove(\"is-success\");\n        this.controlButtonEl.classList.add(\"is-warning\");\n    }\n}\nexports.DisplayController = DisplayController;\n\n\n//# sourceURL=webpack:///./display_controller.ts?");

/***/ }),

/***/ "./feature_registry.ts":
/*!*****************************!*\
  !*** ./feature_registry.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerCategory = registerCategory;\nexports.getCategory = getCategory;\nexports.getFeatureTypeDescriptor = getFeatureTypeDescriptor;\nexports.getAvailableCategories = getAvailableCategories;\nexports.getAvailableFeatureTypes = getAvailableFeatureTypes;\nexports.getDefaultGlobalSettingsForCategory = getDefaultGlobalSettingsForCategory;\nexports.getAllDefaultGlobalSettings = getAllDefaultGlobalSettings;\nexports.getIntervalSettingsFactory = getIntervalSettingsFactory;\nexports.getIntervalSettingsParser = getIntervalSettingsParser;\n// --- Internal Registry Maps ---\n/** Stores registered Category instances, keyed by category name */\nconst categoryRegistry = new Map();\n/** Stores FeatureTypeDescriptors, keyed by categoryName/typeName for quick lookup */\nconst featureTypeRegistry = new Map(); // Key: \"CategoryName/TypeName\"\n/** Stores default global settings data, keyed by category name */\nconst defaultGlobalSettingsRegistry = new Map();\n/** Stores interval settings factories, keyed by category name */\nconst intervalSettingsFactoryRegistry = new Map();\n/** Stores interval settings JSON parsers, keyed by category name */\nconst intervalSettingsParserRegistry = new Map();\n/**\n * Registers a feature category instance.\n * Extracts necessary information and populates internal registries.\n * @param categoryInstance - An instance of a class implementing Category.\n */\nfunction registerCategory(categoryInstance) {\n    var _a;\n    const categoryName = categoryInstance.getName();\n    if (!categoryName || typeof categoryName !== \"string\") {\n        console.error(\"Cannot register category: Instance is missing a valid getName() method.\", categoryInstance);\n        return;\n    }\n    if (categoryRegistry.has(categoryName)) {\n        console.warn(`FeatureCategory \"${categoryName}\" is already registered. Overwriting.`);\n    }\n    categoryRegistry.set(categoryName, categoryInstance);\n    // Store settings and factories provided by the category instance\n    try {\n        defaultGlobalSettingsRegistry.set(categoryName, categoryInstance.getDefaultGlobalSettings());\n    }\n    catch (e) {\n        console.error(`Error getting default global settings for category \"${categoryName}\":`, e);\n    }\n    try {\n        intervalSettingsFactoryRegistry.set(categoryName, categoryInstance.getIntervalSettingsFactory());\n    }\n    catch (e) {\n        console.error(`Error getting interval settings factory for category \"${categoryName}\":`, e);\n    }\n    try {\n        // Bind the method to the instance to preserve 'this' context if needed inside the method\n        intervalSettingsParserRegistry.set(categoryName, categoryInstance.createIntervalSettingsFromJSON.bind(categoryInstance));\n    }\n    catch (e) {\n        console.error(`Error getting interval settings JSON parser for category \"${categoryName}\":`, e);\n    }\n    // Register individual feature types for easy lookup\n    let featureTypes = null;\n    try {\n        featureTypes = categoryInstance.getFeatureTypes();\n        if (!featureTypes)\n            throw new Error(\"getFeatureTypes() returned null or undefined\");\n    }\n    catch (e) {\n        console.error(`Error getting feature types for category \"${categoryName}\":`, e);\n        return; // Don't proceed if features can't be retrieved\n    }\n    featureTypes.forEach((featureType, typeName) => {\n        if (!typeName || typeof typeName !== \"string\") {\n            console.warn(`Skipping feature registration for category \"${categoryName}\": Invalid typeName found.`, featureType);\n            return;\n        }\n        const fullKey = `${categoryName}/${typeName}`;\n        if (featureTypeRegistry.has(fullKey)) {\n            console.warn(`FeatureType \"${fullKey}\" is already registered. Overwriting.`);\n        }\n        // Basic validation of featureType descriptor\n        if (typeof (featureType === null || featureType === void 0 ? void 0 : featureType.createFeature) !== \"function\" ||\n            typeof (featureType === null || featureType === void 0 ? void 0 : featureType.getConfigurationSchema) !== \"function\") {\n            console.warn(`Skipping feature registration for \"${fullKey}\": Invalid FeatureTypeDescriptor (missing createFeature or getConfigurationSchema).`, featureType);\n            return;\n        }\n        featureTypeRegistry.set(fullKey, featureType);\n    });\n    console.log(`Registered Category: ${categoryName} with ${(_a = featureTypes === null || featureTypes === void 0 ? void 0 : featureTypes.size) !== null && _a !== void 0 ? _a : 0} feature types.`);\n}\n/**\n * Retrieves a registered category instance by name.\n * @param categoryName - The unique name of the category.\n * @returns The Category instance or undefined if not found.\n */\nfunction getCategory(categoryName) {\n    return categoryRegistry.get(categoryName);\n}\n/**\n * Retrieves the descriptor for a specific feature type.\n * @param categoryName - The category name.\n * @param typeName - The feature type name within the category.\n * @returns The descriptor or undefined if not found.\n */\nfunction getFeatureTypeDescriptor(categoryName, typeName) {\n    if (!categoryName || !typeName)\n        return undefined;\n    return featureTypeRegistry.get(`${categoryName}/${typeName}`);\n}\n/**\n * Retrieves all registered category instances.\n * @returns An array of all registered Category instances.\n */\nfunction getAvailableCategories() {\n    return Array.from(categoryRegistry.values());\n}\n/**\n * Retrieves all available feature type descriptors for a given category.\n * @param categoryName - The category name.\n * @returns An array of type descriptors, or empty if category not found.\n */\nfunction getAvailableFeatureTypes(categoryName) {\n    const category = categoryRegistry.get(categoryName);\n    return category ? Array.from(category.getFeatureTypes().values()) : [];\n}\n/** Retrieves the default *global* settings *data* for a specific category name. */\nfunction getDefaultGlobalSettingsForCategory(categoryName) {\n    return defaultGlobalSettingsRegistry.get(categoryName);\n}\n/** Constructs a map containing the default *global* settings *data* for all registered categories. */\nfunction getAllDefaultGlobalSettings() {\n    const defaults = {};\n    defaultGlobalSettingsRegistry.forEach((settings, categoryName) => {\n        // Ensure settings is not null/undefined before assigning\n        if (settings !== undefined && settings !== null) {\n            defaults[categoryName] = settings;\n        }\n        else {\n            console.warn(`Default global settings for category \"${categoryName}\" are null or undefined.`);\n            defaults[categoryName] = {}; // Assign empty object as fallback\n        }\n    });\n    return defaults;\n}\n/** Retrieves the factory function for creating a default *interval* settings instance for a category. */\nfunction getIntervalSettingsFactory(categoryName) {\n    return intervalSettingsFactoryRegistry.get(categoryName);\n}\n/** Retrieves the parser function for creating an *interval* settings instance from JSON for a category. */\nfunction getIntervalSettingsParser(categoryName) {\n    return intervalSettingsParserRegistry.get(categoryName);\n}\n\n\n//# sourceURL=webpack:///./feature_registry.ts?");

/***/ }),

/***/ "./floating_views/floating_view_manager.ts":
/*!*************************************************!*\
  !*** ./floating_views/floating_view_manager.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FloatingViewManager = void 0;\n// ts/floating_views/floating_view_manager.ts\nconst floating_view_wrapper_1 = __webpack_require__(/*! ./floating_view_wrapper */ \"./floating_views/floating_view_wrapper.ts\");\nconst floating_view_registry_1 = __webpack_require__(/*! ./floating_view_registry */ \"./floating_views/floating_view_registry.ts\");\nconst FLOATING_VIEW_STATE_KEY = \"floatingViewStates\";\nconst FLOATING_VIEW_AREA_ID = \"floating-view-area\"; // ID of the container element\nclass FloatingViewManager {\n    constructor(appSettings) {\n        this.activeViews = new Map();\n        this.nextInstanceId = 1;\n        this.currentMaxZIndex = 100; // Starting z-index\n        this.appSettings = appSettings; // Keep settings reference\n        this.viewAreaElement = document.getElementById(FLOATING_VIEW_AREA_ID);\n        if (!this.viewAreaElement) {\n            console.error(`Floating View container #${FLOATING_VIEW_AREA_ID} not found! Views will not be displayed.`);\n        }\n    }\n    // --- Public API ---\n    spawnView(viewId, initialState) {\n        var _a;\n        if (!this.viewAreaElement)\n            return;\n        // Removed duplicate check - allow multiple instances\n        const descriptor = (0, floating_view_registry_1.getFloatingViewDescriptor)(viewId);\n        if (!descriptor) {\n            console.error(`Cannot spawn view: Descriptor not found for viewId \"${viewId}\"`);\n            return;\n        }\n        const instanceId = `fv-${this.nextInstanceId++}`;\n        // Bring new view to front\n        this.currentMaxZIndex++;\n        // Merge initial state if provided\n        const state = {\n            instanceId: instanceId,\n            viewId: viewId,\n            position: (_a = initialState === null || initialState === void 0 ? void 0 : initialState.position) !== null && _a !== void 0 ? _a : {\n                x: 50 + ((this.activeViews.size * 20) % 300),\n                y: 50 + ((this.activeViews.size * 20) % 400),\n            }, // Simple cascade with wrap\n            size: initialState === null || initialState === void 0 ? void 0 : initialState.size, // Use saved size or let wrapper use default\n            zIndex: this.currentMaxZIndex,\n            viewState: initialState === null || initialState === void 0 ? void 0 : initialState.viewState,\n        };\n        try {\n            // Pass settings reference, views might need it\n            const viewInstance = descriptor.createView(state.viewState, this.appSettings);\n            const wrapper = new floating_view_wrapper_1.FloatingViewWrapper(state, descriptor.displayName, viewInstance, (id) => this.destroyView(id), // Callback for close button\n            (newState) => this.handleViewStateChange(newState), // Callback for state updates (pos, focus)\n            descriptor.defaultWidth, descriptor.defaultHeight);\n            this.activeViews.set(instanceId, wrapper);\n            this.viewAreaElement.appendChild(wrapper.element);\n            this.saveState(); // Save after adding\n            console.log(`Spawned floating view instance: ${instanceId} (type: ${viewId})`);\n        }\n        catch (e) {\n            console.error(`Error creating view instance for ${viewId}:`, e);\n        }\n    }\n    destroyView(instanceId) {\n        const wrapper = this.activeViews.get(instanceId);\n        if (wrapper) {\n            const viewId = wrapper[\"state\"].viewId; // Get viewId before destroying\n            // Wrapper's destroy method calls the View's destroy and removes element\n            this.activeViews.delete(instanceId);\n            this.saveState(); // Save after removing\n            console.log(`Destroyed floating view instance: ${instanceId} (type: ${viewId})`);\n            // No longer need to dispatch event for checkbox sync\n            // document.dispatchEvent(new CustomEvent('floating-view-destroyed', { detail: { viewId: viewId } }));\n        }\n    }\n    // Removed destroyViewByViewId, isViewActive, getViewInstanceId as they are not needed for this UI model\n    restoreViewsFromState() {\n        if (!this.viewAreaElement)\n            return;\n        console.log(\"Restoring floating views from state...\");\n        const savedState = this.loadState();\n        if (savedState && savedState.openViews) {\n            this.currentMaxZIndex = savedState.nextZIndex || 100; // Restore z-index counter\n            // Sort by z-index before spawning to preserve layering\n            const sortedStates = Object.values(savedState.openViews).sort((a, b) => a.zIndex - b.zIndex);\n            sortedStates.forEach((state) => {\n                var _a, _b, _c, _d;\n                // Use a simplified spawn logic that assumes state is complete\n                const descriptor = (0, floating_view_registry_1.getFloatingViewDescriptor)(state.viewId);\n                if (!descriptor) {\n                    console.warn(`Cannot restore view: Descriptor not found for viewId \"${state.viewId}\"`);\n                    return;\n                }\n                try {\n                    // Ensure instanceId counter is beyond any loaded IDs\n                    const numericId = parseInt(state.instanceId.replace(\"fv-\", \"\"), 10);\n                    if (!isNaN(numericId)) {\n                        this.nextInstanceId = Math.max(this.nextInstanceId, numericId + 1);\n                    }\n                    // Pass current settings reference on restore\n                    const viewInstance = descriptor.createView(state.viewState, this.appSettings);\n                    const wrapper = new floating_view_wrapper_1.FloatingViewWrapper(state, // Pass the full saved state\n                    descriptor.displayName, viewInstance, (id) => this.destroyView(id), (newState) => this.handleViewStateChange(newState), (_b = (_a = state.size) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : descriptor.defaultWidth, // Use saved size if available\n                    (_d = (_c = state.size) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : descriptor.defaultHeight);\n                    this.activeViews.set(state.instanceId, wrapper);\n                    this.viewAreaElement.appendChild(wrapper.element);\n                }\n                catch (e) {\n                    console.error(`Error recreating view instance ${state.instanceId} (${state.viewId}):`, e);\n                }\n            });\n            console.log(`Restored ${this.activeViews.size} floating views.`);\n        }\n        else {\n            console.log(\"No saved floating view state found.\");\n        }\n    }\n    // --- Internal State Management ---\n    handleViewStateChange(newState) {\n        const wrapper = this.activeViews.get(newState.instanceId);\n        if (!wrapper)\n            return;\n        // Bring to front logic\n        if (newState.zIndex < this.currentMaxZIndex) {\n            this.currentMaxZIndex++;\n            newState.zIndex = this.currentMaxZIndex;\n            wrapper.bringToFront(newState.zIndex);\n            // Save state only if z-index changed to bring to front\n            this.saveState();\n        }\n        else {\n            // Otherwise, just save the potentially changed position/size\n            this.saveState();\n        }\n    }\n    saveState() {\n        if (typeof localStorage === \"undefined\")\n            return; // Avoid errors in non-browser envs\n        const stateToSave = {\n            openViews: {},\n            nextZIndex: this.currentMaxZIndex,\n        };\n        this.activeViews.forEach((wrapper, instanceId) => {\n            // Get the *current* state from the wrapper instance\n            stateToSave.openViews[instanceId] = wrapper[\"state\"]; // Access private state for saving\n        });\n        try {\n            localStorage.setItem(FLOATING_VIEW_STATE_KEY, JSON.stringify(stateToSave));\n        }\n        catch (e) {\n            console.error(\"Failed to save floating view state:\", e);\n        }\n    }\n    loadState() {\n        if (typeof localStorage === \"undefined\")\n            return null;\n        const savedJson = localStorage.getItem(FLOATING_VIEW_STATE_KEY);\n        if (savedJson) {\n            try {\n                return JSON.parse(savedJson);\n            }\n            catch (e) {\n                console.error(\"Failed to parse saved floating view state:\", e);\n                localStorage.removeItem(FLOATING_VIEW_STATE_KEY); // Remove corrupted data\n            }\n        }\n        return null;\n    }\n}\nexports.FloatingViewManager = FloatingViewManager;\n\n\n//# sourceURL=webpack:///./floating_views/floating_view_manager.ts?");

/***/ }),

/***/ "./floating_views/floating_view_registry.ts":
/*!**************************************************!*\
  !*** ./floating_views/floating_view_registry.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerFloatingView = registerFloatingView;\nexports.getFloatingViewDescriptor = getFloatingViewDescriptor;\nexports.getAvailableFloatingViews = getAvailableFloatingViews;\nconst registry = new Map();\nfunction registerFloatingView(descriptor) {\n    if (!descriptor || !descriptor.viewId) {\n        console.error(\"Cannot register floating view: Invalid descriptor.\", descriptor);\n        return;\n    }\n    if (registry.has(descriptor.viewId)) {\n        console.warn(`Floating view ID \"${descriptor.viewId}\" is already registered. Overwriting.`);\n    }\n    registry.set(descriptor.viewId, descriptor);\n    console.log(`Registered Floating View: <span class=\"math-inline\">\\{descriptor\\.displayName\\} \\(</span>{descriptor.viewId})`);\n}\nfunction getFloatingViewDescriptor(viewId) {\n    return registry.get(viewId);\n}\nfunction getAvailableFloatingViews() {\n    return Array.from(registry.values());\n}\n\n\n//# sourceURL=webpack:///./floating_views/floating_view_registry.ts?");

/***/ }),

/***/ "./floating_views/floating_view_wrapper.ts":
/*!*************************************************!*\
  !*** ./floating_views/floating_view_wrapper.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FloatingViewWrapper = void 0;\n// Basic Dragging Logic (can be enhanced or use a library)\nlet dragOffsetX = 0;\nlet dragOffsetY = 0;\nlet draggedElement = null;\nfunction startDrag(e, element) {\n    draggedElement = element;\n    const rect = element.getBoundingClientRect();\n    // Calculate offset from top-left corner of the element\n    dragOffsetX = e.clientX - rect.left;\n    dragOffsetY = e.clientY - rect.top;\n    // Use clientX/Y for mouse position relative to viewport\n    // dragOffsetX = e.clientX - element.offsetLeft;\n    // dragOffsetY = e.clientY - element.offsetTop;\n    document.addEventListener(\"mousemove\", doDrag);\n    document.addEventListener(\"mouseup\", stopDrag);\n    element.style.cursor = \"grabbing\";\n    element.classList.add(\"is-dragging\"); // For visual feedback\n}\nfunction doDrag(e) {\n    if (!draggedElement)\n        return;\n    // Set position based on viewport coordinates minus offset\n    let newX = e.clientX - dragOffsetX;\n    let newY = e.clientY - dragOffsetY;\n    // --- Basic Boundary Collision ---\n    const parent = draggedElement.offsetParent || document.body;\n    const parentRect = parent.getBoundingClientRect();\n    const elemRect = draggedElement.getBoundingClientRect();\n    newX = Math.max(0, Math.min(newX, parentRect.width - elemRect.width));\n    newY = Math.max(0, Math.min(newY, parentRect.height - elemRect.height));\n    // --- End Basic Boundary Collision ---\n    draggedElement.style.left = `${newX}px`;\n    draggedElement.style.top = `${newY}px`;\n}\nfunction stopDrag() {\n    if (draggedElement) {\n        draggedElement.style.cursor = \"grab\";\n        draggedElement.classList.remove(\"is-dragging\");\n        // Notify manager about position change (e.g., via callback or event)\n        const managerCallback = draggedElement._notifyPositionChange;\n        if (managerCallback) {\n            managerCallback(parseFloat(draggedElement.style.left || \"0\"), parseFloat(draggedElement.style.top || \"0\"));\n        }\n    }\n    draggedElement = null;\n    document.removeEventListener(\"mousemove\", doDrag);\n    document.removeEventListener(\"mouseup\", stopDrag);\n}\n// --- End Dragging Logic ---\nclass FloatingViewWrapper {\n    constructor(state, title, viewInstance, onDestroy, onStateChange, defaultWidth, defaultHeight) {\n        this.state = state;\n        this.viewInstance = viewInstance;\n        this.onDestroyCallback = onDestroy;\n        this.onStateChangeCallback = onStateChange;\n        this.element = document.createElement(\"div\");\n        this.element.classList.add(\"floating-view-wrapper\");\n        this.element.style.position = \"absolute\"; // Crucial for positioning\n        this.element.style.left = `${state.position.x}px`;\n        this.element.style.top = `${state.position.y}px`;\n        this.element.style.zIndex = `${state.zIndex}`;\n        if (state.size) {\n            this.element.style.width = `${state.size.width}px`;\n            this.element.style.height = `${state.size.height}px`;\n        }\n        else if (defaultWidth || defaultHeight) {\n            if (defaultWidth)\n                this.element.style.width = `${defaultWidth}px`;\n            // Height might be better left to content, or provide default\n            // if (defaultHeight) this.element.style.height = `${defaultHeight}px`;\n        }\n        // Make wrapper focusable and handle z-index bring-to-front\n        this.element.setAttribute(\"tabindex\", \"-1\"); // Allows focus\n        this.element.addEventListener(\"mousedown\", () => {\n            this.onStateChangeCallback(this.state); // Notify manager to bring to front\n        }, true); // Use capture phase\n        // Store callback for drag end notification\n        this.element._notifyPositionChange = (x, y) => {\n            this.state.position = { x, y };\n            this.onStateChangeCallback(this.state);\n        };\n        // --- Title Bar ---\n        const titleBar = document.createElement(\"div\");\n        titleBar.classList.add(\"floating-view-titlebar\");\n        titleBar.textContent = title;\n        titleBar.style.cursor = \"grab\"; // Indicate draggable\n        titleBar.addEventListener(\"mousedown\", (e) => startDrag(e, this.element)); // Attach drag handler\n        // --- Close Button ---\n        const closeButton = document.createElement(\"button\");\n        closeButton.classList.add(\"floating-view-close\");\n        closeButton.innerHTML = \"&times;\"; // 'X' symbol\n        closeButton.title = \"Close\";\n        closeButton.onclick = (e) => {\n            e.stopPropagation(); // Prevent title bar drag\n            this.destroy();\n        };\n        titleBar.appendChild(closeButton);\n        this.element.appendChild(titleBar);\n        // --- Content Area ---\n        this.contentElement = document.createElement(\"div\");\n        this.contentElement.classList.add(\"floating-view-content\");\n        this.element.appendChild(this.contentElement);\n        // --- Render the actual View ---\n        try {\n            this.viewInstance.render(this.contentElement);\n        }\n        catch (e) {\n            console.error(`Error rendering view ${state.viewId}:`, e);\n            this.contentElement.textContent = \"Error rendering view.\";\n        }\n    }\n    get instanceId() {\n        return this.state.instanceId;\n    }\n    bringToFront(zIndex) {\n        this.state.zIndex = zIndex;\n        this.element.style.zIndex = `${zIndex}`;\n    }\n    destroy() {\n        try {\n            this.viewInstance.destroy();\n        }\n        catch (e) {\n            console.error(`Error destroying view ${this.state.viewId}:`, e);\n        }\n        if (this.element.parentNode) {\n            this.element.parentNode.removeChild(this.element);\n        }\n        this.onDestroyCallback(this.state.instanceId);\n    }\n}\nexports.FloatingViewWrapper = FloatingViewWrapper;\n\n\n//# sourceURL=webpack:///./floating_views/floating_view_wrapper.ts?");

/***/ }),

/***/ "./guitar/chords.ts":
/*!**************************!*\
  !*** ./guitar/chords.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chord_library = exports.Chord = void 0;\nclass Chord {\n    constructor(name, strings, fingers) {\n        if (strings.length !== 6 || fingers.length !== 6) {\n            throw new Error(`Chord ${name} must have 6 values for strings and fingers.`);\n        }\n        this.name = name;\n        this.strings = strings;\n        this.fingers = fingers;\n    }\n}\nexports.Chord = Chord;\nexports.chord_library = {\n    // --- Simple Majors ---\n    A_MAJOR: new Chord(\"A Major\", [-1, 0, 2, 2, 2, 0], [-1, 0, 2, 1, 3, 0]),\n    C_MAJOR: new Chord(\"C Major\", [-1, 3, 2, 0, 1, 0], [-1, 3, 2, 0, 1, 0]),\n    D_MAJOR: new Chord(\"D Major\", [-1, -1, 0, 2, 3, 2], [-1, -1, 0, 1, 3, 2]),\n    E_MAJOR: new Chord(\"E Major\", [0, 2, 2, 1, 0, 0], [0, 2, 3, 1, 0, 0]),\n    F_MAJOR: new Chord(\"F Major\", // Barre chord\n    [1, 3, 3, 2, 1, 1], [1, 3, 4, 2, 1, 1]),\n    G_MAJOR: new Chord(\"G Major\", [3, 2, 0, 0, 0, 3], [2, 1, 0, 0, 0, 3]),\n    // --- Simple Minors ---\n    A_MINOR: new Chord(\"A Minor\", [-1, 0, 2, 2, 1, 0], [-1, 0, 2, 3, 1, 0]),\n    B_MINOR: new Chord(\"B Minor\", // Barre chord\n    [-1, 2, 4, 4, 3, 2], [-1, 1, 3, 4, 2, 1]),\n    D_MINOR: new Chord(\"D Minor\", [-1, -1, 0, 2, 3, 1], [-1, -1, 0, 2, 3, 1]),\n    E_MINOR: new Chord(\"E Minor\", [0, 2, 2, 0, 0, 0], [0, 2, 3, 0, 0, 0]),\n    // --- Dominant 7th Chords ---\n    A7: new Chord(\"A7\", [-1, 0, 2, 0, 2, 0], [-1, 0, 2, 0, 3, 0]),\n    B7: new Chord(\"B7\", [-1, 2, 1, 2, 0, 2], [-1, 2, 1, 3, 0, 4]),\n    C7: new Chord(\"C7\", [-1, 3, 2, 3, 1, 0], [-1, 3, 2, 4, 1, 0]),\n    D7: new Chord(\"D7\", [-1, -1, 0, 2, 1, 2], [-1, -1, 0, 2, 1, 3]),\n    E7: new Chord(\"E7\", [0, 2, 0, 1, 0, 0], [0, 2, 0, 1, 0, 0]),\n    F7: new Chord(\"F7\", // Barre chord\n    [1, 3, 1, 2, 1, 1], [1, 3, 1, 2, 1, 1]),\n    G7: new Chord(\"G7\", [3, 2, 0, 0, 0, 1], [3, 2, 0, 0, 0, 1]),\n    // --- Major 7th Chords ---\n    AMAJ7: new Chord(\"A Major 7\", [-1, 0, 2, 1, 2, 0], [-1, 0, 2, 1, 3, 0]),\n    CMAJ7: new Chord(\"C Major 7\", [-1, 3, 2, 0, 0, 0], [-1, 3, 2, 0, 0, 0]),\n    DMAJ7: new Chord(\"D Major 7\", [-1, -1, 0, 2, 2, 2], [-1, -1, 0, 1, 2, 3]),\n    FMAJ7: new Chord(\"F Major 7\", [-1, -1, 3, 2, 1, 0], [-1, -1, 3, 2, 1, 0]),\n    GMAJ7: new Chord(\"G Major 7\", [3, 2, 0, 0, 0, 2], [2, 1, 0, 0, 0, 3]),\n    // --- Minor 7th Chords ---\n    AM7: new Chord(\"A Minor 7\", [-1, 0, 2, 0, 1, 0], [-1, 0, 2, 0, 1, 0]),\n    BM7: new Chord(\"B Minor 7\", // Barre chord\n    [-1, 2, 4, 2, 3, 2], [-1, 1, 3, 1, 2, 1]),\n    CM7: new Chord(\"C Minor 7\", // Barre chord\n    [-1, 3, 5, 3, 4, 3], [-1, 1, 3, 1, 2, 1]),\n    DM7: new Chord(\"D Minor 7\", [-1, -1, 0, 2, 1, 1], [-1, -1, 0, 2, 1, 1]),\n    EM7: new Chord(\"E Minor 7\", [0, 2, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0]),\n    GM7: new Chord(\"G Minor 7\", // Barre chord\n    [3, 5, 3, 3, 3, 3], [1, 3, 1, 1, 1, 1]),\n    // --- Suspended Chords ---\n    ASUS2: new Chord(\"Asus2\", [-1, 0, 2, 2, 0, 0], [-1, 0, 2, 3, 0, 0]),\n    ASUS4: new Chord(\"Asus4\", [-1, 0, 2, 2, 3, 0], [-1, 0, 1, 2, 4, 0]), // Adjusted finger 3->4\n    DSUS2: new Chord(\"Dsus2\", [-1, -1, 0, 2, 3, 0], [-1, -1, 0, 1, 3, 0]),\n    DSUS4: new Chord(\"Dsus4\", [-1, -1, 0, 2, 3, 3], [-1, -1, 0, 1, 2, 3]), // Corrected fingers\n    ESUS4: new Chord(\"Esus4\", [0, 2, 2, 2, 0, 0], [0, 1, 2, 3, 0, 0]), // Corrected fingers\n    // --- Other Common Barre Chords ---\n    B_MAJOR: new Chord(\"B Major\", [-1, 2, 4, 4, 4, 2], [-1, 1, 3, 3, 3, 1]),\n    Fsharp_MINOR: new Chord(\"F# Minor\", [2, 4, 4, 2, 2, 2], [1, 3, 4, 1, 1, 1]),\n    Csharp_MINOR: new Chord(\"C# Minor\", [-1, 4, 6, 6, 5, 4], [-1, 1, 3, 4, 2, 1]),\n};\n\n\n//# sourceURL=webpack:///./guitar/chords.ts?");

/***/ }),

/***/ "./guitar/colors.ts":
/*!**************************!*\
  !*** ./guitar/colors.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Defines color constants for guitar-related rendering.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.INTERVAL_COLORS = exports.NOTE_COLORS = void 0;\nexports.getColor = getColor;\n// --- Note Colors ---\n// Using a distinct color for each chromatic note.\n// Colors chosen for visual distinction, but can be adjusted.\nexports.NOTE_COLORS = {\n    // Using sharps for keys\n    A: \"#FF6B6B\", // Red\n    \"A#\": \"#FF9F43\", // Orange\n    B: \"#FFD166\", // Yellow\n    C: \"#90EE90\", // Light Green\n    \"C#\": \"#1DD1A1\", // Teal\n    D: \"#4ECDC4\", // Turquoise\n    \"D#\": \"#54A0FF\", // Blue\n    E: \"#9B59B6\", // Purple\n    F: \"#C7A2CB\", // Lavender\n    \"F#\": \"#FDA7DF\", // Pink\n    G: \"#E67E22\", // Dark Orange\n    \"G#\": \"#BDC3C7\", // Silver/Grey\n    // Include flat aliases mapping to the same colors\n    Bb: \"#FF9F43\", // Orange (Same as A#)\n    Db: \"#1DD1A1\", // Teal (Same as C#)\n    Eb: \"#54A0FF\", // Blue (Same as D#)\n    Gb: \"#FDA7DF\", // Pink (Same as F#)\n    Ab: \"#BDC3C7\", // Silver/Grey (Same as G#)\n    DEFAULT: \"#888888\", // Default grey for unknown/unspecified\n};\n// --- Interval Colors ---\n// Colors representing the function/quality of the interval relative to a root.\nexports.INTERVAL_COLORS = {\n    \"R\": \"#E74C3C\", // Root (Red) - Stable, Foundation\n    \"b2\": \"#A0522D\", // Minor Second (Sienna Brown) - Dissonant, close to Root\n    \"2\": \"#F39C12\", // Major Second (Orange) - Common scale tone\n    \"b3\": \"#3498DB\", // Minor Third (Blue) - Defines Minor quality\n    \"3\": \"#2ECC71\", // Major Third (Green) - Defines Major quality\n    \"4\": \"#9B59B6\", // Perfect Fourth (Purple) - Stable Consonance\n    \"d5\": \"#7F8C8D\", // Diminished Fifth (Slate Grey) - Tritone, Unstable/Dissonant\n    \"#4\": \"#7F8C8D\", // Augmented Fourth (Slate Grey) - Tritone (alternate label)\n    \"5\": \"#F1C40F\", // Perfect Fifth (Yellow/Gold) - Strongest Consonance\n    \"b6\": \"#6A5ACD\", // Minor Sixth (Slate Blue) - Minor feel, related to b3\n    \"#5\": \"#FF00FF\", // Augmented Fifth (Magenta) - Altered, Tense\n    \"6\": \"#1ABC9C\", // Major Sixth (Teal/Turquoise) - Major feel, consonant\n    \"b7\": \"#483D8B\", // Minor Seventh (Dark Slate Blue/Indigo) - Dominant quality, tension\n    \"7\": \"#E91E63\", // Major Seventh (Pink) - Bright, close to Octave/Root, slightly dissonant\n    DEFAULT: \"#555555\", // Default dark grey for unspecified intervals\n};\n/**\n * Gets the appropriate color based on the scheme, note, and interval.\n * @param scheme The active color scheme.\n * @param noteName The name of the note (e.g., \"C#\").\n * @param intervalLabel The interval label (e.g., \"R\", \"b3\", \"5\").\n * @returns The hex color string.\n */\nfunction getColor(scheme, noteName, intervalLabel) {\n    switch (scheme) {\n        case \"note\":\n            // Use the primary name (e.g., A# over Bb) if available, otherwise the provided name\n            const primaryNoteName = Object.keys(exports.NOTE_COLORS).find((key) => key === noteName || exports.NOTE_COLORS[key] === exports.NOTE_COLORS[noteName]) || noteName;\n            return exports.NOTE_COLORS[primaryNoteName] || exports.NOTE_COLORS.DEFAULT;\n        case \"simplified\": // Renamed from \"default\"\n            // Simple logic: Red for root, dark grey otherwise\n            return intervalLabel === \"R\"\n                ? exports.INTERVAL_COLORS[\"R\"]\n                : exports.INTERVAL_COLORS.DEFAULT;\n        case \"interval\": // Handle \"interval\" explicitly, now also default\n        default: // Default behavior is now interval coloring\n            return exports.INTERVAL_COLORS[intervalLabel] || exports.INTERVAL_COLORS.DEFAULT;\n    }\n}\n\n\n//# sourceURL=webpack:///./guitar/colors.ts?");

/***/ }),

/***/ "./guitar/features/caged_feature.ts":
/*!******************************************!*\
  !*** ./guitar/features/caged_feature.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* ts/guitar/features/caged_feature.ts */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CagedFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst scales_1 = __webpack_require__(/*! ../scales */ \"./guitar/scales.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst fretboard_view_1 = __webpack_require__(/*! ../views/fretboard_view */ \"./guitar/views/fretboard_view.ts\");\nconst colors_1 = __webpack_require__(/*! ../colors */ \"./guitar/colors.ts\");\n// Helper function to compare CAGED positions (5 < 1 < 2 < 3 < 4)\nfunction compareCagedPositions(a, b) {\n    if (a === 5 && b === 1)\n        return -1; // 5 always comes first unless compared with itself\n    if (b === 5 && a === 1)\n        return 1; // 5 always comes first unless compared with itself\n    return a - b; // Normal sort order for 1, 2, 3, 4\n}\n// --- Reference CAGED Pattern Data (Key of A Major) ---\n// NOTE: This data MUST be accurately populated for the A Major scale notes\n// within the bounds of each visual CAGED shape across the fretboard.\nconst CAGED_REFERENCE_PATTERNS = [\n    // A-Shape (Position 4)\n    {\n        shape: \"A\",\n        position: 4,\n        notes: [\n            { string: 0, fret: 10 },\n            { string: 0, fret: 12 },\n            { string: 0, fret: 14 }, // Low E root and 2nd\n            { string: 1, fret: 11 },\n            { string: 1, fret: 12 },\n            { string: 1, fret: 14 }, // A string\n            { string: 2, fret: 11 },\n            { string: 2, fret: 12 },\n            { string: 2, fret: 14 }, // D string\n            { string: 3, fret: 11 },\n            { string: 3, fret: 13 },\n            { string: 3, fret: 14 }, // G string\n            { string: 4, fret: 12 },\n            { string: 4, fret: 14 },\n            { string: 4, fret: 15 }, // B string\n            { string: 5, fret: 12 },\n            { string: 5, fret: 14 }, // High E string\n        ],\n    },\n    // G-Shape (Position 5)\n    {\n        shape: \"G\",\n        position: 5,\n        notes: [\n            { string: 0, fret: 2 },\n            { string: 0, fret: 4 },\n            { string: 0, fret: 5 }, // Low E root and 2nd\n            { string: 1, fret: 2 },\n            { string: 1, fret: 4 },\n            { string: 1, fret: 5 }, // A string\n            { string: 2, fret: 2 },\n            { string: 2, fret: 4 }, // D string\n            { string: 3, fret: 1 },\n            { string: 3, fret: 2 },\n            { string: 3, fret: 4 }, // G string\n            { string: 4, fret: 2 },\n            { string: 4, fret: 3 },\n            { string: 4, fret: 5 }, // B string\n            { string: 5, fret: 2 },\n            { string: 5, fret: 4 },\n            { string: 5, fret: 5 }, // High E string\n        ],\n    },\n    // E-Shape (Position 1)\n    {\n        shape: \"E\",\n        position: 1,\n        notes: [\n            { string: 0, fret: 4 },\n            { string: 0, fret: 5 },\n            { string: 0, fret: 7 }, // Low E\n            { string: 1, fret: 4 },\n            { string: 1, fret: 5 },\n            { string: 1, fret: 7 }, // A string\n            { string: 2, fret: 4 },\n            { string: 2, fret: 6 },\n            { string: 2, fret: 7 }, // D string\n            { string: 3, fret: 4 },\n            { string: 3, fret: 6 },\n            { string: 3, fret: 7 }, // G string\n            { string: 4, fret: 5 },\n            { string: 4, fret: 7 }, // B string\n            { string: 5, fret: 4 },\n            { string: 5, fret: 5 },\n            { string: 5, fret: 7 }, // High E string\n        ],\n    },\n    // D-Shape (Position 2)\n    {\n        shape: \"D\",\n        position: 2,\n        notes: [\n            { string: 0, fret: 7 },\n            { string: 0, fret: 9 },\n            { string: 0, fret: 10 }, // Low E\n            { string: 1, fret: 7 },\n            { string: 1, fret: 9 }, // A string\n            { string: 2, fret: 6 },\n            { string: 2, fret: 7 },\n            { string: 2, fret: 9 }, // D string\n            { string: 3, fret: 6 },\n            { string: 3, fret: 7 },\n            { string: 3, fret: 9 }, // G string\n            { string: 4, fret: 7 },\n            { string: 4, fret: 9 },\n            { string: 4, fret: 10 }, // B string\n            { string: 5, fret: 7 },\n            { string: 5, fret: 9 },\n            { string: 5, fret: 10 }, // High E string\n        ],\n    },\n    // C-Shape (Position 3)\n    {\n        shape: \"C\",\n        position: 3,\n        notes: [\n            { string: 0, fret: 9 },\n            { string: 0, fret: 10 },\n            { string: 0, fret: 12 }, // Low E\n            { string: 1, fret: 9 },\n            { string: 1, fret: 11 },\n            { string: 1, fret: 12 }, // A string\n            { string: 2, fret: 9 },\n            { string: 2, fret: 11 },\n            { string: 2, fret: 12 }, // D string\n            { string: 3, fret: 9 },\n            { string: 3, fret: 11 }, // G string\n            { string: 4, fret: 9 },\n            { string: 4, fret: 10 },\n            { string: 4, fret: 12 }, // B string\n            { string: 5, fret: 9 },\n            { string: 5, fret: 10 },\n            { string: 5, fret: 12 }, // High E string\n        ],\n    },\n];\nclass CagedFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, keyIndex, rootNoteName, scaleType, scale, labelDisplay, headerText, settings, intervalSettings, audioController, maxCanvasHeight) {\n        super(config, settings, intervalSettings, audioController, maxCanvasHeight);\n        this.typeName = CagedFeature.typeName;\n        this.keyIndex = keyIndex;\n        this.rootNoteName = rootNoteName;\n        this.scaleType = scaleType;\n        this.scale = scale;\n        this.labelDisplay = labelDisplay;\n        this.headerText = headerText;\n        this.fretCount = 18;\n        this.fretboardViewInstance = new fretboard_view_1.FretboardView(this.fretboardConfig, this.fretCount);\n        this._views.unshift(this.fretboardViewInstance); // Add FretboardView first\n        this.calculateAndSetCagedNotes();\n    }\n    // Static methods (getConfigurationSchema, createFeature) remain the same\n    static getConfigurationSchema() {\n        const availableKeys = guitar_utils_1.MUSIC_NOTES.flat();\n        const availableScales = [\n            \"Major\",\n            \"Minor\",\n            \"Major Pentatonic\",\n            \"Minor Pentatonic\",\n        ];\n        const labelOptions = [\"Interval\", \"Note Name\"];\n        const specificArgs = [\n            {\n                name: \"Key\",\n                type: \"enum\",\n                required: true,\n                enum: availableKeys,\n                description: \"Root note of the scale.\",\n            },\n            {\n                name: \"Scale Type\",\n                type: \"enum\",\n                required: true,\n                enum: availableScales.sort(),\n                description: \"Select the scale to display.\",\n            },\n            {\n                name: \"Label Display\",\n                type: \"enum\",\n                required: true,\n                enum: labelOptions,\n                description: \"Display intervals or note names on the dots.\",\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName},Key,ScaleType,LabelDisplay[,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    static createFeature(config, audioController, settings, intervalSettings, maxCanvasHeight, categoryName) {\n        var _a, _b;\n        if (config.length < 3) {\n            throw new Error(`[${this.typeName}] Invalid config. Expected [Key, ScaleType, LabelDisplay].`);\n        }\n        const rootNoteName = config[0];\n        const scaleTypeName = config[1]; // Keep original name for header/minor check\n        const labelDisplay = config[2];\n        const featureSpecificConfig = [rootNoteName, scaleTypeName, labelDisplay];\n        const keyIndex = (0, guitar_utils_1.getKeyIndex)(rootNoteName);\n        if (keyIndex === -1)\n            throw new Error(`[${this.typeName}] Unknown key: \"${rootNoteName}\"`);\n        const validRootName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[keyIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : rootNoteName;\n        let scaleKey = scales_1.scale_names[scaleTypeName];\n        if (!scaleKey) {\n            scaleKey = scaleTypeName.toUpperCase().replace(/ /g, \"_\");\n        }\n        const scale = scales_1.scales[scaleKey];\n        if (!scale) {\n            throw new Error(`[${this.typeName}] Unsupported or unknown scale type: \"${scaleTypeName}\" (mapped to key \"${scaleKey}\")`);\n        }\n        const validLabelDisplay = labelDisplay === \"Note Name\" || labelDisplay === \"Interval\"\n            ? labelDisplay\n            : \"Interval\";\n        const headerText = `${validRootName} ${scale.name} (${this.displayName})`;\n        const guitarIntervalSettings = intervalSettings;\n        return new CagedFeature(featureSpecificConfig, keyIndex, validRootName, scaleTypeName, // Pass original user-selected name\n        scale, validLabelDisplay, headerText, settings, guitarIntervalSettings, audioController, maxCanvasHeight);\n    }\n    /** Calculates scale notes and their CAGED membership using reference patterns. */\n    /** Calculates scale notes and their CAGED membership using reference patterns. */\n    calculateAndSetCagedNotes() {\n        var _a, _b, _c, _d, _e;\n        const notesData = [];\n        const config = this.fretboardConfig;\n        const tuning = config.tuning.tuning;\n        const fretCount = this.fretCount;\n        // Determine if the selected scale is minor to find the relative major\n        // Use the selected scaleType string for robust checking\n        const isMinorScale = this.scaleType.toLowerCase().includes(\"minor\");\n        const relativeMajorKeyIndex = isMinorScale ? (this.keyIndex + 3) % 12 : this.keyIndex;\n        // Pre-calculate expected fret positions based on the RELATIVE MAJOR key\n        // Map key: \"string:fret\", Value: Array of { shape: CagedShapeName; position: number }\n        const expectedFretLookup = new Map();\n        const referenceKeyIndex = 0; // Reference key is A\n        // Calculate slide offset from reference A to the relative major key\n        const slideOffset = (relativeMajorKeyIndex - referenceKeyIndex + 12) % 12;\n        CAGED_REFERENCE_PATTERNS.forEach(pattern => {\n            pattern.notes.forEach(refNote => {\n                // Calculate all expected frets for this reference note in the target relative major key\n                for (let octave = -2; octave <= 2; octave++) {\n                    const expectedFret = refNote.fret + slideOffset + (octave * 12);\n                    if (expectedFret >= 0 && expectedFret <= fretCount) {\n                        const lookupKey = `${refNote.string}:${expectedFret}`;\n                        const shapes = expectedFretLookup.get(lookupKey) || [];\n                        const newShapeInfo = { shape: pattern.shape, position: pattern.position };\n                        if (!shapes.some(s => s.shape === newShapeInfo.shape)) {\n                            shapes.push(newShapeInfo);\n                            if (shapes.length <= 2) { // Only keep up to 2 shapes\n                                expectedFretLookup.set(lookupKey, shapes);\n                            }\n                        }\n                    }\n                }\n            });\n        });\n        // Iterate through fretboard to find notes in the SELECTED scale (major or minor)\n        for (let stringIndex = 0; stringIndex < 6; stringIndex++) {\n            if (stringIndex >= tuning.length)\n                continue;\n            const stringTuning = tuning[stringIndex];\n            for (let fretIndex = 0; fretIndex <= fretCount; fretIndex++) {\n                const noteOffsetFromA = (stringTuning + fretIndex) % 12;\n                // Calculate note relative to the SELECTED key (this.keyIndex)\n                const noteRelativeToKey = (noteOffsetFromA - this.keyIndex + 12) % 12;\n                // Check if the note is part of the *selected* scale (this.scale)\n                if (this.scale.degrees.includes(noteRelativeToKey)) {\n                    const noteName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[noteOffsetFromA]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n                    const intervalLabel = (0, guitar_utils_1.getIntervalLabel)(noteRelativeToKey);\n                    // Determine CAGED membership by looking up this note's position\n                    // in the lookup map (which is based on the relative major key)\n                    const lookupKey = `${stringIndex}:${fretIndex}`;\n                    const shapeMembershipInfo = expectedFretLookup.get(lookupKey) || []; // Array of {shape, position}\n                    // Determine stroke color based on CAGED membership using NOTE_COLORS\n                    let strokeColor = \"rgba(50, 50, 50, 0.7)\"; // Default subtle stroke\n                    if (shapeMembershipInfo.length === 1) {\n                        const shapeName = shapeMembershipInfo[0].shape;\n                        strokeColor = (_c = colors_1.NOTE_COLORS[shapeName]) !== null && _c !== void 0 ? _c : strokeColor;\n                    }\n                    else if (shapeMembershipInfo.length >= 2) {\n                        // Sort the shapes based on position (5 < 1 < 2 < 3 < 4)\n                        const sortedShapes = shapeMembershipInfo.sort((a, b) => compareCagedPositions(a.position, b.position));\n                        strokeColor = [\n                            (_d = colors_1.NOTE_COLORS[sortedShapes[0].shape]) !== null && _d !== void 0 ? _d : \"grey\",\n                            (_e = colors_1.NOTE_COLORS[sortedShapes[1].shape]) !== null && _e !== void 0 ? _e : \"grey\",\n                        ];\n                    }\n                    // Determine fill color (based on interval relative to the selected key)\n                    const fillColor = (0, colors_1.getColor)(\"interval\", noteName, intervalLabel);\n                    // Determine display label\n                    const displayLabel = this.labelDisplay === \"Interval\" ? intervalLabel : noteName;\n                    // Determine stroke width\n                    const strokeWidth = shapeMembershipInfo.length > 0 ? 3 : 1;\n                    notesData.push({\n                        fret: fretIndex,\n                        stringIndex: stringIndex,\n                        noteName: noteName,\n                        intervalLabel: intervalLabel,\n                        displayLabel: displayLabel,\n                        fillColor: fillColor,\n                        strokeColor: strokeColor,\n                        strokeWidth: strokeWidth,\n                        radiusOverride: fretIndex === 0 ? config.noteRadiusPx * guitar_utils_1.OPEN_NOTE_RADIUS_FACTOR : undefined,\n                    });\n                }\n            }\n        }\n        // Update the view\n        requestAnimationFrame(() => {\n            if (this.fretboardViewInstance) {\n                this.fretboardViewInstance.setNotes(notesData);\n                this.fretboardViewInstance.setLines([]);\n            }\n        });\n    }\n    render(container) {\n        (0, guitar_utils_1.clearAllChildren)(container);\n        (0, guitar_utils_1.addHeader)(container, this.headerText);\n    }\n}\nexports.CagedFeature = CagedFeature;\nCagedFeature.typeName = \"CAGED\";\nCagedFeature.displayName = \"CAGED Scale Shapes\";\nCagedFeature.description = \"Displays notes for a selected scale (Major, Minor, Pentatonics) in a given key. Highlights notes based on the standard Major scale CAGED patterns using stroke colors.\";\n\n\n//# sourceURL=webpack:///./guitar/features/caged_feature.ts?");

/***/ }),

/***/ "./guitar/features/chord_feature.ts":
/*!******************************************!*\
  !*** ./guitar/features/chord_feature.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChordFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst chords_1 = __webpack_require__(/*! ../chords */ \"./guitar/chords.ts\");\nconst chord_diagram_view_1 = __webpack_require__(/*! ../views/chord_diagram_view */ \"./guitar/views/chord_diagram_view.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\n/** A feature for displaying mulitple chord diagrams and a metronome. */\nclass ChordFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, // Chord keys specific to this feature\n    chords, settings, intervalSettings, // Constructor still expects specific type from base class\n    audioController, maxCanvasHeight) {\n        // Pass intervalSettings up to the base constructor\n        super(config, settings, intervalSettings, // Pass specific type here\n        audioController, maxCanvasHeight);\n        this.typeName = ChordFeature.typeName;\n        // Create ChordDiagramViews (metronome view is handled by base constructor)\n        chords.forEach((chord) => {\n            // Use the chord's name property for the diagram title\n            this._views.push(new chord_diagram_view_1.ChordDiagramView(chord, chord.name, this.fretboardConfig));\n        });\n    }\n    // --- Static Methods ---\n    static getConfigurationSchema() {\n        const availableChordNames = Object.keys(chords_1.chord_library);\n        const specificArgs = [\n            {\n                name: \"Chord\", // Changed from \"ChordNames\"\n                type: \"enum\",\n                required: true,\n                enum: availableChordNames,\n                description: \"Select one or more chords.\",\n                isVariadic: true,\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName},ChordName1[,ChordName2,...][,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    // **** UPDATED createFeature Signature ****\n    static createFeature(config, audioController, settings, intervalSettings, // <<< CHANGED: Accept generic base type\n    maxCanvasHeight, categoryName // <<< ADDED: Accept category name string\n    ) {\n        // Separate feature-specific args from potential nested settings args\n        // This simplistic approach assumes chord names are all args before any potential settings object.\n        // A more robust config parser might be needed eventually.\n        const chordKeys = config;\n        if (chordKeys.length < 1) {\n            throw new Error(`Invalid config for ${this.typeName}. Expected at least one ChordName.`);\n        }\n        const chords = [];\n        chordKeys.forEach((chordKey) => {\n            const chord = chords_1.chord_library[chordKey];\n            if (chord) {\n                chords.push(chord);\n            }\n            else {\n                console.warn(`[${this.typeName}] Unknown chord key: \"${chordKey}\". Skipping.`);\n            }\n        });\n        if (chords.length === 0) {\n            throw new Error(`[${this.typeName}] No valid chords found in config: ${config.join(\",\")}`);\n        }\n        // --- Type Assertion for Constructor ---\n        // We assert that the intervalSettings object passed in is actually\n        // GuitarIntervalSettings because the ScheduleBuilder should have used the\n        // correct parser registered by the GuitarCategory.\n        const guitarIntervalSettings = intervalSettings;\n        // --- End Type Assertion ---\n        return new ChordFeature(chordKeys, // Pass only the chord keys as the specific config\n        chords, settings, guitarIntervalSettings, // Pass the asserted specific type\n        audioController, maxCanvasHeight);\n    }\n    /** Render method now just adds the header. Views are rendered by DisplayController. */\n    render(container) {\n        (0, guitar_utils_1.clearAllChildren)(container);\n        const chordViews = this._views.filter((v) => v instanceof chord_diagram_view_1.ChordDiagramView);\n        const uniqueChordNames = [\n            ...new Set(chordViews.map((v) => v.chord.name)), // Use cast if needed\n        ];\n        let headerText = \"Chord Diagram\";\n        if (uniqueChordNames.length === 1) {\n            headerText = `${uniqueChordNames[0]} Chord`;\n        }\n        else if (uniqueChordNames.length > 1) {\n            headerText = uniqueChordNames.slice(0, 3).join(\" / \") + \" Chords\";\n        }\n        (0, guitar_utils_1.addHeader)(container, headerText);\n    }\n}\nexports.ChordFeature = ChordFeature;\n// Static properties (category removed, others unchanged)\n// static readonly category = FeatureCategoryName.Guitar; // Removed\nChordFeature.typeName = \"Chord\";\nChordFeature.displayName = \"Chord Diagram\";\nChordFeature.description = \"Displays one or more chord diagrams.\";\n\n\n//# sourceURL=webpack:///./guitar/features/chord_feature.ts?");

/***/ }),

/***/ "./guitar/features/chord_progression_feature.ts":
/*!******************************************************!*\
  !*** ./guitar/features/chord_progression_feature.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChordProgressionFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst chords_1 = __webpack_require__(/*! ../chords */ \"./guitar/chords.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst progressions_1 = __webpack_require__(/*! ../progressions */ \"./guitar/progressions.ts\");\nconst chord_diagram_view_1 = __webpack_require__(/*! ../views/chord_diagram_view */ \"./guitar/views/chord_diagram_view.ts\");\n/** Displays chord diagrams for a Roman numeral progression in a given key. */\nclass ChordProgressionFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, // Should contain only progression numerals now\n    rootNoteName, progression, headerText, settings, intervalSettings, // Constructor expects specific type\n    audioController, maxCanvasHeight) {\n        super(config, // Pass specific config\n        settings, intervalSettings, // Pass specific type\n        audioController, maxCanvasHeight);\n        this.typeName = ChordProgressionFeature.typeName;\n        this.rootNoteName = rootNoteName;\n        this.progression = progression;\n        this.headerText = headerText;\n        // Create ChordDiagramViews (metronome view is handled by base constructor)\n        const rootNoteIndex = (0, guitar_utils_1.getKeyIndex)(this.rootNoteName);\n        if (rootNoteIndex !== -1) {\n            this.progression.forEach((numeral) => {\n                const chordDetails = (0, progressions_1.getChordInKey)(rootNoteIndex, numeral);\n                const chordData = chordDetails.chordKey\n                    ? chords_1.chord_library[chordDetails.chordKey]\n                    : null;\n                if (chordData) {\n                    const title = `${chordDetails.chordName} (${numeral})`;\n                    // Add view to the mutable _views array from base class\n                    this._views.push(new chord_diagram_view_1.ChordDiagramView(chordData, title, this.fretboardConfig));\n                }\n                else {\n                    console.warn(`[${this.typeName}] Chord data not found for ${chordDetails.chordName} (${numeral}) in key ${this.rootNoteName}`);\n                }\n            });\n        }\n        else {\n            console.error(`[${this.typeName}] Invalid root note provided: ${this.rootNoteName}`);\n        }\n    }\n    // --- Static Methods ---\n    static getConfigurationSchema() {\n        // Unchanged\n        const availableKeys = guitar_utils_1.MUSIC_NOTES.flat();\n        // Corrected progression labels based on actual schema definition in progressions.ts\n        const progressionButtonLabels = [\n            \"I\",\n            \"ii\",\n            \"iii\",\n            \"IV\",\n            \"V\",\n            \"vi\",\n            \"vii°\",\n            \"Imaj7\",\n            \"ii7\",\n            \"iii7\",\n            \"IVmaj7\",\n            \"V7\",\n            \"vi7\",\n            \"viiø7\",\n        ];\n        const specificArgs = [\n            {\n                name: \"RootNote\",\n                type: \"enum\",\n                required: true,\n                enum: availableKeys,\n                description: \"Root note (key) of the progression.\",\n            },\n            {\n                name: \"Progression\",\n                type: \"string\",\n                required: true, // Underlying type is string (joined later if needed)\n                uiComponentType: \"toggle_button_selector\", // Use toggle buttons\n                uiComponentData: { buttonLabels: progressionButtonLabels }, // Provide labels\n                isVariadic: true, // Allow multiple selections\n                description: \"Build the progression sequence using the Roman numeral buttons.\",\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName},RootNote,ProgressionSequence...[,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    // **** UPDATED createFeature Signature ****\n    static createFeature(config, audioController, settings, intervalSettings, // <<< CHANGED: Accept generic base type\n    maxCanvasHeight, categoryName // <<< ADDED: Accept category name string\n    ) {\n        var _a, _b;\n        // --- Parse Config Args ---\n        // Assume RootNote is first, Progression numerals follow.\n        if (config.length < 2) {\n            // Need at least RootNote and one Numeral\n            throw new Error(`[${this.typeName}] Invalid config. Expected [RootNote, Numeral1, ...], received: [${config.join(\", \")}]`);\n        }\n        const rootNoteName = config[0];\n        const progressionNumerals = config.slice(1); // Rest are numerals\n        const keyIndex = (0, guitar_utils_1.getKeyIndex)(rootNoteName);\n        if (keyIndex === -1)\n            throw new Error(`[${this.typeName}] Unknown key: \"${rootNoteName}\"`);\n        const validRootName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[keyIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : rootNoteName;\n        if (progressionNumerals.length === 0) {\n            throw new Error(`[${this.typeName}] Progression cannot be empty.`);\n        }\n        // Basic validation of numerals? Maybe not here. getChordInKey will handle unknown ones.\n        const headerText = `${progressionNumerals.join(\"-\")} Progression in ${validRootName}`;\n        // --- Type Assertion for Constructor ---\n        const guitarIntervalSettings = intervalSettings;\n        // --- End Type Assertion ---\n        // Pass only the progression numerals as the feature-specific config to the constructor\n        return new ChordProgressionFeature(progressionNumerals, // Feature specific args\n        validRootName, progressionNumerals, headerText, settings, guitarIntervalSettings, // Pass asserted specific type\n        audioController, maxCanvasHeight);\n    }\n    /** Render method now just adds the header. Views are rendered by DisplayController. */\n    render(container) {\n        // Unchanged\n        (0, guitar_utils_1.clearAllChildren)(container);\n        (0, guitar_utils_1.addHeader)(container, this.headerText);\n        // DisplayController renders the views (_views) added in the constructor\n    }\n}\nexports.ChordProgressionFeature = ChordProgressionFeature;\n// Static properties (category removed, others unchanged)\n// static readonly category = FeatureCategoryName.Guitar; // Removed\nChordProgressionFeature.typeName = \"Chord Progression\";\nChordProgressionFeature.displayName = \"Chord Progression\";\nChordProgressionFeature.description = \"Displays chord diagrams for a Roman numeral progression (e.g., I-IV-V) in a specified key.\";\n\n\n//# sourceURL=webpack:///./guitar/features/chord_progression_feature.ts?");

/***/ }),

/***/ "./guitar/features/metronome_feature.ts":
/*!**********************************************!*\
  !*** ./guitar/features/metronome_feature.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetronomeFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\n/** A simple feature that only displays a MetronomeView (if BPM > 0). */\nclass MetronomeFeature extends guitar_base_1.GuitarFeature {\n    // --- Static Methods ---\n    static getConfigurationSchema() {\n        // Unchanged\n        return {\n            description: `Config: ${this.typeName}[,GuitarSettings]\\nDisplays a metronome. BPM set via Guitar Settings.`,\n            args: [guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    // **** UPDATED createFeature Signature ****\n    static createFeature(config, audioController, settings, intervalSettings, // <<< CHANGED: Accept generic base type\n    maxCanvasHeight, categoryName // <<< ADDED: Accept category name string\n    ) {\n        // --- Type Assertion for Constructor ---\n        const guitarIntervalSettings = intervalSettings;\n        // --- End Type Assertion ---\n        // Metronome feature has no specific config args itself\n        const featureSpecificConfig = [];\n        return new MetronomeFeature(featureSpecificConfig, // Pass empty array for specific config\n        settings, guitarIntervalSettings, // Pass asserted specific type\n        audioController, maxCanvasHeight);\n    }\n    // Constructor calls super, which handles metronome view creation\n    constructor(config, // Expects empty array or potentially filtered settings args\n    settings, intervalSettings, // Constructor expects specific type\n    audioController, maxCanvasHeight) {\n        // Pass intervalSettings up to the base constructor\n        // The base constructor will extract BPM and create MetronomeView if needed\n        super(config, settings, intervalSettings, audioController, maxCanvasHeight); // Pass specific type\n        this.typeName = MetronomeFeature.typeName;\n        // No feature-specific views to add here\n    }\n    /** Render just adds a header; DisplayController handles the MetronomeView. */\n    render(container) {\n        // **** FIX: Only add header if it doesn't exist ****\n        // Check if a header already exists to avoid duplicates if render is called multiple times\n        if (!container.querySelector(\".feature-header\")) {\n            const headerText = this.metronomeBpm > 0\n                ? `Metronome @ ${this.metronomeBpm} BPM`\n                : \"Metronome (Off)\";\n            const headerEl = (0, guitar_utils_1.addHeader)(container, headerText);\n            headerEl.classList.add(\"feature-header\"); // Add class for identification\n        }\n        // Optional messages can still be added if needed, but don't clear\n        if (this.views.length === 0 && this.metronomeBpm > 0) {\n            if (!container.querySelector(\".metronome-error-msg\")) {\n                const errorMsg = document.createElement(\"p\");\n                errorMsg.textContent =\n                    \"Metronome view could not be created (check console for errors).\";\n                errorMsg.style.padding = \"10px\";\n                errorMsg.style.color = \"var(--clr-danger)\";\n                errorMsg.classList.add(\"metronome-error-msg\");\n                container.appendChild(errorMsg);\n            }\n        }\n        else if (this.views.length === 0 && this.metronomeBpm <= 0) {\n            if (!container.querySelector(\".metronome-off-msg\")) {\n                const offMsg = document.createElement(\"p\");\n                offMsg.textContent = \"Metronome BPM is set to 0.\";\n                offMsg.style.padding = \"10px\";\n                offMsg.style.color = \"var(--clr-text-subtle)\";\n                offMsg.classList.add(\"metronome-off-msg\");\n                container.appendChild(offMsg);\n            }\n        }\n    }\n}\nexports.MetronomeFeature = MetronomeFeature;\n// Static properties (category removed, others unchanged)\n// static readonly category = FeatureCategoryName.Guitar; // Removed\nMetronomeFeature.typeName = \"Metronome\";\nMetronomeFeature.displayName = \"Metronome Only\";\nMetronomeFeature.description = \"Displays only a metronome control/visualizer. BPM is set via Guitar Settings.\";\n\n\n//# sourceURL=webpack:///./guitar/features/metronome_feature.ts?");

/***/ }),

/***/ "./guitar/features/notes_feature.ts":
/*!******************************************!*\
  !*** ./guitar/features/notes_feature.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* ts/guitar/features/notes_feature.ts */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotesFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst fretboard_view_1 = __webpack_require__(/*! ../views/fretboard_view */ \"./guitar/views/fretboard_view.ts\");\n/** A guitar feature for displaying all notes on the fretboard using FretboardView. */\nclass NotesFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, // Should be empty now for NotesFeature specific args\n    settings, rootNoteName, // Pass the parsed rootNoteName\n    intervalSettings, // Constructor expects specific type\n    audioController, maxCanvasHeight) {\n        super(config, settings, intervalSettings, audioController, maxCanvasHeight); // Pass specific type\n        this.typeName = NotesFeature.typeName;\n        this.rootNoteName = rootNoteName;\n        const fretCount = 18;\n        // Create FretboardView instance (Metronome is handled by base class)\n        this.fretboardViewInstance = new fretboard_view_1.FretboardView(this.fretboardConfig, fretCount);\n        this._views.push(this.fretboardViewInstance);\n        this.calculateAndSetNotes(fretCount);\n    }\n    // --- Static Methods ---\n    static getConfigurationSchema() {\n        // Unchanged\n        const availableKeys = [\"None\", ...guitar_utils_1.MUSIC_NOTES.flat()];\n        const specificArgs = [\n            {\n                name: \"RootNote\",\n                type: \"enum\",\n                required: false, // Optional argument\n                enum: availableKeys,\n                description: \"Select 'None' (default) to color by note name, or a root note for interval-based colors.\",\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName}[,RootNote][,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG], // Merge with base\n        };\n    }\n    // **** UPDATED createFeature Signature ****\n    static createFeature(config, audioController, settings, intervalSettings, // <<< CHANGED: Accept generic base type\n    maxCanvasHeight, categoryName // <<< ADDED: Accept category name string\n    ) {\n        let rootNoteName = null;\n        let featureSpecificConfig = []; // NotesFeature has no specific args to pass down\n        // Notes feature has only one optional specific argument: RootNote\n        if (config.length > 0 && config[0]) {\n            const potentialRoot = config[0];\n            if (potentialRoot.toLowerCase() === \"none\") {\n                rootNoteName = null;\n                // featureSpecificConfig remains empty\n            }\n            else if ((0, guitar_utils_1.getKeyIndex)(potentialRoot) !== -1) {\n                rootNoteName = potentialRoot;\n                // featureSpecificConfig remains empty\n            }\n            else {\n                console.warn(`[${this.typeName}] Invalid RootNote value \"${potentialRoot}\", using note-based coloring.`);\n                rootNoteName = null;\n                // featureSpecificConfig remains empty\n            }\n        }\n        else {\n            // No argument provided, default to note-based coloring\n            rootNoteName = null;\n        }\n        // --- Type Assertion for Constructor ---\n        const guitarIntervalSettings = intervalSettings;\n        // --- End Type Assertion ---\n        return new NotesFeature(featureSpecificConfig, // Pass empty array\n        settings, rootNoteName, // Pass parsed root note\n        guitarIntervalSettings, // Pass asserted specific type\n        audioController, maxCanvasHeight);\n    }\n    /** Calculates all note data and passes it to the FretboardView instance. */\n    calculateAndSetNotes(fretCount) {\n        var _a, _b;\n        // Unchanged\n        // ... (Implementation from previous response) ...\n        const notesData = [];\n        const rootNoteIndex = this.rootNoteName\n            ? (0, guitar_utils_1.getKeyIndex)(this.rootNoteName)\n            : -1;\n        const schemeOverride = this.rootNoteName\n            ? \"interval\"\n            : \"note\";\n        const config = this.fretboardConfig;\n        for (let stringIndex = 0; stringIndex < 6; stringIndex++) {\n            if (stringIndex >= config.tuning.tuning.length)\n                continue;\n            const stringTuning = config.tuning.tuning[stringIndex];\n            for (let fretIndex = 0; fretIndex <= fretCount; fretIndex++) {\n                const noteOffsetFromA = (stringTuning + fretIndex) % 12;\n                const noteName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[noteOffsetFromA]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n                let intervalLabel = \"?\";\n                if (rootNoteIndex !== -1) {\n                    const noteRelativeToKey = (noteOffsetFromA - rootNoteIndex + 12) % 12;\n                    intervalLabel = (0, guitar_utils_1.getIntervalLabel)(noteRelativeToKey);\n                }\n                notesData.push({\n                    fret: fretIndex,\n                    stringIndex: stringIndex,\n                    noteName: noteName,\n                    intervalLabel: intervalLabel,\n                    displayLabel: noteName,\n                    colorSchemeOverride: schemeOverride,\n                    radiusOverride: fretIndex === 0\n                        ? config.noteRadiusPx * guitar_utils_1.OPEN_NOTE_RADIUS_FACTOR\n                        : undefined,\n                });\n            }\n        }\n        requestAnimationFrame(() => {\n            if (this.fretboardViewInstance) {\n                this.fretboardViewInstance.setNotes(notesData);\n                this.fretboardViewInstance.setLines([]);\n            }\n        });\n    }\n    render(container) {\n        // Unchanged\n        (0, guitar_utils_1.clearAllChildren)(container);\n        const headerText = this.rootNoteName\n            ? `Notes (Interval Colors Relative to ${this.rootNoteName})`\n            : \"Notes (Note Name Colors)\";\n        (0, guitar_utils_1.addHeader)(container, headerText);\n    }\n}\nexports.NotesFeature = NotesFeature;\n// Static properties (category removed, others unchanged)\n// static readonly category = FeatureCategoryName.Guitar; // Removed\nNotesFeature.typeName = \"Notes\";\nNotesFeature.displayName = \"Fretboard Notes\";\nNotesFeature.description = \"Displays all notes on the fretboard. Select 'None' for note-based colors, or a root note for interval-based colors.\";\n\n\n//# sourceURL=webpack:///./guitar/features/notes_feature.ts?");

/***/ }),

/***/ "./guitar/features/scale_feature.ts":
/*!******************************************!*\
  !*** ./guitar/features/scale_feature.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScaleFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst scales_1 = __webpack_require__(/*! ../scales */ \"./guitar/scales.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\"); // getNotesInScale removed\nconst fretboard_view_1 = __webpack_require__(/*! ../views/fretboard_view */ \"./guitar/views/fretboard_view.ts\");\nconst colors_1 = __webpack_require__(/*! ../colors */ \"./guitar/colors.ts\");\n// Color for non-highlighted scale notes when highlighting is active\nconst NON_HIGHLIGHTED_SCALE_COLOR = \"#CCCCCC\"; // Lighter grey for contrast\nconst OUT_OF_SCALE_HIGHLIGHT_STROKE = \"#E74C3C\"; // Red for out-of-scale highlights\nconst IN_SCALE_HIGHLIGHT_STROKE = \"#333333\"; // Dark grey/black for in-scale highlights\nconst DEFAULT_STROKE = \"rgba(50, 50, 50, 0.7)\"; // Subtle stroke for default interval view\n/** Displays scale diagrams on the fretboard using FretboardView. */\nclass ScaleFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, // [ScaleName, RootNote, ...HighlightNotes]\n    scale, keyIndex, rootNoteName, highlightNotes, headerText, settings, intervalSettings, audioController, maxCanvasHeight) {\n        super(config, settings, intervalSettings, audioController, maxCanvasHeight);\n        this.typeName = ScaleFeature.typeName;\n        this.scale = scale;\n        this.keyIndex = keyIndex;\n        this.rootNoteName = rootNoteName;\n        this.highlightNotes = highlightNotes;\n        this.headerText = headerText;\n        this.fretCount = 18;\n        this.fretboardViewInstance = new fretboard_view_1.FretboardView(this.fretboardConfig, this.fretCount);\n        this._views.unshift(this.fretboardViewInstance);\n        this.calculateAndSetScaleNotes();\n    }\n    // --- Static Methods ---\n    static getConfigurationSchema() {\n        const availableScaleNames = [\n            ...new Set([...Object.keys(scales_1.scales), ...Object.keys(scales_1.scale_names)]),\n        ].sort();\n        const availableKeys = guitar_utils_1.MUSIC_NOTES.flat();\n        // Static list of all notes for the toggle buttons\n        const allNoteNames = guitar_utils_1.MUSIC_NOTES.map((n) => n[0]); // Use primary sharp names\n        const specificArgs = [\n            {\n                name: \"ScaleName\",\n                type: \"enum\",\n                required: true,\n                enum: availableScaleNames,\n                description: \"Name of the scale.\",\n            },\n            {\n                name: \"Root Note\",\n                type: \"enum\",\n                required: true,\n                enum: availableKeys,\n                description: \"Root note of the scale.\",\n            },\n            {\n                name: \"Highlight Notes\",\n                type: \"enum\", // Use enum type\n                required: false,\n                enum: allNoteNames, // Use the static list of all notes\n                uiComponentType: \"toggle_button_selector\",\n                isVariadic: true,\n                uiComponentData: { buttonLabels: allNoteNames }, // Provide static labels\n                description: \"Select notes to highlight. Notes outside the scale get a red border. If none selected, colors based on interval.\",\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName},ScaleName,RootNote[,HighlightNote1,...][,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    static createFeature(config, audioController, settings, intervalSettings, maxCanvasHeight, categoryName) {\n        var _a, _b, _c;\n        if (config.length < 2) {\n            throw new Error(`[${this.typeName}] Invalid config. Expected [ScaleName, RootNote, ...HighlightNotes]. Received: [${config.join(\", \")}]`);\n        }\n        const scaleNameOrAlias = config[0];\n        const rootNoteName = config[1];\n        const highlightNotesArray = config.slice(2);\n        const highlightNotesSet = new Set(highlightNotesArray);\n        const scaleKey = (_a = scales_1.scale_names[scaleNameOrAlias]) !== null && _a !== void 0 ? _a : scaleNameOrAlias.toUpperCase().replace(/ /g, \"_\");\n        const scale = scales_1.scales[scaleKey];\n        if (!scale)\n            throw new Error(`[${this.typeName}] Unknown scale: \"${scaleNameOrAlias}\" (tried key \"${scaleKey}\")`);\n        const keyIndex = (0, guitar_utils_1.getKeyIndex)(rootNoteName);\n        if (keyIndex === -1)\n            throw new Error(`[${this.typeName}] Unknown key: \"${rootNoteName}\"`);\n        const validRootName = (_c = (_b = guitar_utils_1.MUSIC_NOTES[keyIndex]) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : rootNoteName;\n        const headerText = `${validRootName} ${scale.name}`;\n        const guitarIntervalSettings = intervalSettings;\n        const featureSpecificConfig = [\n            scaleNameOrAlias,\n            rootNoteName,\n            ...highlightNotesArray,\n        ];\n        return new ScaleFeature(featureSpecificConfig, scale, keyIndex, validRootName, highlightNotesSet, headerText, settings, guitarIntervalSettings, audioController, maxCanvasHeight);\n    }\n    /** Calculates scale notes and passes them to the FretboardView. */\n    calculateAndSetScaleNotes() {\n        var _a, _b;\n        const notesData = [];\n        const config = this.fretboardConfig;\n        const tuning = config.tuning.tuning;\n        const fretCount = this.fretCount;\n        const highlightingActive = this.highlightNotes.size > 0;\n        for (let stringIndex = 0; stringIndex < 6; stringIndex++) {\n            if (stringIndex >= tuning.length)\n                continue;\n            const stringTuning = tuning[stringIndex];\n            for (let fretIndex = 0; fretIndex <= fretCount; fretIndex++) {\n                const noteOffsetFromA = (stringTuning + fretIndex) % 12;\n                const noteRelativeToKey = (noteOffsetFromA - this.keyIndex + 12) % 12;\n                const noteName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[noteOffsetFromA]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n                const isNoteInScale = this.scale.degrees.includes(noteRelativeToKey);\n                const isNoteHighlighted = this.highlightNotes.has(noteName);\n                let shouldRender = false;\n                let fillColor = colors_1.NOTE_COLORS.DEFAULT;\n                let strokeColor = DEFAULT_STROKE;\n                let strokeWidth = 1;\n                let colorSchemeOverride = undefined;\n                let displayLabel = noteName;\n                if (highlightingActive) {\n                    if (isNoteHighlighted) {\n                        shouldRender = true;\n                        fillColor = colors_1.NOTE_COLORS[noteName] || colors_1.NOTE_COLORS.DEFAULT;\n                        strokeWidth = 1.5; // Slightly thicker stroke for highlighted\n                        strokeColor = isNoteInScale\n                            ? IN_SCALE_HIGHLIGHT_STROKE\n                            : OUT_OF_SCALE_HIGHLIGHT_STROKE;\n                    }\n                    else if (isNoteInScale) {\n                        shouldRender = true;\n                        fillColor = NON_HIGHLIGHTED_SCALE_COLOR;\n                        strokeColor = DEFAULT_STROKE;\n                        strokeWidth = 1;\n                        displayLabel = \"\"; // Hide label for non-highlighted scale notes in highlight mode\n                    }\n                }\n                else {\n                    // No highlighting, default interval coloring\n                    if (isNoteInScale) {\n                        shouldRender = true;\n                        const intervalLabel = (0, guitar_utils_1.getIntervalLabel)(noteRelativeToKey);\n                        fillColor = (0, colors_1.getColor)(\"interval\", noteName, intervalLabel);\n                        colorSchemeOverride = \"interval\";\n                        strokeColor =\n                            intervalLabel === \"R\"\n                                ? IN_SCALE_HIGHLIGHT_STROKE\n                                : DEFAULT_STROKE;\n                        strokeWidth = intervalLabel === \"R\" ? 2.0 : 1;\n                        displayLabel = intervalLabel; // Show interval label in this mode\n                    }\n                }\n                if (shouldRender) {\n                    notesData.push({\n                        fret: fretIndex,\n                        stringIndex: stringIndex,\n                        noteName: noteName,\n                        intervalLabel: (0, guitar_utils_1.getIntervalLabel)(noteRelativeToKey), // Keep interval for potential future use\n                        displayLabel: displayLabel,\n                        fillColor: fillColor,\n                        strokeColor: strokeColor,\n                        strokeWidth: strokeWidth,\n                        colorSchemeOverride: colorSchemeOverride,\n                        radiusOverride: fretIndex === 0\n                            ? config.noteRadiusPx * guitar_utils_1.OPEN_NOTE_RADIUS_FACTOR\n                            : undefined,\n                    });\n                }\n            }\n        }\n        // Update the view\n        requestAnimationFrame(() => {\n            if (this.fretboardViewInstance) {\n                this.fretboardViewInstance.setNotes(notesData);\n                this.fretboardViewInstance.setLines([]);\n            }\n        });\n    }\n    render(container) {\n        (0, guitar_utils_1.clearAllChildren)(container);\n        (0, guitar_utils_1.addHeader)(container, this.headerText);\n    }\n}\nexports.ScaleFeature = ScaleFeature;\nScaleFeature.typeName = \"Scale\";\nScaleFeature.displayName = \"Scale Diagram\";\nScaleFeature.description = \"Displays a specified scale on the fretboard in a given key. Optionally highlight specific notes (highlighted notes outside the scale get a red border).\";\n\n\n//# sourceURL=webpack:///./guitar/features/scale_feature.ts?");

/***/ }),

/***/ "./guitar/features/triad_feature.ts":
/*!******************************************!*\
  !*** ./guitar/features/triad_feature.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TriadFeature = void 0;\nconst guitar_base_1 = __webpack_require__(/*! ../guitar_base */ \"./guitar/guitar_base.ts\");\nconst fretboard_1 = __webpack_require__(/*! ../fretboard */ \"./guitar/fretboard.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst triads_1 = __webpack_require__(/*! ../triads */ \"./guitar/triads.ts\");\nconst fretboard_view_1 = __webpack_require__(/*! ../views/fretboard_view */ \"./guitar/views/fretboard_view.ts\");\nconst guitar_settings_1 = __webpack_require__(/*! ../guitar_settings */ \"./guitar/guitar_settings.ts\");\nconst STRING_GROUPS = [\n    [0, 1, 2],\n    [1, 2, 3],\n    [2, 3, 4],\n    [3, 4, 5],\n];\n/**\n * A dedicated View to render a single row for a given triad quality,\n * containing a header and four FretboardViews. This class is self-contained.\n */\nclass TriadQualityRowView {\n    constructor(quality, rootNoteName, fretboardConfig) {\n        this.fretboardViews = [];\n        this.rowContainer = null;\n        this.diagramsContainer = null; // Keep reference to this\n        this.quality = quality;\n        this.rootNoteName = rootNoteName;\n        this.fretboardConfig = fretboardConfig;\n        const fretCount = 15;\n        let orderedGroups = [...STRING_GROUPS];\n        if (this.fretboardConfig.handedness === \"left\") {\n            orderedGroups.reverse();\n        }\n        orderedGroups.forEach((group) => {\n            const triadData = (0, triads_1.getTriadNotesAndLinesForGroup)(rootNoteName, quality, group, fretCount, fretboardConfig);\n            const view = new fretboard_view_1.FretboardView(fretboardConfig, fretCount);\n            view.setNotes(triadData.notes);\n            view.setLines(triadData.lines);\n            this.fretboardViews.push(view);\n        });\n    }\n    render(container) {\n        // Create the DOM elements only on the first render call\n        if (!this.rowContainer) {\n            this.rowContainer = document.createElement(\"div\");\n            this.rowContainer.className = \"triad-quality-row\";\n            this.rowContainer.style.marginBottom = \"10px\";\n            const header = (0, guitar_utils_1.addHeader)(this.rowContainer, `${this.quality} Triads`);\n            header.style.textAlign = \"left\";\n            header.style.fontSize = \"1.1rem\";\n            this.diagramsContainer = document.createElement(\"div\");\n            this.diagramsContainer.style.display = \"flex\";\n            this.diagramsContainer.style.flexWrap = \"wrap\";\n            this.diagramsContainer.style.gap = \"4px\";\n            this.rowContainer.appendChild(this.diagramsContainer);\n        }\n        // Ensure the main row container is attached to the parent DOM\n        if (this.rowContainer && !this.rowContainer.parentNode) {\n            container.appendChild(this.rowContainer);\n        }\n        // Always call render on the child FretboardViews to ensure they redraw themselves.\n        // The diagramsContainer, which is the parent for the canvases, will be valid.\n        if (this.diagramsContainer) {\n            this.fretboardViews.forEach((view) => {\n                view.render(this.diagramsContainer);\n            });\n        }\n    }\n    start() {\n        /* No-op */\n    }\n    stop() {\n        /* No-op */\n    }\n    destroy() {\n        var _a;\n        this.fretboardViews.forEach((view) => view.destroy());\n        (_a = this.rowContainer) === null || _a === void 0 ? void 0 : _a.remove();\n    }\n}\n/** Displays triad shapes across four 3-string groups for multiple qualities. */\nclass TriadFeature extends guitar_base_1.GuitarFeature {\n    constructor(config, rootNoteName, qualities, mainHeaderText, settings, intervalSettings, audioController, maxCanvasHeight) {\n        var _a, _b;\n        const guitarGlobalSettings = (_a = settings.categorySettings[\"Guitar\"]) !== null && _a !== void 0 ? _a : guitar_settings_1.DEFAULT_GUITAR_SETTINGS;\n        const baseFretboardConfig = new fretboard_1.FretboardConfig((_b = fretboard_1.AVAILABLE_TUNINGS[guitarGlobalSettings.tuning]) !== null && _b !== void 0 ? _b : fretboard_1.STANDARD_TUNING, guitarGlobalSettings.handedness, guitarGlobalSettings.colorScheme, undefined, undefined, undefined, maxCanvasHeight);\n        const featureFretboardConfig = new fretboard_1.FretboardConfig(baseFretboardConfig.tuning, baseFretboardConfig.handedness, baseFretboardConfig.colorScheme, baseFretboardConfig.markerDots, baseFretboardConfig.sideNumbers, baseFretboardConfig.stringWidths, maxCanvasHeight, qualities.length === 1 ? 0.65 : .5);\n        super(config, settings, intervalSettings, audioController, maxCanvasHeight);\n        this.typeName = TriadFeature.typeName;\n        this.rowViews = [];\n        this.fretboardConfig = featureFretboardConfig;\n        this.mainHeaderText = mainHeaderText;\n        // Create and store the row views internally.\n        qualities.forEach((quality) => {\n            this.rowViews.push(new TriadQualityRowView(quality, rootNoteName, this.fretboardConfig));\n        });\n    }\n    static getConfigurationSchema() {\n        const availableKeys = guitar_utils_1.MUSIC_NOTES.flat();\n        const qualities = [\n            \"Major\",\n            \"Minor\",\n            \"Diminished\",\n            \"Augmented\",\n        ];\n        const specificArgs = [\n            {\n                name: \"Root Note\",\n                type: \"enum\",\n                required: true,\n                enum: availableKeys,\n                description: \"Root note of the triads.\",\n            },\n            {\n                name: \"Qualities\",\n                type: \"enum\",\n                required: true,\n                isVariadic: true,\n                uiComponentType: \"toggle_button_selector\",\n                uiComponentData: { buttonLabels: qualities },\n                description: \"Select one or more triad qualities to display.\",\n            },\n        ];\n        return {\n            description: `Config: ${this.typeName},RootNote,Quality1[,Quality2,...][,GuitarSettings]`,\n            args: [...specificArgs, guitar_base_1.GuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG],\n        };\n    }\n    static createFeature(config, audioController, settings, intervalSettings, maxCanvasHeight, categoryName) {\n        var _a, _b;\n        if (config.length < 2) {\n            throw new Error(`[${this.typeName}] Invalid config. Expected [RootNote, Quality1, ...].`);\n        }\n        const rootNoteName = config[0];\n        const qualities = config.slice(1);\n        const keyIndex = (0, guitar_utils_1.getKeyIndex)(rootNoteName);\n        if (keyIndex === -1)\n            throw new Error(`[${this.typeName}] Unknown key: \"${rootNoteName}\"`);\n        const validRootName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[keyIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : rootNoteName;\n        if (qualities.length === 0) {\n            throw new Error(`[${this.typeName}] At least one triad quality must be selected.`);\n        }\n        const mainHeaderText = `${validRootName} Triad Shapes`;\n        const guitarIntervalSettings = intervalSettings;\n        return new TriadFeature(config, validRootName, qualities, mainHeaderText, settings, guitarIntervalSettings, audioController, maxCanvasHeight);\n    }\n    render(container) {\n        (0, guitar_utils_1.clearAllChildren)(container);\n        (0, guitar_utils_1.addHeader)(container, this.mainHeaderText);\n        // Explicitly render our internal row views.\n        this.rowViews.forEach((view) => {\n            view.render(container);\n        });\n        // Also render any views managed by the base class (like the metronome).\n        this._views.forEach((view) => {\n            view.render(container);\n        });\n    }\n    destroy() {\n        var _a;\n        // Clean up our internal views.\n        this.rowViews.forEach((view) => view.destroy());\n        // Call the base class's destroy method to clean up its views (the metronome).\n        (_a = super.destroy) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\nexports.TriadFeature = TriadFeature;\nTriadFeature.typeName = \"Triad Shapes\";\nTriadFeature.displayName = \"Triad Shapes (3-String Sets)\";\nTriadFeature.description = \"Displays triad shapes for selected qualities (Major, Minor, etc.) across all positions for each 3-string set.\";\n\n\n//# sourceURL=webpack:///./guitar/features/triad_feature.ts?");

/***/ }),

/***/ "./guitar/fretboard.ts":
/*!*****************************!*\
  !*** ./guitar/fretboard.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Fretboard = exports.AVAILABLE_TUNINGS = exports.DROP_D_TUNING = exports.STANDARD_TUNING = exports.Tuning = exports.FretboardConfig = exports.NoteIcon = void 0;\nconst guitar_utils_1 = __webpack_require__(/*! ./guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst colors_1 = __webpack_require__(/*! ./colors */ \"./guitar/colors.ts\");\nvar NoteIcon;\n(function (NoteIcon) {\n    NoteIcon[\"None\"] = \"none\";\n    NoteIcon[\"Star\"] = \"star\";\n    NoteIcon[\"Circle\"] = \"circle\";\n    NoteIcon[\"Square\"] = \"square\";\n    NoteIcon[\"Triangle\"] = \"triangle\";\n})(NoteIcon || (exports.NoteIcon = NoteIcon = {}));\n// --- FretboardConfig Class ---\nclass FretboardConfig {\n    constructor(tuning, handedness = \"right\", colorScheme = \"interval\", // <<< FIXED: Changed default from \"default\" to \"interval\"\n    markerDots = [\n        0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 2, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, // Added 0 for 22nd fret\n    ], sideNumbers = [\n        \"\", \"\", \"\", \"III\", \"\", \"V\", \"\", \"VII\", \"\", \"IX\", \"\", \"\",\n        \"XII\", \"\", \"\", \"XV\", \"\", \"XVII\", \"\", \"XIX\", \"\", \"XXI\", \"\", // Added \"\" for 22nd fret\n    ], stringWidths = [3, 3, 2, 2, 1, 1], maxCanvasHeight, globalScaleMultiplier = 1.0) {\n        this.tuning = tuning;\n        this.handedness = handedness;\n        this.colorScheme = colorScheme;\n        this.markerDots = markerDots;\n        this.sideNumbers = sideNumbers;\n        this.stringWidths = stringWidths;\n        this.baseStringSpacingPx = 32;\n        this.baseFretLengthPx = 39;\n        this.baseMarkerDotRadiusPx = 7;\n        this.baseNoteRadiusPx = guitar_utils_1.NOTE_RADIUS_PX;\n        const DEFAULT_FRETBOARD_DRAW_HEIGHT = 650;\n        const ESTIMATED_FRETS_FOR_SCALING = 18;\n        const actualMaxHeight = maxCanvasHeight !== null && maxCanvasHeight !== void 0 ? maxCanvasHeight : DEFAULT_FRETBOARD_DRAW_HEIGHT;\n        const estimatedBaseHeight = this.baseFretLengthPx * ESTIMATED_FRETS_FOR_SCALING + 80;\n        this.scaleFactor =\n            Math.min(1.0, actualMaxHeight / estimatedBaseHeight) *\n                globalScaleMultiplier;\n        this.stringSpacingPx = this.baseStringSpacingPx * this.scaleFactor;\n        this.fretLengthPx = this.baseFretLengthPx * this.scaleFactor;\n        this.markerDotRadiusPx = this.baseMarkerDotRadiusPx * this.scaleFactor;\n        this.noteRadiusPx = this.baseNoteRadiusPx * this.scaleFactor;\n    }\n    getStringWidths() {\n        return this.handedness === \"left\"\n            ? [...this.stringWidths].reverse()\n            : this.stringWidths;\n    }\n}\nexports.FretboardConfig = FretboardConfig;\n// --- Tuning Definitions ---\nclass Tuning {\n    constructor(tuning) {\n        this.tuning = tuning;\n    }\n}\nexports.Tuning = Tuning;\nexports.STANDARD_TUNING = new Tuning([7, 0, 5, 10, 2, 7]);\nexports.DROP_D_TUNING = new Tuning([5, 0, 5, 10, 2, 7]);\nexports.AVAILABLE_TUNINGS = {\n    Standard: exports.STANDARD_TUNING,\n    \"Drop D\": exports.DROP_D_TUNING,\n};\n// --- Fretboard Class ---\nclass Fretboard {\n    constructor(config, leftPx = 45, // Base X position on canvas for drawing start\n    topPx = 45, // Base Y position on canvas for drawing start\n    fretCount // Number of frets to *display*\n    ) {\n        this.config = config;\n        this.leftPx = leftPx;\n        this.topPx = topPx;\n        this.fretCount = fretCount;\n        this.notesToRender = [];\n        this.linesToRender = [];\n        this.startFret = 0; // <<< ADDED: Store the starting fret for rendering\n        // Calculated positions (relative to internal origin)\n        this.nutLineY = 0;\n        this.absoluteTopPx = 0; // Y coordinate for the very top drawing bound (fretboard's topPx)\n        this.absoluteLeftPx = 0; // X coordinate for the very left drawing bound (fretboard's leftPx)\n        // Pre-calculate positions based on scaled config\n        const scaleFactor = this.config.scaleFactor;\n        const scaledNoteRadius = this.config.noteRadiusPx;\n        this.absoluteLeftPx = this.leftPx;\n        this.absoluteTopPx = this.topPx;\n        // Clearance needed above the nut line\n        const openNoteClearance = scaledNoteRadius * 1.5 + 5 * scaleFactor;\n        // The Y coordinate where the nut line (or the first visible fret line if startFret > 0) should be drawn relative to this.topPx\n        this.nutLineY = this.absoluteTopPx + openNoteClearance;\n    }\n    // --- Public Data Setting Methods ---\n    setNotes(notes) {\n        this.notesToRender = notes;\n    }\n    setLines(lines) {\n        this.linesToRender = lines;\n    }\n    clearMarkings() {\n        this.notesToRender = [];\n        this.linesToRender = [];\n    }\n    /** Sets the starting fret number for the diagram display. */\n    setStartFret(fret) {\n        this.startFret = Math.max(0, fret); // Ensure start fret is not negative\n    }\n    // --- Coordinate and Grid Logic ---\n    getStringIndex(visualIndex) {\n        return this.config.handedness === \"left\" ? 5 - visualIndex : visualIndex;\n    }\n    getStringX(visualIndex) {\n        return this.absoluteLeftPx + visualIndex * this.config.stringSpacingPx;\n    }\n    /** Calculates the X, Y coordinates for the center of a note circle on the canvas. */\n    getNoteCoordinates(stringIndex, fret // fret is the *actual* fret number (0 for open, >0 for fretted)\n    ) {\n        const visualStringIndex = this.config.handedness === \"left\" ? 5 - stringIndex : stringIndex;\n        const x = this.getStringX(visualStringIndex);\n        let y;\n        // Calculate fret position relative to the displayed range\n        const displayFret = fret - this.startFret;\n        if (displayFret > 0) {\n            // Note is on a visible fret (not open, not below startFret)\n            y = this.nutLineY + (displayFret - 0.5) * this.config.fretLengthPx;\n        }\n        else {\n            // Note is open (fret=0) or muted (fret=-1)\n            // Position above the first visible line (nut or first fret line)\n            const textBuffer = 5 * this.config.scaleFactor;\n            y = this.nutLineY - this.config.noteRadiusPx - textBuffer;\n            y = Math.max(this.absoluteTopPx + this.config.noteRadiusPx, y);\n        }\n        return { x, y };\n    }\n    // --- Main Render Method ---\n    render(ctx) {\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas\n        this._renderGrid(ctx);\n        this._renderLines(ctx); // Draw lines first (underneath notes)\n        this._renderNotes(ctx); // Draw notes on top\n    }\n    // --- Private Rendering Helpers ---\n    _renderGrid(ctx) {\n        const config = this.config;\n        const scaleFactor = config.scaleFactor;\n        const textHeight = 12 * scaleFactor;\n        const stringWidths = config.getStringWidths();\n        ctx.fillStyle = \"#aaa\"; // Grid color\n        // Strings\n        for (var visualIndex = 0; visualIndex < 6; visualIndex++) {\n            const xPos = this.getStringX(visualIndex);\n            ctx.beginPath();\n            ctx.lineWidth = stringWidths[visualIndex] * scaleFactor; // Scale string width\n            ctx.moveTo(xPos, this.nutLineY); // Start at the first line (nut or fret)\n            const stringBottomY = this.nutLineY + this.fretCount * config.fretLengthPx; // Bottom based on *displayed* fret count\n            ctx.lineTo(xPos, stringBottomY);\n            ctx.strokeStyle = \"#aaa\";\n            ctx.stroke();\n        }\n        // Frets & Markers\n        ctx.font = textHeight + \"px Sans-serif\";\n        ctx.strokeStyle = \"#555\"; // Fret color\n        ctx.fillStyle = \"#aaa\"; // Marker color\n        const totalBoardWidth = 5 * config.stringSpacingPx;\n        const boardCenterX = this.absoluteLeftPx + totalBoardWidth / 2;\n        const defaultFretLineWidth = 1 * scaleFactor;\n        const boldFretLineWidth = 2 * scaleFactor;\n        const sideNumberOffsetX = 18 * scaleFactor;\n        // Draw the first line (nut or starting fret)\n        const firstLineY = this.nutLineY;\n        ctx.beginPath();\n        // Make nut extra thick only if startFret is 0\n        ctx.lineWidth = this.startFret === 0 ? boldFretLineWidth * 1.5 : boldFretLineWidth;\n        ctx.moveTo(this.absoluteLeftPx, firstLineY);\n        ctx.lineTo(this.absoluteLeftPx + totalBoardWidth, firstLineY);\n        ctx.stroke();\n        // Draw subsequent fret lines\n        for (var i = 1; i <= this.fretCount; i++) { // Iterate through *displayed* frets\n            const yPos = this.nutLineY + i * config.fretLengthPx;\n            const actualFretNumber = this.startFret + i; // Calculate the actual fret number\n            const hasSideNumber = actualFretNumber < config.sideNumbers.length && !!config.sideNumbers[actualFretNumber];\n            if (hasSideNumber)\n                ctx.lineWidth = boldFretLineWidth;\n            else\n                ctx.lineWidth = defaultFretLineWidth;\n            ctx.beginPath();\n            ctx.moveTo(this.absoluteLeftPx, yPos);\n            ctx.lineTo(this.absoluteLeftPx + totalBoardWidth, yPos);\n            ctx.stroke();\n            // Side Numbers (position based on *visual* fret index i)\n            if (hasSideNumber && actualFretNumber > 0) {\n                ctx.textAlign = \"right\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(config.sideNumbers[actualFretNumber], // Use actual fret number for lookup\n                this.absoluteLeftPx - sideNumberOffsetX, this.nutLineY + (i - 0.5) * config.fretLengthPx // Position based on visual fret i\n                );\n            }\n            // Marker Dots (position based on *visual* fret index i)\n            const markerY = this.nutLineY + (i - 0.5) * config.fretLengthPx;\n            const scaledMarkerRadius = config.markerDotRadiusPx;\n            const markerDotType = actualFretNumber < config.markerDots.length ? config.markerDots[actualFretNumber] : 0;\n            if (markerDotType === 1) {\n                ctx.beginPath();\n                ctx.arc(boardCenterX, markerY, scaledMarkerRadius, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n            else if (markerDotType === 2) {\n                const markerX1 = this.absoluteLeftPx + 1.5 * config.stringSpacingPx;\n                const markerX2 = this.absoluteLeftPx + 3.5 * config.stringSpacingPx;\n                ctx.beginPath();\n                ctx.arc(markerX1, markerY, scaledMarkerRadius, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.beginPath();\n                ctx.arc(markerX2, markerY, scaledMarkerRadius, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n        ctx.textAlign = \"left\";\n        ctx.lineWidth = 1; // Reset default line width\n    }\n    _renderLines(ctx) {\n        const scaleFactor = this.config.scaleFactor;\n        ctx.save();\n        this.linesToRender.forEach((line) => {\n            ctx.strokeStyle = line.color || \"grey\";\n            // Use provided strokeWidth (unscaled) and apply scaling factor\n            ctx.lineWidth = (line.strokeWidth || 2) * scaleFactor;\n            if (line.dashed) {\n                const dashLength = 4 * scaleFactor;\n                ctx.setLineDash([dashLength, dashLength]);\n            }\n            else {\n                ctx.setLineDash([]);\n            }\n            ctx.beginPath();\n            ctx.moveTo(line.startX, line.startY); // Use pre-calculated scaled coords\n            ctx.lineTo(line.endX, line.endY);\n            ctx.stroke();\n        });\n        ctx.restore();\n    }\n    _renderNotes(ctx) {\n        const scaleFactor = this.config.scaleFactor;\n        const baseFontSize = 16 * scaleFactor; // Base scaled font size\n        const baseNoteRadius = this.config.noteRadiusPx; // Base scaled radius\n        this.notesToRender.forEach((noteData) => {\n            var _a, _b, _c;\n            // Only render notes within the displayed fret range (or open/muted)\n            const displayFret = noteData.fret - this.startFret;\n            if (noteData.fret === -1 || (displayFret >= 0 && displayFret <= this.fretCount)) {\n                if (noteData.fret === -1) {\n                    // Handle muted string\n                    const visualStringIndex = this.config.handedness === \"left\"\n                        ? 5 - noteData.stringIndex\n                        : noteData.stringIndex;\n                    this._drawMutedString(ctx, visualStringIndex, baseNoteRadius);\n                }\n                else {\n                    // Handle open or fretted note\n                    const { x, y } = this.getNoteCoordinates(noteData.stringIndex, noteData.fret // Pass the actual fret\n                    );\n                    const effectiveRadius = (_a = noteData.radiusOverride) !== null && _a !== void 0 ? _a : (noteData.fret === 0\n                        ? baseNoteRadius * guitar_utils_1.OPEN_NOTE_RADIUS_FACTOR\n                        : baseNoteRadius);\n                    const effectiveStrokeWidth = ((_b = noteData.strokeWidth) !== null && _b !== void 0 ? _b : 1) * scaleFactor;\n                    const effectiveColorScheme = (_c = noteData.colorSchemeOverride) !== null && _c !== void 0 ? _c : this.config.colorScheme;\n                    // Determine Fill Color\n                    let finalFillColor = noteData.fillColor ||\n                        (0, colors_1.getColor)(effectiveColorScheme, noteData.noteName, noteData.intervalLabel);\n                    // Determine Stroke Color\n                    let finalStrokeColor = noteData.strokeColor || \"black\"; // Default stroke\n                    // Determine FG color (for text/icon) based on primary fill\n                    const primaryFill = Array.isArray(finalFillColor)\n                        ? finalFillColor[0]\n                        : finalFillColor;\n                    let fgColor = \"#eee\"; // Default light text\n                    if (primaryFill !== \"transparent\") {\n                        try {\n                            const r = parseInt(primaryFill.slice(1, 3), 16);\n                            const g = parseInt(primaryFill.slice(3, 5), 16);\n                            const b = parseInt(primaryFill.slice(5, 7), 16);\n                            const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n                            fgColor = brightness > 150 ? \"#333\" : \"#eee\"; // Dark text on light bg\n                        }\n                        catch (e) {\n                            /* Keep default fgColor if parsing fails */\n                        }\n                    }\n                    // Draw Circle(s)\n                    this._drawCircle(ctx, x, y, effectiveRadius, finalFillColor, finalStrokeColor, effectiveStrokeWidth);\n                    // Determine Content Hierarchy\n                    let contentToDraw = null;\n                    let drawIconType = noteData.icon && noteData.icon !== NoteIcon.None\n                        ? noteData.icon\n                        : undefined;\n                    if (!drawIconType) {\n                        if (noteData.displayLabel !== undefined &&\n                            noteData.displayLabel !== \"\") {\n                            contentToDraw = noteData.displayLabel;\n                        }\n                        else {\n                            // Fallback if displayLabel is empty or undefined\n                            contentToDraw = noteData.noteName;\n                        }\n                    }\n                    // Draw Content (Icon or Text)\n                    if (drawIconType) {\n                        this._drawIcon(ctx, drawIconType, x, y, effectiveRadius, fgColor);\n                    }\n                    else if (contentToDraw) {\n                        // Adjust font size based on radius (especially for smaller open notes)\n                        const fontSizeRatio = 0.9; // How much of the radius the font should occupy vertically\n                        const effectiveFontSize = Math.min(baseFontSize, effectiveRadius * 2 * fontSizeRatio * 0.6); // Heuristic adjustment\n                        this._drawText(ctx, contentToDraw, x, y, effectiveFontSize, fgColor);\n                    }\n                }\n            } // End if note is within display range\n        });\n    }\n    // --- Private Drawing Helpers ---\n    _drawCircle(ctx, x, y, radius, fill, stroke, strokeWidth) {\n        var _a, _b;\n        ctx.save();\n        ctx.lineWidth = strokeWidth;\n        if (Array.isArray(fill) || Array.isArray(stroke)) {\n            // Split Circle Logic\n            const topFill = Array.isArray(fill) ? fill[0] : fill;\n            const bottomFill = Array.isArray(fill) ? (_a = fill[1]) !== null && _a !== void 0 ? _a : fill[0] : fill;\n            const topStroke = Array.isArray(stroke) ? stroke[0] : stroke;\n            const bottomStroke = Array.isArray(stroke)\n                ? (_b = stroke[1]) !== null && _b !== void 0 ? _b : stroke[0]\n                : stroke;\n            // Top Half\n            ctx.beginPath();\n            ctx.arc(x, y, radius, Math.PI, 0); // Top semi-circle path\n            if (topFill !== \"transparent\") {\n                ctx.fillStyle = topFill;\n                ctx.fill();\n            }\n            if (topStroke !== \"transparent\") {\n                ctx.strokeStyle = topStroke;\n                ctx.stroke();\n            }\n            // Bottom Half\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI); // Bottom semi-circle path\n            if (bottomFill !== \"transparent\") {\n                ctx.fillStyle = bottomFill;\n                ctx.fill();\n            }\n            if (bottomStroke !== \"transparent\") {\n                ctx.strokeStyle = bottomStroke;\n                ctx.stroke();\n            }\n            // Draw dividing line for split circles\n            ctx.beginPath();\n            ctx.moveTo(x - radius, y);\n            ctx.lineTo(x + radius, y);\n            // Use an average or default stroke color for the divider? Or maybe primary stroke?\n            ctx.strokeStyle = Array.isArray(stroke) ? stroke[0] : stroke;\n            ctx.stroke();\n        }\n        else {\n            // Solid Circle Logic\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n            if (fill !== \"transparent\") {\n                ctx.fillStyle = fill;\n                ctx.fill();\n            }\n            if (stroke !== \"transparent\") {\n                ctx.strokeStyle = stroke;\n                ctx.stroke();\n            }\n        }\n        ctx.restore();\n    }\n    _drawMutedString(ctx, visualStringIndex, baseScaledRadius) {\n        const x = this.getStringX(visualStringIndex);\n        // Position above the first visible line (nut or starting fret line)\n        const y = this.nutLineY - baseScaledRadius * 1.5;\n        const size = baseScaledRadius * 0.55; // Size based on note radius\n        ctx.save();\n        ctx.strokeStyle = \"#555\";\n        ctx.lineWidth = 1.5 * this.config.scaleFactor;\n        ctx.beginPath();\n        ctx.moveTo(x - size, y - size);\n        ctx.lineTo(x + size, y + size);\n        ctx.moveTo(x + size, y - size);\n        ctx.lineTo(x - size, y + size);\n        ctx.stroke();\n        ctx.restore();\n    }\n    _drawText(ctx, text, x, y, fontSize, color) {\n        ctx.save();\n        ctx.fillStyle = color;\n        ctx.font = `bold ${fontSize}px Sans-serif`; // Consider making font configurable, added bold\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        const textYOffset = fontSize * 0.05; // Small adjustment for visual centering\n        ctx.fillText(text, x, y + textYOffset);\n        ctx.restore();\n    }\n    _drawIcon(ctx, icon, x, y, radius, color) {\n        ctx.save();\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color; // Icons are typically solid color\n        ctx.lineWidth = 1 * this.config.scaleFactor; // Thin line for icons\n        const iconSize = radius * 0.7; // Size relative to note radius\n        switch (icon) {\n            case NoteIcon.Star:\n                this._drawStarIcon(ctx, x, y, iconSize); // Call helper\n                break;\n            case NoteIcon.Circle:\n                ctx.beginPath();\n                ctx.arc(x, y, iconSize / 2, 0, 2 * Math.PI);\n                //ctx.fill(); // Fill or stroke for circle? Let's stroke.\n                ctx.stroke();\n                break;\n            case NoteIcon.Square:\n                ctx.fillRect(x - iconSize / 2, y - iconSize / 2, iconSize, iconSize);\n                break;\n            case NoteIcon.Triangle:\n                ctx.beginPath();\n                ctx.moveTo(x, y - iconSize / 1.7); // Top point\n                ctx.lineTo(x + iconSize / 1.7, y + iconSize / 3.4); // Bottom right\n                ctx.lineTo(x - iconSize / 1.7, y + iconSize / 3.4); // Bottom left\n                ctx.closePath();\n                ctx.fill();\n                break;\n            // Add cases for other icons\n            case NoteIcon.None:\n            default:\n                break; // Do nothing\n        }\n        ctx.restore();\n    }\n    _drawStarIcon(ctx, cx, cy, outerRadius) {\n        const spikes = 5;\n        const innerRadius = outerRadius * 0.4; // Adjust for star point sharpness\n        let rot = (Math.PI / 2) * 3;\n        let x = cx;\n        let y = cy;\n        const step = Math.PI / spikes;\n        ctx.beginPath();\n        ctx.moveTo(cx, cy - outerRadius);\n        for (let i = 0; i < spikes; i++) {\n            x = cx + Math.cos(rot) * outerRadius;\n            y = cy + Math.sin(rot) * outerRadius;\n            ctx.lineTo(x, y);\n            rot += step;\n            x = cx + Math.cos(rot) * innerRadius;\n            y = cy + Math.sin(rot) * innerRadius;\n            ctx.lineTo(x, y);\n            rot += step;\n        }\n        ctx.lineTo(cx, cy - outerRadius);\n        ctx.closePath();\n        ctx.fill(); // Fill the star\n    }\n}\nexports.Fretboard = Fretboard;\n\n\n//# sourceURL=webpack:///./guitar/fretboard.ts?");

/***/ }),

/***/ "./guitar/guitar_base.ts":
/*!*******************************!*\
  !*** ./guitar/guitar_base.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GuitarFeature = void 0;\nconst metronome_view_1 = __webpack_require__(/*! ./views/metronome_view */ \"./guitar/views/metronome_view.ts\");\nconst fretboard_1 = __webpack_require__(/*! ./fretboard */ \"./guitar/fretboard.ts\");\nconst settings_1 = __webpack_require__(/*! ../settings */ \"./settings.ts\");\nconst guitar_settings_1 = __webpack_require__(/*! ./guitar_settings */ \"./guitar/guitar_settings.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ./guitar_utils */ \"./guitar/guitar_utils.ts\");\n/**\n * Base class for all Guitar-related features.\n * Handles common setup like FretboardConfig and conditional MetronomeView creation based on interval settings.\n */\nclass GuitarFeature {\n    get views() {\n        // Expose as readonly externally\n        return this._views;\n    }\n    constructor(config, settings, intervalSettings, audioController, maxCanvasHeight) {\n        var _a, _b;\n        this._views = []; // Mutable array for internal use\n        this.metronomeBpm = 0;\n        this.config = config;\n        this.settings = settings;\n        this.maxCanvasHeight = maxCanvasHeight;\n        this.audioController = audioController;\n        const guitarGlobalSettings = (_a = (0, settings_1.getCategorySettings)(settings, guitar_settings_1.GUITAR_SETTINGS_KEY)) !== null && _a !== void 0 ? _a : guitar_settings_1.DEFAULT_GUITAR_SETTINGS;\n        const tuningName = fretboard_1.AVAILABLE_TUNINGS[guitarGlobalSettings.tuning]\n            ? guitarGlobalSettings.tuning\n            : \"Standard\";\n        const tuning = fretboard_1.AVAILABLE_TUNINGS[tuningName];\n        this.fretboardConfig = new fretboard_1.FretboardConfig(tuning, guitarGlobalSettings.handedness, guitarGlobalSettings.colorScheme, undefined, // markerDots\n        undefined, // sideNumbers\n        undefined, // stringWidths\n        this.maxCanvasHeight);\n        // --- Metronome Handling ---\n        let metronomeViewInstance = null;\n        this.metronomeBpm = (_b = intervalSettings === null || intervalSettings === void 0 ? void 0 : intervalSettings.metronomeBpm) !== null && _b !== void 0 ? _b : 0;\n        if (this.metronomeBpm > 0) {\n            if (this.audioController &&\n                this.audioController.metronomeAudioEl &&\n                this.audioController.accentMetronomeAudioEl) {\n                metronomeViewInstance = new metronome_view_1.MetronomeView(this.metronomeBpm, this.audioController);\n            }\n            else {\n                console.warn(`Metronome requested (BPM: ${this.metronomeBpm}) but audio elements/controller missing. MetronomeView not created.`);\n            }\n        }\n        // Subclasses add their views to this._views BEFORE calling super.\n        // Add the metronome view if created, ensuring it's last.\n        if (metronomeViewInstance) {\n            this._views.push(metronomeViewInstance);\n        }\n    }\n    // Common lifecycle methods\n    prepare() {\n        this._views.forEach((view) => {\n            if (typeof view.prepare === \"function\") {\n                view.prepare();\n            }\n        });\n    }\n    start() {\n        this._views.forEach((view) => view.start());\n    }\n    stop() {\n        this._views.forEach((view) => view.stop());\n    }\n    destroy() {\n        this._views.forEach((view) => view.destroy());\n    }\n    // Helper for canvas setup\n    clearAndAddCanvas(container, headerText) {\n        (0, guitar_utils_1.clearAllChildren)(container);\n        (0, guitar_utils_1.addHeader)(container, headerText);\n        const uniqueSuffix = `${this.typeName}-${Math.random().toString(36).substring(2, 9)}`;\n        const canvasEl = (0, guitar_utils_1.addCanvas)(container, uniqueSuffix);\n        const ctx = canvasEl.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(`Could not get 2D context for canvas in feature ${this.typeName}.`);\n        }\n        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);\n        ctx.resetTransform(); // Use resetTransform for modern canvas state clearing\n        // Optional: Translate for sharper lines\n        // ctx.translate(0.5, 0.5);\n        return { canvas: canvasEl, ctx: ctx };\n    }\n}\nexports.GuitarFeature = GuitarFeature;\nGuitarFeature.BASE_GUITAR_SETTINGS_CONFIG_ARG = {\n    name: \"\",\n    type: \"ellipsis\",\n    uiComponentType: \"ellipsis\",\n    description: \"Configure interval-specific settings (e.g., Metronome).\",\n    nestedSchema: [\n        {\n            name: \"metronomeBpm\",\n            type: \"number\",\n            description: \"Metronome BPM (0=off)\",\n        },\n    ],\n};\n\n\n//# sourceURL=webpack:///./guitar/guitar_base.ts?");

/***/ }),

/***/ "./guitar/guitar_category.ts":
/*!***********************************!*\
  !*** ./guitar/guitar_category.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GuitarCategory = void 0;\n// Import Guitar Features\nconst notes_feature_1 = __webpack_require__(/*! ./features/notes_feature */ \"./guitar/features/notes_feature.ts\");\nconst scale_feature_1 = __webpack_require__(/*! ./features/scale_feature */ \"./guitar/features/scale_feature.ts\");\nconst chord_feature_1 = __webpack_require__(/*! ./features/chord_feature */ \"./guitar/features/chord_feature.ts\");\nconst chord_progression_feature_1 = __webpack_require__(/*! ./features/chord_progression_feature */ \"./guitar/features/chord_progression_feature.ts\");\nconst triad_feature_1 = __webpack_require__(/*! ./features/triad_feature */ \"./guitar/features/triad_feature.ts\");\nconst metronome_feature_1 = __webpack_require__(/*! ./features/metronome_feature */ \"./guitar/features/metronome_feature.ts\");\nconst floating_view_registry_1 = __webpack_require__(/*! ../floating_views/floating_view_registry */ \"./floating_views/floating_view_registry.ts\");\nconst color_legend_view_1 = __webpack_require__(/*! ./views/color_legend_view */ \"./guitar/views/color_legend_view.ts\");\nconst floating_metronome_view_1 = __webpack_require__(/*! ./views/floating_metronome_view */ \"./guitar/views/floating_metronome_view.ts\");\nconst fretboard_reference_view_1 = __webpack_require__(/*! ./views/fretboard_reference_view */ \"./guitar/views/fretboard_reference_view.ts\");\n// Import Guitar Settings related items\nconst guitar_settings_1 = __webpack_require__(/*! ./guitar_settings */ \"./guitar/guitar_settings.ts\");\nconst guitar_interval_settings_1 = __webpack_require__(/*! ./guitar_interval_settings */ \"./guitar/guitar_interval_settings.ts\");\n// Helper function imports (for settings UI schema)\nconst fretboard_1 = __webpack_require__(/*! ./fretboard */ \"./guitar/fretboard.ts\");\nconst caged_feature_1 = __webpack_require__(/*! ./features/caged_feature */ \"./guitar/features/caged_feature.ts\");\n// Helper function to generate UI Schema (can be kept here or imported)\nfunction getGuitarGlobalSettingsUISchema() {\n    const tuningOptions = Object.keys(fretboard_1.AVAILABLE_TUNINGS).map((key) => ({\n        value: key,\n        text: key,\n    }));\n    const handednessOptions = [\n        { value: \"right\", text: \"Right-Handed\" },\n        { value: \"left\", text: \"Left-Handed\" },\n    ];\n    // Updated color scheme options\n    const colorSchemeOptions = [\n        { value: \"interval\", text: \"Interval Colors (Default)\" }, // Interval is default\n        { value: \"note\", text: \"Note Name Colors\" },\n        { value: \"simplified\", text: \"Simplified (Root Only)\" }, // Renamed from \"Default\"\n    ];\n    return [\n        {\n            key: \"handedness\",\n            label: \"Diagram Handedness\",\n            type: \"select\",\n            options: handednessOptions,\n            description: \"Orientation of fretboard diagrams.\",\n        },\n        {\n            key: \"tuning\",\n            label: \"Tuning\",\n            type: \"select\",\n            options: tuningOptions,\n            description: \"Select the guitar tuning.\",\n        },\n        {\n            key: \"colorScheme\",\n            label: \"Fretboard Color Scheme\",\n            type: \"select\",\n            options: colorSchemeOptions,\n            description: \"How notes on the fretboard are colored.\",\n        },\n    ];\n}\nclass GuitarCategory {\n    constructor() {\n        this.name = \"Guitar\";\n        this.displayName = \"Guitar Tools\";\n        // Instantiate the map of features provided by this category\n        this.featureTypes = new Map([\n            [notes_feature_1.NotesFeature.typeName, notes_feature_1.NotesFeature],\n            [scale_feature_1.ScaleFeature.typeName, scale_feature_1.ScaleFeature],\n            [chord_feature_1.ChordFeature.typeName, chord_feature_1.ChordFeature],\n            [\n                chord_progression_feature_1.ChordProgressionFeature.typeName,\n                chord_progression_feature_1.ChordProgressionFeature,\n            ],\n            [triad_feature_1.TriadFeature.typeName, triad_feature_1.TriadFeature],\n            [caged_feature_1.CagedFeature.typeName, caged_feature_1.CagedFeature],\n            [\n                metronome_feature_1.MetronomeFeature.typeName,\n                metronome_feature_1.MetronomeFeature,\n            ],\n        ]);\n        this.registerFloatingViews();\n    }\n    registerFloatingViews() {\n        (0, floating_view_registry_1.registerFloatingView)({\n            viewId: \"guitar_color_legend\", // Unique ID\n            displayName: \"Color Legend\", // User-facing name\n            categoryName: this.getName(), // Associate with Guitar category\n            defaultWidth: 180, // Example default size\n            // Factory needs access to AppSettings to get current scheme\n            createView: (initialState, appSettings) => {\n                if (!appSettings) {\n                    console.error(\"AppSettings not provided to ColorLegendView factory!\");\n                    // Return a dummy view or throw error\n                    return {\n                        render: (c) => (c.textContent = \"Error: Settings unavailable.\"),\n                        start() { },\n                        stop() { },\n                        destroy() { },\n                    };\n                }\n                return new color_legend_view_1.ColorLegendView(appSettings);\n            },\n        });\n        (0, floating_view_registry_1.registerFloatingView)({\n            viewId: \"guitar_fretboard_reference\", // Unique ID\n            displayName: \"Fretboard Reference\", // Name for the dropdown menu\n            categoryName: this.getName(),\n            defaultWidth: 180, // A bit wider to accommodate the fretboard\n            defaultHeight: 550, // Taller to show more frets\n            createView: (initialState, appSettings) => {\n                return new fretboard_reference_view_1.FretboardReferenceView(appSettings);\n            },\n        });\n        (0, floating_view_registry_1.registerFloatingView)({\n            viewId: \"guitar_floating_metronome\",\n            displayName: \"Metronome\",\n            categoryName: this.getName(),\n            defaultWidth: 280,\n            defaultHeight: 150,\n            createView: (initialState, appSettings) => {\n                return new floating_metronome_view_1.FloatingMetronomeView(appSettings);\n            },\n        });\n    }\n    getName() {\n        return this.name;\n    }\n    getDisplayName() {\n        return this.displayName;\n    }\n    getFeatureTypes() {\n        return this.featureTypes;\n    }\n    getDefaultGlobalSettings() {\n        // Return a copy to prevent modification of the original default\n        return Object.assign({}, guitar_settings_1.DEFAULT_GUITAR_SETTINGS);\n    }\n    getIntervalSettingsFactory() {\n        // Return a function that creates a new default instance\n        return () => new guitar_interval_settings_1.GuitarIntervalSettings();\n    }\n    createIntervalSettingsFromJSON(json) {\n        // Use the static method on the specific class\n        // Cast the input json; the registry ensures this method is called for the correct category.\n        return guitar_interval_settings_1.GuitarIntervalSettings.fromJSON(json);\n    }\n    getGlobalSettingsUISchema() {\n        // Return the schema for the Guitar category's global settings\n        return getGuitarGlobalSettingsUISchema();\n    }\n    /** Returns a default set of intervals for a simple guitar schedule */\n    getDefaultIntervals() {\n        // Use the factory to get default settings for these intervals\n        const defaultIntervalSettings = this.getIntervalSettingsFactory()();\n        return [\n            {\n                rowType: \"interval\",\n                duration: \"5:00\",\n                task: \"Warmup\",\n                categoryName: this.getName(), // Use own name\n                featureTypeName: \"Notes\",\n                featureArgsList: [],\n                intervalSettings: defaultIntervalSettings, // Assign instance\n            },\n            { rowType: \"group\", level: 1, name: \"Scale Practice\" },\n            {\n                rowType: \"interval\",\n                duration: \"3:00\",\n                task: \"C Major Scale\",\n                categoryName: this.getName(),\n                featureTypeName: \"Scale\",\n                featureArgsList: [\"Major\", \"C\"],\n                intervalSettings: defaultIntervalSettings, // Assign instance\n            },\n            {\n                rowType: \"interval\",\n                duration: \"3:00\",\n                task: \"G Major Scale\",\n                categoryName: this.getName(),\n                featureTypeName: \"Scale\",\n                featureArgsList: [\"Major\", \"G\"],\n                intervalSettings: defaultIntervalSettings, // Assign instance\n            },\n        ];\n    }\n}\nexports.GuitarCategory = GuitarCategory;\n\n\n//# sourceURL=webpack:///./guitar/guitar_category.ts?");

/***/ }),

/***/ "./guitar/guitar_interval_settings.ts":
/*!********************************************!*\
  !*** ./guitar/guitar_interval_settings.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Defines settings specific to a guitar feature within a single interval.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GuitarIntervalSettings = void 0;\nclass GuitarIntervalSettings {\n    constructor(metronomeBpm) {\n        // Use provided BPM if valid, otherwise default\n        this.metronomeBpm =\n            metronomeBpm !== undefined && metronomeBpm >= 0\n                ? metronomeBpm\n                : GuitarIntervalSettings.DEFAULT_METRONOME_BPM;\n    }\n    /**\n     * Creates a GuitarIntervalSettings instance from a JSON object.\n     * @param json - The JSON object (or undefined).\n     * @returns A new GuitarIntervalSettings instance.\n     */\n    static fromJSON(json) {\n        // Create instance with defaults\n        const settings = new GuitarIntervalSettings();\n        if (json) {\n            // Apply valid values from JSON\n            if (json.metronomeBpm !== undefined && json.metronomeBpm >= 0) {\n                settings.metronomeBpm = json.metronomeBpm;\n            }\n            else if (json.metronomeBpm !== undefined) {\n                console.warn(`Invalid metronomeBpm value in JSON (${json.metronomeBpm}), using default.`);\n            }\n            // Add logic for other settings here if they exist\n        }\n        return settings;\n    }\n    /**\n     * Serializes the settings into a JSON object suitable for `JSON.stringify`.\n     * Only includes non-default values.\n     * @returns A JSON object or undefined if all settings are default.\n     */\n    toJSON() {\n        if (this.isDefault()) {\n            return undefined; // Don't include settings object if it's all default\n        }\n        const json = {};\n        if (this.metronomeBpm !== GuitarIntervalSettings.DEFAULT_METRONOME_BPM) {\n            json.metronomeBpm = this.metronomeBpm;\n        }\n        // Add other non-default settings here\n        // Check if any non-default values were actually added\n        return Object.keys(json).length > 0 ? json : undefined;\n    }\n    /** Returns true if the settings are default (currently just checks BPM). */\n    isDefault() {\n        return this.metronomeBpm === GuitarIntervalSettings.DEFAULT_METRONOME_BPM;\n        // Add checks for other settings here: && this.otherSetting === DEFAULT_OTHER ...\n    }\n}\nexports.GuitarIntervalSettings = GuitarIntervalSettings;\n// Default settings for a guitar interval\nGuitarIntervalSettings.DEFAULT_METRONOME_BPM = 0; // Default to OFF unless overridden\n\n\n//# sourceURL=webpack:///./guitar/guitar_interval_settings.ts?");

/***/ }),

/***/ "./guitar/guitar_settings.ts":
/*!***********************************!*\
  !*** ./guitar/guitar_settings.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GUITAR_SETTINGS_KEY = exports.DEFAULT_GUITAR_SETTINGS = void 0;\n/** Default values for Guitar settings. */\nexports.DEFAULT_GUITAR_SETTINGS = {\n    handedness: \"right\",\n    tuning: \"Standard\",\n    colorScheme: \"interval\",\n};\n/**\n * Storage key for guitar-specific settings within AppSettings' categorySettings map.\n * Uses the string name of the category.\n */\nexports.GUITAR_SETTINGS_KEY = \"Guitar\";\n\n\n//# sourceURL=webpack:///./guitar/guitar_settings.ts?");

/***/ }),

/***/ "./guitar/guitar_utils.ts":
/*!********************************!*\
  !*** ./guitar/guitar_utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MUSIC_NOTES = exports.CANVAS_SUBTITLE_FONT = exports.CANVAS_SUBTITLE_HEIGHT_PX = exports.CANVAS_HEIGHT_PX = exports.CANVAS_WIDTH_PX = exports.OPEN_NOTE_RADIUS_FACTOR = exports.NOTE_RADIUS_PX = exports.START_PX = void 0;\nexports.clearAllChildren = clearAllChildren;\nexports.addHeader = addHeader;\nexports.addCanvas = addCanvas;\nexports.getKeyIndex = getKeyIndex;\nexports.getChordTones = getChordTones;\nexports.getIntervalLabel = getIntervalLabel;\nexports.getNotesInScale = getNotesInScale;\n// Feature configuration constants\nexports.START_PX = 35;\nexports.NOTE_RADIUS_PX = 14; // Base radius\nexports.OPEN_NOTE_RADIUS_FACTOR = 0.7; // Make open note circles smaller\nexports.CANVAS_WIDTH_PX = 400;\nexports.CANVAS_HEIGHT_PX = 500;\nexports.CANVAS_SUBTITLE_HEIGHT_PX = 25;\nexports.CANVAS_SUBTITLE_FONT = '14px sans-serif';\n// Musical constants\nexports.MUSIC_NOTES = [\n    ['A'], ['A#', 'Bb'], ['B'], ['C'], ['C#', 'Db'], ['D'],\n    ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'],\n];\n// --- Utility Functions ---\n/** Clears all child elements from a given HTML element */\nfunction clearAllChildren(element) {\n    while (element.firstChild) {\n        element.removeChild(element.firstChild);\n    }\n}\n/** Adds a simple h4 header element to a container */\nfunction addHeader(container, text) {\n    const header = document.createElement('h4');\n    header.classList.add('title', 'is-6'); // Example Bulma classes\n    header.style.textAlign = 'center';\n    header.textContent = text;\n    container.appendChild(header);\n    return header;\n}\n/** Adds a canvas element to a container */\nfunction addCanvas(container, idSuffix) {\n    const canvas = document.createElement('canvas');\n    // Ensure unique ID, especially if multiple diagrams are rendered\n    canvas.id = `canvas-${idSuffix}-${Math.random().toString(36).substring(2, 9)}`;\n    canvas.width = exports.CANVAS_WIDTH_PX;\n    canvas.height = exports.CANVAS_HEIGHT_PX;\n    container.appendChild(canvas);\n    return canvas;\n}\n/** Finds the primary index (0-11) for a given note name (e.g., C, Db, F#) */\nfunction getKeyIndex(noteName) {\n    if (!noteName)\n        return -1;\n    // Normalize input slightly (e.g., lowercase, trim) - optional\n    const normalizedNote = noteName.trim(); //.toUpperCase(); - keep case for now\n    return exports.MUSIC_NOTES.findIndex(group => group.includes(normalizedNote));\n}\n/** Gets chord tones for highlighting (simple implementation) */\nfunction getChordTones(chordTonesStr) {\n    if (!chordTonesStr)\n        return [];\n    return chordTonesStr.split('|').map(group => group.split('-').map(n => n.trim()).filter(n => n));\n}\n/**\n * Gets a standard interval label (e.g., 'R', 'b3', '5', '7') from a semitone offset.\n * @param offset - Semitones relative to the root (0-11).\n * @returns The interval label string.\n */\nfunction getIntervalLabel(offset) {\n    var _a;\n    const labels = {\n        0: \"R\", // Root\n        1: \"b2\", // Minor Second\n        2: \"2\", // Major Second\n        3: \"b3\", // Minor Third\n        4: \"3\", // Major Third\n        5: \"4\", // Perfect Fourth\n        6: \"d5\", // Diminished Fifth (Tritone) - can also be #4\n        7: \"5\", // Perfect Fifth\n        8: \"b6\", // Minor Sixth (or #5)\n        9: \"6\", // Major Sixth\n        10: \"b7\", // Minor Seventh\n        11: \"7\", // Major Seventh (often denoted M7, but using 7 for brevity)\n    };\n    return (_a = labels[offset % 12]) !== null && _a !== void 0 ? _a : \"?\"; // Use modulo 12 and handle unexpected offsets\n}\n/**\n * Gets the names of the notes in a given scale and root.\n * @param scale - The Scale object.\n * @param rootNoteIndex - The index (0-11) of the root note.\n * @returns An array of note name strings (e.g., [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"]).\n */\nfunction getNotesInScale(scale, rootNoteIndex) {\n    if (rootNoteIndex < 0 || rootNoteIndex > 11)\n        return [];\n    return scale.degrees.map(degree => {\n        var _a, _b;\n        const noteIndex = (rootNoteIndex + degree) % 12;\n        // Return the primary name (first element) from the MUSIC_NOTES group\n        return (_b = (_a = exports.MUSIC_NOTES[noteIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n    });\n}\n\n\n//# sourceURL=webpack:///./guitar/guitar_utils.ts?");

/***/ }),

/***/ "./guitar/progressions.ts":
/*!********************************!*\
  !*** ./guitar/progressions.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getChordInKey = getChordInKey;\nconst guitar_utils_1 = __webpack_require__(/*! ./guitar_utils */ \"./guitar/guitar_utils.ts\");\nconst chords_1 = __webpack_require__(/*! ./chords */ \"./guitar/chords.ts\"); // Import chord library\n/**\n * Represents the mapping from a Roman numeral in a major key context\n * to its scale degree (0-11) and default chord quality.\n */\nconst MAJOR_KEY_ROMAN_MAP = {\n    // Diatonic Triads\n    \"I\": { degree: 0, quality: \"Major\" }, // Tonic Major\n    \"ii\": { degree: 2, quality: \"Minor\" }, // Supertonic Minor\n    \"iii\": { degree: 4, quality: \"Minor\" }, // Mediant Minor\n    \"IV\": { degree: 5, quality: \"Major\" }, // Subdominant Major\n    \"V\": { degree: 7, quality: \"Major\" }, // Dominant Major\n    \"vi\": { degree: 9, quality: \"Minor\" }, // Submediant Minor\n    \"vii°\": { degree: 11, quality: \"Diminished\" }, // Leading Tone Diminished\n    // Common Diatonic 7ths (can be expanded)\n    \"Imaj7\": { degree: 0, quality: \"Major7th\" },\n    \"ii7\": { degree: 2, quality: \"Minor7th\" },\n    \"iii7\": { degree: 4, quality: \"Minor7th\" },\n    \"IVmaj7\": { degree: 5, quality: \"Major7th\" },\n    \"V7\": { degree: 7, quality: \"Dominant7th\" },\n    \"vi7\": { degree: 9, quality: \"Minor7th\" },\n    \"viiø7\": { degree: 11, quality: \"Minor7th\" }, // Half-diminished (m7b5) - approximate for now\n    // Aliases or variations can be added here (e.g., \"V/V\")\n    // TODO: Add support for secondary dominants, borrowed chords, etc.\n};\n/**\n * Simple helper to map quality types to common suffixes used in chord_library keys.\n * This is a basic mapping and might need refinement based on chord_library structure.\n */\nfunction qualityToChordKeySuffix(quality) {\n    switch (quality) {\n        case \"Major\": return \"_MAJOR\"; // Assuming MAJOR suffix exists\n        case \"Minor\": return \"_MINOR\"; // Assuming MINOR suffix exists\n        case \"Diminished\": return \"_DIM\"; // Placeholder - Check chord_library\n        case \"Augmented\": return \"_AUG\"; // Placeholder - Check chord_library\n        case \"Dominant7th\": return \"7\"; // Common notation\n        case \"Major7th\": return \"MAJ7\"; // Common notation\n        case \"Minor7th\": return \"m7\"; // Common notation - might need checking (AM7 vs A_MINOR7)\n        default: return \"\"; // Unknown or simple triad assumed if no suffix\n    }\n}\n/**\n * Calculates the chord name and attempts to find a matching key in the chord library\n * based on a root note index and a Roman numeral string (assuming Major Key context).\n *\n * @param rootNoteIndex - The index (0-11) of the key's root note.\n * @param romanNumeral - The Roman numeral string (e.g., \"I\", \"vi\", \"V7\").\n * @returns An object containing the calculated chord name and the potential chord library key.\n */\nfunction getChordInKey(rootNoteIndex, romanNumeral) {\n    var _a, _b;\n    const mapEntry = MAJOR_KEY_ROMAN_MAP[romanNumeral];\n    if (!mapEntry) {\n        console.warn(`Roman numeral \"${romanNumeral}\" not found in map.`);\n        return { chordName: `${romanNumeral}?`, chordKey: null, quality: \"Unknown\" };\n    }\n    const chordRootIndex = (rootNoteIndex + mapEntry.degree) % 12;\n    const chordRootName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[chordRootIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\"; // Get the primary name (e.g., C# over Db)\n    let fullChordName;\n    // Construct the full chord name based on quality\n    switch (mapEntry.quality) {\n        case \"Major\":\n            fullChordName = `${chordRootName}`; // Often just the letter for major\n            break;\n        case \"Minor\":\n            fullChordName = `${chordRootName}m`;\n            break;\n        case \"Diminished\":\n            fullChordName = `${chordRootName}dim`;\n            break;\n        case \"Augmented\":\n            fullChordName = `${chordRootName}aug`;\n            break;\n        case \"Dominant7th\":\n            fullChordName = `${chordRootName}7`;\n            break;\n        case \"Major7th\":\n            fullChordName = `${chordRootName}maj7`;\n            break;\n        case \"Minor7th\":\n            fullChordName = `${chordRootName}m7`;\n            break;\n        default:\n            fullChordName = `${chordRootName} (${mapEntry.quality})`; // Fallback\n            break;\n    }\n    // --- Attempt to find matching chordKey in chord_library ---\n    // This part is heuristic and depends heavily on naming conventions in chord_library.\n    let potentialKey = null;\n    // 1. Try direct match with constructed name (e.g., \"Am7\")\n    const directKey = Object.keys(chords_1.chord_library).find(key => chords_1.chord_library[key].name === fullChordName);\n    if (directKey) {\n        potentialKey = directKey;\n    }\n    else {\n        // 2. Try constructing key from root + suffix (e.g., A + _MINOR + 7 -> A_MINOR7 ?)\n        // This needs careful mapping based on how keys ARE ACTUALLY defined in chords.ts\n        const suffix = qualityToChordKeySuffix(mapEntry.quality);\n        let constructedKeyBase = chordRootName.replace(\"#\", \"sharp\"); // Replace '#' if keys use 'sharp'\n        // Check common variations (e.g., C_MAJOR, G7, AM7, B_MINOR)\n        const variationsToTest = [\n            `${constructedKeyBase}${suffix}`, // e.g., A_MINOR, C_MAJOR\n            `${constructedKeyBase.toUpperCase()}${suffix}`, // e.g., A_MINOR, C_MAJOR\n            `${constructedKeyBase}${suffix.toUpperCase()}`, // e.g., Am7, Cmaj7 (might match chord name)\n            // Add specific overrides if needed\n            mapEntry.quality === 'Dominant7th' ? `${constructedKeyBase}7` : null, // G7\n            mapEntry.quality === 'Major7th' ? `${constructedKeyBase.toUpperCase()}MAJ7` : null, // AMAJ7\n            mapEntry.quality === 'Minor7th' ? `${constructedKeyBase}m7` : null, // Am7, Bm7\n        ].filter(v => v !== null); // Remove nulls\n        for (const testKey of variationsToTest) {\n            if (testKey && chords_1.chord_library[testKey]) {\n                potentialKey = testKey;\n                break;\n            }\n        }\n        if (!potentialKey) {\n            console.warn(`Could not find key in chord_library for: ${fullChordName} (tried variations like ${variationsToTest.join(', ')})`);\n        }\n    }\n    return {\n        chordName: fullChordName,\n        chordKey: potentialKey,\n        quality: mapEntry.quality,\n    };\n}\n\n\n//# sourceURL=webpack:///./guitar/progressions.ts?");

/***/ }),

/***/ "./guitar/scales.ts":
/*!**************************!*\
  !*** ./guitar/scales.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scales = exports.scale_names = exports.Scale = void 0;\nclass Scale {\n    constructor(name, degrees) {\n        this.name = name;\n        this.degrees = degrees;\n    }\n}\nexports.Scale = Scale;\n// Aliases map to internal keys (e.g., MAJOR, NATURAL_MINOR)\nexports.scale_names = {\n    Blues: \"MINOR_BLUES\",\n    \"Minor Blues\": \"MINOR_BLUES\",\n    \"Major Blues\": \"MAJOR_BLUES\",\n    \"Natural Minor\": \"NATURAL_MINOR\",\n    \"Pure Minor\": \"NATURAL_MINOR\",\n    Minor: \"NATURAL_MINOR\",\n    Major: \"MAJOR\",\n    \"Spanish Minor\": \"PHRYGIAN\",\n    \"Dominant 7th\": \"MIXOLYDIAN\",\n    \"Half-Diminished\": \"LOCRIAN\",\n    \"Lydian Major\": \"LYDIAN\",\n    \"Pentatonic Minor\": \"MINOR_PENTATONIC\",\n    \"Pentatonic Major\": \"MAJOR_PENTATONIC\",\n    \"Country & Western\": \"MAJOR_PENTATONIC\",\n    \"Harmonic Minor\": \"HARMONIC_MINOR\",\n    \"Melodic Minor\": \"MELODIC_MINOR\",\n    \"Jazz Minor\": \"MELODIC_MINOR\",\n    \"Phrygian Dominant\": \"PHRYGIAN_DOMINANT\",\n    \"Spanish Gypsy\": \"PHRYGIAN_DOMINANT\",\n    \"Jewish Scale\": \"PHRYGIAN_DOMINANT\",\n    \"Whole Tone\": \"WHOLE_TONE\",\n    \"Diminished WH\": \"DIMINISHED_WH\",\n    \"Diminished HW\": \"DIMINISHED_HW\",\n    \"Lydian Dominant\": \"LYDIAN_DOMINANT\",\n    \"Lydian b7\": \"LYDIAN_DOMINANT\",\n    \"Altered Scale\": \"ALTERED\",\n    \"Super Locrian\": \"ALTERED\",\n    \"Diminished Whole Tone\": \"ALTERED\",\n    \"Bebop Dominant\": \"BEBOP_DOMINANT\",\n    \"Hungarian Minor\": \"HUNGARIAN_MINOR\",\n    \"Gypsy Minor\": \"HUNGARIAN_MINOR\",\n    // Modes\n    Ionian: \"MAJOR\", // Shorter alias\n    Dorian: \"DORIAN\",\n    Phrygian: \"PHRYGIAN\",\n    Lydian: \"LYDIAN\",\n    Mixolydian: \"MIXOLYDIAN\",\n    Aeolian: \"NATURAL_MINOR\",\n    Locrian: \"LOCRIAN\",\n    // Keep longer mode names as aliases if desired\n    \"Ionian Mode\": \"MAJOR\",\n    \"Dorian Mode\": \"DORIAN\",\n    \"Dorian Minor\": \"DORIAN\",\n    \"Phrygian Mode\": \"PHRYGIAN\",\n    \"Lydian Mode\": \"LYDIAN\",\n    \"Mixolydian Mode\": \"MIXOLYDIAN\",\n    \"Aeolian Mode\": \"NATURAL_MINOR\",\n    \"Locrian Mode\": \"LOCRIAN\",\n};\n/**\n * As a reference, the interval qualities by semitone.\n * 0\tPerfect Unison\tP1\n * 1\tMinor 2nd\tm2\n * 2\tMajor 2nd\tM2\n * 3\tMinor 3rd\tm3\n * 4\tMajor 3rd\tM3\n * 5\tPerfect 4th\tP4\n * 6\tAugmented 4th/Diminished 5th\tA4/d5 (Tritone)\n * 7\tPerfect 5th\tP5\n * 8\tMinor 6th\tm6\n * 9\tMajor 6th\tM6\n * 10\tMinor 7th\tm7\n * 11\tMajor 7th\tM7\n * 12\tOctave\tP8\n */\n// Internal scale definitions using clearer names\nexports.scales = {\n    MAJOR: new Scale(\"Major\", [0, 2, 4, 5, 7, 9, 11]), // Ionian\n    NATURAL_MINOR: new Scale(\"Minor\", [0, 2, 3, 5, 7, 8, 10]), // Aeolian\n    DORIAN: new Scale(\"Dorian\", [0, 2, 3, 5, 7, 9, 10]),\n    PHRYGIAN: new Scale(\"Phrygian\", [0, 1, 3, 5, 7, 8, 10]),\n    LYDIAN: new Scale(\"Lydian\", [0, 2, 4, 6, 7, 9, 11]),\n    MIXOLYDIAN: new Scale(\"Mixolydian\", [0, 2, 4, 5, 7, 9, 10]),\n    LOCRIAN: new Scale(\"Locrian\", [0, 1, 3, 5, 6, 8, 10]),\n    MAJOR_PENTATONIC: new Scale(\"Major Pentatonic\", [0, 2, 4, 7, 9]),\n    MINOR_PENTATONIC: new Scale(\"Minor Pentatonic\", [0, 3, 5, 7, 10]),\n    MINOR_BLUES: new Scale(\"Minor Blues\", [0, 3, 5, 6, 7, 10]),\n    MAJOR_BLUES: new Scale(\"Major Blues\", [0, 2, 3, 4, 7, 9]),\n    HARMONIC_MINOR: new Scale(\"Harmonic Minor\", [0, 2, 3, 5, 7, 8, 11]),\n    MELODIC_MINOR: new Scale(\"Melodic Minor\", [0, 2, 3, 5, 7, 9, 11]),\n    PHRYGIAN_DOMINANT: new Scale(\"Phrygian Dominant\", [0, 1, 4, 5, 7, 8, 10]),\n    WHOLE_TONE: new Scale(\"Whole Tone\", [0, 2, 4, 6, 8, 10]),\n    DIMINISHED_WH: new Scale(\"Diminished (W-H)\", [0, 2, 3, 5, 6, 8, 9, 11]),\n    DIMINISHED_HW: new Scale(\"Diminished (H-W)\", [0, 1, 3, 4, 6, 7, 9, 10]),\n    LYDIAN_DOMINANT: new Scale(\"Lydian Dominant\", [0, 2, 4, 6, 7, 9, 10]),\n    ALTERED: new Scale(\"Altered\", [0, 1, 3, 4, 6, 8, 10]),\n    BEBOP_DOMINANT: new Scale(\"Bebop Dominant\", [0, 2, 4, 5, 7, 9, 10, 11]),\n    HUNGARIAN_MINOR: new Scale(\"Hungarian Minor\", [0, 2, 3, 6, 7, 8, 11]),\n};\n\n\n//# sourceURL=webpack:///./guitar/scales.ts?");

/***/ }),

/***/ "./guitar/triads.ts":
/*!**************************!*\
  !*** ./guitar/triads.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TRIAD_INTERVALS = void 0;\nexports.getTriadNotesAndLinesForGroup = getTriadNotesAndLinesForGroup;\nconst fretboard_1 = __webpack_require__(/*! ./fretboard */ \"./guitar/fretboard.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ./guitar_utils */ \"./guitar/guitar_utils.ts\");\n/** Map of triad qualities to their intervals (in semitones relative to root). */\nexports.TRIAD_INTERVALS = {\n    Major: [0, 4, 7], // R, M3, P5\n    Minor: [0, 3, 7], // R, m3, P5\n    Diminished: [0, 3, 6], // R, m3, m5\n    Augmented: [0, 3, 8], // R, m3, m6\n};\n// --- Revised Catalog of Relative Triad Shapes ---\nconst TRIAD_SHAPE_CATALOG = [\n    // === MAJOR === (R=0, M3=4, P5=7)\n    // --- EAD [0,1,2] ---\n    { quality: \"Major\", inversion: \"Root\", stringGroup: [0, 1, 2], relativeFrets: [3, 2, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Major\", inversion: \"2nd\", stringGroup: [0, 1, 2], relativeFrets: [0, 0, -1], rootStringIndexInGroup: 1 },\n    { quality: \"Major\", inversion: \"1st\", stringGroup: [0, 1, 2], relativeFrets: [2, 0, 0], rootStringIndexInGroup: 2 },\n    // --- ADG [1,2,3] ---\n    { quality: \"Major\", inversion: \"Root\", stringGroup: [1, 2, 3], relativeFrets: [3, 2, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Major\", inversion: \"2nd\", stringGroup: [1, 2, 3], relativeFrets: [0, 0, -1], rootStringIndexInGroup: 1 },\n    { quality: \"Major\", inversion: \"1st\", stringGroup: [1, 2, 3], relativeFrets: [2, 0, 0], rootStringIndexInGroup: 2 },\n    // --- DGB [2,3,4] ---\n    { quality: \"Major\", inversion: \"Root\", stringGroup: [2, 3, 4], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Major\", inversion: \"2nd\", stringGroup: [2, 3, 4], relativeFrets: [0, 0, 0], rootStringIndexInGroup: 1 },\n    { quality: \"Major\", inversion: \"1st\", stringGroup: [2, 3, 4], relativeFrets: [1, -1, 0], rootStringIndexInGroup: 2 },\n    // --- GBE [3,4,5] ---\n    { quality: \"Major\", inversion: \"Root\", stringGroup: [3, 4, 5], relativeFrets: [2, 2, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Major\", inversion: \"2nd\", stringGroup: [3, 4, 5], relativeFrets: [-1, 0, -1], rootStringIndexInGroup: 1 },\n    { quality: \"Major\", inversion: \"1st\", stringGroup: [3, 4, 5], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 2 },\n    // === MINOR === (R=0, m3=3, P5=7)\n    // EAD [0,1,2]\n    { quality: \"Minor\", inversion: \"Root\", stringGroup: [0, 1, 2], relativeFrets: [3, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Minor\", inversion: \"2nd\", stringGroup: [0, 1, 2], relativeFrets: [0, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Minor\", inversion: \"1st\", stringGroup: [0, 1, 2], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 2 },\n    // ADG [1,2,3]\n    { quality: \"Minor\", inversion: \"Root\", stringGroup: [1, 2, 3], relativeFrets: [3, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Minor\", inversion: \"2nd\", stringGroup: [1, 2, 3], relativeFrets: [0, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Minor\", inversion: \"1st\", stringGroup: [1, 2, 3], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 2 },\n    // DGB [2,3,4] (B string adjusted)\n    { quality: \"Minor\", inversion: \"Root\", stringGroup: [2, 3, 4], relativeFrets: [2, 0, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Minor\", inversion: \"2nd\", stringGroup: [2, 3, 4], relativeFrets: [0, 0, -1], rootStringIndexInGroup: 1 },\n    { quality: \"Minor\", inversion: \"1st\", stringGroup: [2, 3, 4], relativeFrets: [0, -1, 0], rootStringIndexInGroup: 2 },\n    // GBE [3,4,5] (B string adjusted)\n    { quality: \"Minor\", inversion: \"Root\", stringGroup: [3, 4, 5], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Minor\", inversion: \"2nd\", stringGroup: [3, 4, 5], relativeFrets: [-1, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Minor\", inversion: \"1st\", stringGroup: [3, 4, 5], relativeFrets: [0, 0, 0], rootStringIndexInGroup: 2 },\n    // === DIMINISHED === (R=0, m3=3, m5=6)\n    // EAD [0,1,2]\n    { quality: \"Diminished\", inversion: \"Root\", stringGroup: [0, 1, 2], relativeFrets: [4, 2, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Diminished\", inversion: \"2nd\", stringGroup: [0, 1, 2], relativeFrets: [-1, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Diminished\", inversion: \"1st\", stringGroup: [0, 1, 2], relativeFrets: [1, -1, 0], rootStringIndexInGroup: 2 },\n    // ADG [1,2,3]\n    { quality: \"Diminished\", inversion: \"Root\", stringGroup: [1, 2, 3], relativeFrets: [4, 2, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Diminished\", inversion: \"2nd\", stringGroup: [1, 2, 3], relativeFrets: [-1, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Diminished\", inversion: \"1st\", stringGroup: [1, 2, 3], relativeFrets: [1, -1, 0], rootStringIndexInGroup: 2 },\n    // DGB [2,3,4] (B string adjusted)\n    { quality: \"Diminished\", inversion: \"Root\", stringGroup: [2, 3, 4], relativeFrets: [2, 0, -1], rootStringIndexInGroup: 0 },\n    { quality: \"Diminished\", inversion: \"2nd\", stringGroup: [2, 3, 4], relativeFrets: [-1, 0, -1], rootStringIndexInGroup: 1 },\n    { quality: \"Diminished\", inversion: \"1st\", stringGroup: [2, 3, 4], relativeFrets: [0, -2, 0], rootStringIndexInGroup: 2 },\n    // GBE [3,4,5] (B string adjusted)\n    { quality: \"Diminished\", inversion: \"Root\", stringGroup: [3, 4, 5], relativeFrets: [2, 1, -1], rootStringIndexInGroup: 0 },\n    { quality: \"Diminished\", inversion: \"2nd\", stringGroup: [3, 4, 5], relativeFrets: [-2, 0, -2], rootStringIndexInGroup: 1 },\n    { quality: \"Diminished\", inversion: \"1st\", stringGroup: [3, 4, 5], relativeFrets: [0, -1, 0], rootStringIndexInGroup: 2 },\n    // === Augmented === (R=0, m3=3, m6=8)\n    // EAD [0,1,2]\n    { quality: \"Augmented\", inversion: \"Root\", stringGroup: [0, 1, 2], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Augmented\", inversion: \"2nd\", stringGroup: [0, 1, 2], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 1 },\n    { quality: \"Augmented\", inversion: \"1st\", stringGroup: [0, 1, 2], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 2 },\n    // ADG [1,2,3]\n    { quality: \"Augmented\", inversion: \"Root\", stringGroup: [1, 2, 3], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Augmented\", inversion: \"2nd\", stringGroup: [1, 2, 3], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 1 },\n    { quality: \"Augmented\", inversion: \"1st\", stringGroup: [1, 2, 3], relativeFrets: [2, 1, 0], rootStringIndexInGroup: 2 },\n    // DGB [2,3,4] (B string adjusted)\n    { quality: \"Augmented\", inversion: \"Root\", stringGroup: [2, 3, 4], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 0 },\n    { quality: \"Augmented\", inversion: \"2nd\", stringGroup: [2, 3, 4], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 1 },\n    { quality: \"Augmented\", inversion: \"1st\", stringGroup: [2, 3, 4], relativeFrets: [1, 0, 0], rootStringIndexInGroup: 2 },\n    // GBE [3,4,5] (B string adjusted)\n    { quality: \"Augmented\", inversion: \"Root\", stringGroup: [3, 4, 5], relativeFrets: [2, 2, 1], rootStringIndexInGroup: 0 },\n    { quality: \"Augmented\", inversion: \"2nd\", stringGroup: [3, 4, 5], relativeFrets: [2, 2, 1], rootStringIndexInGroup: 1 },\n    { quality: \"Augmented\", inversion: \"1st\", stringGroup: [3, 4, 5], relativeFrets: [2, 2, 1], rootStringIndexInGroup: 2 },\n];\nconst INVERSION_LINE_COLORS = {\n    \"Root\": \"#3273dc\", \"1st\": \"#48c774\", \"2nd\": \"#ff3860\",\n};\n/**\n * Finds all occurrences of triads for a given key and quality on a specific 3-string group.\n * Uses the TRIAD_SHAPE_CATALOG for relative shapes.\n * Returns data optimized for FretboardView rendering.\n *\n * @returns An object containing arrays of notes (NoteRenderData without x/y) and lines (LineData with calculated coords).\n */\nfunction getTriadNotesAndLinesForGroup(rootNoteName, quality, stringGroup, fretCount, fretboardConfig // Pass the config for coordinate calculations\n) {\n    var _a, _b;\n    const rootNoteIndex = (0, guitar_utils_1.getKeyIndex)(rootNoteName);\n    if (rootNoteIndex === -1)\n        return { notes: [], lines: [] };\n    const triadIntervals = exports.TRIAD_INTERVALS[quality];\n    if (!triadIntervals)\n        return { notes: [], lines: [] };\n    const allNotesForGroup = [];\n    const allLinesForGroup = [];\n    const tuning = fretboardConfig.tuning.tuning;\n    const scaledStartPx = guitar_utils_1.START_PX * fretboardConfig.scaleFactor;\n    // Instantiate a temporary Fretboard object ONLY for coordinate calculations\n    const coordCalculator = new fretboard_1.Fretboard(fretboardConfig, scaledStartPx, scaledStartPx, fretCount);\n    const relevantShapes = TRIAD_SHAPE_CATALOG.filter(s => s.quality === quality &&\n        s.stringGroup.every((val, index) => val === stringGroup[index]));\n    // No longer needed: const targetIntervalMap = new Map<number, number>();\n    // triadIntervals.forEach(interval => targetIntervalMap.set(((12+rootNoteIndex) + interval) % 12, interval));\n    const addedInstances = new Set(); // To prevent adding exact same shape at same location\n    for (const shape of relevantShapes) {\n        const anchorStringAbsoluteIndex = shape.stringGroup[shape.rootStringIndexInGroup];\n        const anchorStringTuning = tuning[anchorStringAbsoluteIndex];\n        const requiredNoteIndexForAnchor = (12 + rootNoteIndex) % 12; // Root note index (0-11)\n        for (let anchorFret = 0; anchorFret <= fretCount; anchorFret++) {\n            const noteAtAnchorFret = (anchorStringTuning + anchorFret) % 12;\n            if (noteAtAnchorFret === requiredNoteIndexForAnchor) {\n                // Found a potential root note at anchorFret on the anchor string\n                const instanceNotesData = [];\n                const instanceCoords = []; // Store coords temporarily for lines\n                let isValidInstance = true;\n                // const absoluteFrets: number[] = [-1, -1, -1]; // Not needed to store\n                for (let i = 0; i < 3; i++) { // Iterate through the 3 strings in the shape's group\n                    const currentStringAbsoluteIndex = shape.stringGroup[i];\n                    const currentStringTuning = tuning[currentStringAbsoluteIndex];\n                    // Calculate the absolute fret for the current string based on the anchor fret and the relative shape\n                    const absFret = anchorFret + shape.relativeFrets[i] - shape.relativeFrets[shape.rootStringIndexInGroup];\n                    // absoluteFrets[i] = absFret; // Not needed\n                    if (absFret < 0 || absFret > fretCount) {\n                        isValidInstance = false; // Note is outside the fretboard range\n                        break;\n                    }\n                    const resultingNoteIndex = (currentStringTuning + absFret) % 12; // Calculate the note index (0-11)\n                    // Check if this note belongs to the target triad (redundant if shape catalog is correct, but good validation)\n                    // const intervalOffset = (resultingNoteIndex - rootNoteIndex + 12) % 12;\n                    // if (!triadIntervals.includes(intervalOffset)) {\n                    //     isValidInstance = false; // Note doesn't belong to the triad\n                    //     console.warn(`Shape validation failed: Shape ${shape.inversion}/${shape.quality} on ${shape.stringGroup} produced note ${MUSIC_NOTES[resultingNoteIndex][0]} (offset ${intervalOffset}) at string ${currentStringAbsoluteIndex}, fret ${absFret}, which is not in triad intervals [${triadIntervals.join(',')}] for root ${rootNoteName}`);\n                    //     break;\n                    // }\n                    const noteName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[resultingNoteIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n                    // Corrected interval calculation:\n                    const intervalSemitones = (resultingNoteIndex - rootNoteIndex + 12) % 12;\n                    const intervalLabel = (0, guitar_utils_1.getIntervalLabel)(intervalSemitones);\n                    // Get coordinates for this note *before* adding NoteRenderData\n                    const coords = coordCalculator.getNoteCoordinates(currentStringAbsoluteIndex, absFret);\n                    instanceCoords.push(coords); // Store for line drawing\n                    // Push NoteRenderData *without* x/y\n                    instanceNotesData.push({\n                        fret: absFret, stringIndex: currentStringAbsoluteIndex,\n                        noteName: noteName, intervalLabel: intervalLabel,\n                        displayLabel: intervalLabel, // Display interval label for triads\n                        colorSchemeOverride: \"interval\", // Use interval colors\n                    });\n                }\n                if (isValidInstance && instanceNotesData.length === 3) {\n                    // Create a unique key for this instance based on frets and strings\n                    const instanceKey = instanceNotesData.map(n => `${n.stringIndex}:${n.fret}`).sort().join(',');\n                    if (!addedInstances.has(instanceKey)) {\n                        allNotesForGroup.push(...instanceNotesData);\n                        addedInstances.add(instanceKey); // Mark as added\n                        // Add connecting lines using the calculated coords\n                        const lineColor = INVERSION_LINE_COLORS[shape.inversion] || 'grey';\n                        // Sort COORDS based on corresponding note string index for consistent line drawing\n                        const sortedCoords = instanceCoords.sort((a, b) => {\n                            // Find the corresponding notes to get their string indices for sorting\n                            const noteA = instanceNotesData.find(n => n.fret === instanceNotesData[instanceCoords.indexOf(a)].fret && n.stringIndex === instanceNotesData[instanceCoords.indexOf(a)].stringIndex);\n                            const noteB = instanceNotesData.find(n => n.fret === instanceNotesData[instanceCoords.indexOf(b)].fret && n.stringIndex === instanceNotesData[instanceCoords.indexOf(b)].stringIndex);\n                            // Basic sort if notes aren't found (shouldn't happen)\n                            if (!noteA || !noteB)\n                                return 0;\n                            return noteA.stringIndex - noteB.stringIndex;\n                        });\n                        for (let i = 0; i < 2; i++) {\n                            // Use sortedCoords for line data\n                            allLinesForGroup.push({\n                                startX: sortedCoords[i].x, startY: sortedCoords[i].y,\n                                endX: sortedCoords[i + 1].x, endY: sortedCoords[i + 1].y,\n                                color: lineColor, dashed: true, strokeWidth: 1.5 // Use unscaled width\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return { notes: allNotesForGroup, lines: allLinesForGroup };\n}\n\n\n//# sourceURL=webpack:///./guitar/triads.ts?");

/***/ }),

/***/ "./guitar/views/chord_diagram_view.ts":
/*!********************************************!*\
  !*** ./guitar/views/chord_diagram_view.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChordDiagramView = void 0;\n// Import Fretboard class and necessary types/enum from fretboard.ts\nconst fretboard_1 = __webpack_require__(/*! ../fretboard */ \"./guitar/fretboard.ts\");\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\n/**\n * Helper to get the notes in a chord.\n * @param chord - The Chord object.\n * @param config - FretboardConfig for tuning info.\n * @returns Sorted array of note names in the chord.\n */\nfunction getChordNotes(chord, config) {\n    var _a, _b;\n    const notes = new Set();\n    const tuning = config.tuning.tuning;\n    for (let i = 0; i < chord.strings.length; i++) {\n        const fret = chord.strings[i];\n        if (fret >= 0 && i < tuning.length) {\n            // Check fret >= 0 and valid string index\n            const noteIndex = (tuning[i] + fret) % 12;\n            notes.add((_b = (_a = guitar_utils_1.MUSIC_NOTES[noteIndex]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\");\n        }\n    }\n    // Define a canonical note order for sorting\n    const canonicalOrder = guitar_utils_1.MUSIC_NOTES.map((n) => n[0]);\n    return Array.from(notes).sort((a, b) => canonicalOrder.indexOf(a) - canonicalOrder.indexOf(b));\n}\n/**\n * A View responsible for rendering a single chord diagram by configuring\n * and delegating to an internal Fretboard instance.\n */\nclass ChordDiagramView {\n    constructor(chord, title, fretboardConfig) {\n        this.wrapperDiv = null;\n        this.canvas = null;\n        this.ctx = null;\n        // Store calculated dimensions\n        this.requiredWidth = 0;\n        this.requiredHeight = 0;\n        this.fretCount = 5; // Standard for chord diagrams\n        this.chord = chord;\n        this.title = title;\n        this.fretboardConfig = fretboardConfig;\n        // Calculate dimensions needed for canvas\n        this.calculateDimensions();\n        // Instantiate the Fretboard logic class\n        // The Fretboard class uses START_PX internally for drawing padding\n        const scaledStartPx = guitar_utils_1.START_PX * this.fretboardConfig.scaleFactor;\n        this.fretboard = new fretboard_1.Fretboard(this.fretboardConfig, scaledStartPx, // Pass scaled start X for drawing origin within canvas\n        scaledStartPx, // Pass scaled start Y for drawing origin within canvas\n        this.fretCount);\n        // Prepare note data immediately and pass it to the Fretboard instance\n        this.prepareAndSetChordData();\n    }\n    /** Calculates the required canvas dimensions. */\n    calculateDimensions() {\n        const config = this.fretboardConfig;\n        const scaleFactor = config.scaleFactor;\n        const scaledNoteRadius = config.noteRadiusPx;\n        const scaledStartPx = guitar_utils_1.START_PX * scaleFactor;\n        // Clearance needed above the nut line for potential open notes/muted markers\n        const openNoteClearance = scaledNoteRadius * 1.5 + 5 * scaleFactor;\n        // Height of the fretted area\n        const fretboardLinesHeight = this.fretCount * config.fretLengthPx;\n        // Clearance needed below the last fret line\n        const bottomClearance = scaledNoteRadius + 5 * scaleFactor;\n        this.requiredWidth =\n            scaledStartPx + config.stringSpacingPx * 5 + scaledStartPx; // LeftPad + Strings + RightPad\n        // Height includes space *within the canvas* for grid, clearances, and padding\n        this.requiredHeight =\n            scaledStartPx +\n                openNoteClearance +\n                fretboardLinesHeight +\n                bottomClearance +\n                scaledStartPx;\n    }\n    /** Calculates NoteRenderData for the chord and passes it to the Fretboard instance. */\n    prepareAndSetChordData() {\n        var _a, _b;\n        const notesData = [];\n        const config = this.fretboardConfig;\n        // Determine starting fret for the diagram display range\n        let minFret = this.fretCount + 1;\n        let maxFret = 0;\n        this.chord.strings.forEach((fret) => {\n            if (fret > 0) {\n                minFret = Math.min(minFret, fret);\n                maxFret = Math.max(maxFret, fret);\n            }\n        });\n        let startFret = 0; // Fret number the diagram starts AT (0 means show nut)\n        // If the lowest fretted note is too high OR the total range exceeds the display count\n        if (minFret > this.fretCount || maxFret - minFret >= this.fretCount) {\n            startFret = minFret - 1; // Start diagram just below lowest fretted note\n        }\n        // Pass startFret to Fretboard instance\n        this.fretboard.setStartFret(startFret); // Call the new method\n        const chordRootName = this.getChordRootNote();\n        const chordRootIndex = chordRootName ? (0, guitar_utils_1.getKeyIndex)(chordRootName) : -1;\n        for (let stringIndex = 0; stringIndex < this.chord.strings.length; stringIndex++) {\n            if (stringIndex >= config.tuning.tuning.length)\n                continue;\n            const fret = this.chord.strings[stringIndex]; // Actual fret (-1, 0, or >0)\n            const finger = this.chord.fingers[stringIndex];\n            const displayFretForNote = fret - startFret; // Fret relative to diagram start\n            // Include note if it's muted, open, or within the displayed fret range\n            if (fret === -1 ||\n                (displayFretForNote >= 0 && displayFretForNote <= this.fretCount)) {\n                const isMuted = fret === -1;\n                const isOpen = fret === 0;\n                let noteName = \"?\";\n                let intervalLabel = \"?\";\n                let displayLabel = finger > 0 ? `${finger}` : \"\"; // Prioritize finger number\n                if (!isMuted) {\n                    const noteOffsetFromA = (config.tuning.tuning[stringIndex] + fret) % 12;\n                    noteName = (_b = (_a = guitar_utils_1.MUSIC_NOTES[noteOffsetFromA]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"?\";\n                    if (chordRootIndex !== -1) {\n                        const noteRelativeToKey = (noteOffsetFromA - chordRootIndex + 12) % 12;\n                        intervalLabel = (0, guitar_utils_1.getIntervalLabel)(noteRelativeToKey);\n                    }\n                    // Fallback display label if no finger number\n                    if (displayLabel === \"\") {\n                        // Use interval label for root, note name otherwise\n                        if (intervalLabel === \"R\")\n                            displayLabel = \"R\";\n                        else\n                            displayLabel = noteName;\n                    }\n                }\n                notesData.push({\n                    fret: fret, // Pass the ACTUAL fret to Fretboard drawing logic\n                    stringIndex: stringIndex,\n                    noteName: noteName,\n                    intervalLabel: intervalLabel,\n                    displayLabel: displayLabel,\n                    colorSchemeOverride: config.colorScheme, // Use diagram's configured scheme\n                    radiusOverride: isOpen\n                        ? config.noteRadiusPx * guitar_utils_1.OPEN_NOTE_RADIUS_FACTOR\n                        : undefined,\n                });\n            }\n        }\n        // Set notes (and clear lines for single chord diagram)\n        this.fretboard.setNotes(notesData);\n        this.fretboard.setLines([]); // Explicitly clear lines\n    }\n    /** Creates the wrapper div, title, canvas and triggers the render via the Fretboard instance. */\n    render(container) {\n        if (!this.wrapperDiv) {\n            this.createElements(container);\n        }\n        else {\n            if (!this.wrapperDiv.parentNode) {\n                container.appendChild(this.wrapperDiv); // Re-attach if detached\n            }\n        }\n        if (this.ctx) {\n            // Delegate all drawing to the Fretboard instance\n            this.fretboard.render(this.ctx);\n        }\n        else {\n            console.error(\"Canvas context not available for ChordDiagramView render:\", this.title);\n        }\n    }\n    /** Creates the wrapper, title, and canvas elements. */\n    createElements(container) {\n        // --- Create Wrapper Div ---\n        this.wrapperDiv = document.createElement(\"div\");\n        this.wrapperDiv.classList.add(\"chord-diagram-view\");\n        this.wrapperDiv.style.display = \"inline-block\";\n        this.wrapperDiv.style.verticalAlign = \"top\";\n        this.wrapperDiv.style.padding = \"5px\";\n        this.wrapperDiv.style.minWidth = `${this.requiredWidth}px`; // Use calculated width\n        // --- Add Title (External to Canvas) ---\n        const titleEl = (0, guitar_utils_1.addHeader)(this.wrapperDiv, this.title);\n        titleEl.classList.replace(\"is-6\", \"is-6\"); // Adjusted size (e.g., is-6 instead of is-7)\n        titleEl.style.marginBottom = `4px`; // Adjust spacing if needed\n        // --- Add Notes List ---\n        const notesList = getChordNotes(this.chord, this.fretboardConfig); // Call helper\n        const notesEl = document.createElement(\"div\");\n        notesEl.classList.add(\"chord-notes-list\"); // Add class for styling\n        notesEl.textContent = notesList.join(\", \");\n        notesEl.style.fontSize = \"0.75rem\"; // Smaller font size for notes\n        notesEl.style.textAlign = \"center\";\n        notesEl.style.color = \"var(--clr-text-subtle)\"; // Use a subtle color\n        notesEl.style.marginBottom = \"8px\"; // Space below notes, before canvas\n        this.wrapperDiv.appendChild(notesEl); // Append notes below title\n        // --- Create Canvas ---\n        const canvasIdSuffix = `chord-${this.title.replace(/[^a-zA-Z0-9-]/g, \"_\")}`;\n        this.canvas = (0, guitar_utils_1.addCanvas)(this.wrapperDiv, canvasIdSuffix); // Add canvas to wrapper\n        this.canvas.width = Math.max(150, this.requiredWidth);\n        this.canvas.height = Math.max(200, this.requiredHeight);\n        this.ctx = this.canvas.getContext(\"2d\");\n        if (!this.ctx) {\n            console.error(\"Failed to get 2D context for chord diagram:\", this.title);\n            this.canvas = null;\n            return;\n        }\n        // Append the wrapper to the main container\n        container.appendChild(this.wrapperDiv);\n    }\n    /** Helper to get chord root note - needed for interval calculation */\n    getChordRootNote() {\n        if (!this.chord || !this.chord.name)\n            return null;\n        const chordName = this.chord.name;\n        // Match common root note patterns (A, A#, Ab, G# etc.)\n        const match = chordName.match(/^([A-G])([#b]?)/);\n        if (match) {\n            const rootName = `${match[1]}${match[2] || \"\"}`;\n            // Validate against known notes\n            if (guitar_utils_1.MUSIC_NOTES.flat().includes(rootName))\n                return rootName;\n        }\n        // Fallback might be needed if chord_library keys differ significantly from names\n        console.warn(`Could not determine root note for chord name: ${chordName}`);\n        return null;\n    }\n    // --- View Lifecycle Methods ---\n    start() { } // No active processes\n    stop() { } // No active processes\n    destroy() {\n        var _a;\n        if (this.wrapperDiv && this.wrapperDiv.parentNode) {\n            this.wrapperDiv.parentNode.removeChild(this.wrapperDiv);\n        }\n        this.wrapperDiv = null;\n        this.canvas = null;\n        this.ctx = null;\n        (_a = this.fretboard) === null || _a === void 0 ? void 0 : _a.clearMarkings(); // Clear data in underlying fretboard\n    }\n}\nexports.ChordDiagramView = ChordDiagramView;\n\n\n//# sourceURL=webpack:///./guitar/views/chord_diagram_view.ts?");

/***/ }),

/***/ "./guitar/views/color_legend_view.ts":
/*!*******************************************!*\
  !*** ./guitar/views/color_legend_view.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorLegendView = void 0;\nconst settings_1 = __webpack_require__(/*! ../../settings */ \"./settings.ts\");\nconst guitar_settings_1 = __webpack_require__(/*! ../guitar_settings */ \"./guitar/guitar_settings.ts\");\nconst colors_1 = __webpack_require__(/*! ../colors */ \"./guitar/colors.ts\"); // Import color maps\nclass ColorLegendView {\n    constructor(appSettings) {\n        this.container = null;\n        // Need AppSettings to get the current guitar color scheme\n        if (!appSettings) {\n            throw new Error(\"ColorLegendView requires AppSettings instance.\");\n        }\n        this.appSettings = appSettings;\n    }\n    render(container) {\n        var _a;\n        this.container = container;\n        this.container.innerHTML = \"\"; // Clear previous content\n        this.container.classList.add(\"color-legend-view\"); // For styling\n        const guitarSettings = (_a = (0, settings_1.getCategorySettings)(this.appSettings, guitar_settings_1.GUITAR_SETTINGS_KEY)) !== null && _a !== void 0 ? _a : guitar_settings_1.DEFAULT_GUITAR_SETTINGS;\n        const currentScheme = guitarSettings.colorScheme;\n        let colorMap = {};\n        let title = \"Color Legend\";\n        if (currentScheme === \"interval\") {\n            colorMap = colors_1.INTERVAL_COLORS;\n            title = \"Interval Color Legend\";\n        }\n        else if (currentScheme === \"note\") {\n            colorMap = colors_1.NOTE_COLORS;\n            title = \"Note Color Legend\";\n            // Filter out aliases for display? (Optional)\n            const primaryNoteMap = {};\n            Object.entries(colors_1.NOTE_COLORS).forEach(([key, value]) => {\n                if (!key.includes(\"b\") || key.length === 2) {\n                    // Basic filter for primary names (A, A#, B, C...)\n                    if (key !== \"DEFAULT\")\n                        primaryNoteMap[key] = value;\n                }\n            });\n            colorMap = primaryNoteMap;\n        }\n        else {\n            // Simplified or others\n            colorMap = { R: colors_1.INTERVAL_COLORS[\"R\"], Other: colors_1.INTERVAL_COLORS[\"DEFAULT\"] };\n            title = \"Simplified Color Legend\";\n        }\n        // Add a title inside the view content\n        const titleEl = document.createElement(\"div\");\n        titleEl.classList.add(\"legend-title\");\n        titleEl.textContent = title;\n        this.container.appendChild(titleEl);\n        // Create legend items\n        for (const key in colorMap) {\n            if (key === \"DEFAULT\")\n                continue; // Skip default entry\n            const item = document.createElement(\"div\");\n            item.classList.add(\"legend-item\");\n            const swatch = document.createElement(\"span\");\n            swatch.classList.add(\"color-swatch\");\n            swatch.style.backgroundColor = colorMap[key];\n            const label = document.createElement(\"span\");\n            label.classList.add(\"legend-label\");\n            label.textContent = key;\n            item.appendChild(swatch);\n            item.appendChild(label);\n            this.container.appendChild(item);\n        }\n    }\n    // --- View Lifecycle Methods (Simple for this static view) ---\n    start() { }\n    stop() { }\n    destroy() {\n        // Cleanup if needed (remove listeners, etc.)\n        if (this.container) {\n            this.container.innerHTML = \"\";\n        }\n        this.container = null;\n    }\n}\nexports.ColorLegendView = ColorLegendView;\n\n\n//# sourceURL=webpack:///./guitar/views/color_legend_view.ts?");

/***/ }),

/***/ "./guitar/views/floating_metronome_view.ts":
/*!*************************************************!*\
  !*** ./guitar/views/floating_metronome_view.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FloatingMetronomeView = void 0;\nconst audio_controller_1 = __webpack_require__(/*! ../../audio_controller */ \"./audio_controller.ts\");\nconst metronome_view_1 = __webpack_require__(/*! ./metronome_view */ \"./guitar/views/metronome_view.ts\"); // Import the original view\n/**\n * A floating view that wraps the main MetronomeView, making it\n * available as a draggable, independent component.\n */\nclass FloatingMetronomeView {\n    constructor(appSettings) {\n        // The floating metronome needs its own AudioController instance.\n        this.audioController = new audio_controller_1.AudioController(document.querySelector(\"#intro-end-sound\"), document.querySelector(\"#interval-end-sound\"), document.querySelector(\"#metronome-sound\"), document.querySelector(\"#metronome-accent-sound\"));\n        // Create an instance of the original MetronomeView with a default BPM.\n        // The BPM will be controlled by the UI within the MetronomeView itself.\n        this.metronomeView = new metronome_view_1.MetronomeView(120, this.audioController);\n    }\n    /**\n     * Delegates rendering to the wrapped MetronomeView instance.\n     */\n    render(container) {\n        this.metronomeView.render(container);\n    }\n    /**\n     * Delegates the start action to the wrapped MetronomeView.\n     */\n    start() {\n        this.metronomeView.start();\n    }\n    /**\n     * Delegates the stop action to the wrapped MetronomeView.\n     */\n    stop() {\n        this.metronomeView.stop();\n    }\n    /**\n     * Delegates the destroy action to the wrapped MetronomeView.\n     */\n    destroy() {\n        this.metronomeView.destroy();\n    }\n}\nexports.FloatingMetronomeView = FloatingMetronomeView;\n\n\n//# sourceURL=webpack:///./guitar/views/floating_metronome_view.ts?");

/***/ }),

/***/ "./guitar/views/fretboard_reference_view.ts":
/*!**************************************************!*\
  !*** ./guitar/views/fretboard_reference_view.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FretboardReferenceView = void 0;\nconst notes_feature_1 = __webpack_require__(/*! ../features/notes_feature */ \"./guitar/features/notes_feature.ts\");\nconst audio_controller_1 = __webpack_require__(/*! ../../audio_controller */ \"./audio_controller.ts\");\nconst guitar_interval_settings_1 = __webpack_require__(/*! ../guitar_interval_settings */ \"./guitar/guitar_interval_settings.ts\");\n/**\n * A floating view that acts as a persistent fretboard reference\n * by displaying the NotesFeature.\n */\nclass FretboardReferenceView {\n    constructor(appSettings) {\n        this.notesFeature = null;\n        this.viewContainer = null;\n        if (!appSettings) {\n            throw new Error(\"FretboardReferenceView requires AppSettings.\");\n        }\n        this.appSettings = appSettings;\n        // Create a dummy audio controller as it's required by the feature constructor\n        this.audioController = new audio_controller_1.AudioController(null, null, null, null);\n    }\n    render(container) {\n        this.viewContainer = container;\n        this.viewContainer.innerHTML = \"\"; // Clear previous content\n        // Create a default instance of GuitarIntervalSettings (no metronome)\n        const intervalSettings = new guitar_interval_settings_1.GuitarIntervalSettings();\n        // Create an instance of the NotesFeature\n        // Config: ['None'] to show all notes without interval coloring\n        // We pass a smaller maxCanvasHeight to make it more suitable for a floating window\n        this.notesFeature = new notes_feature_1.NotesFeature(['None'], // Config to show standard note names\n        this.appSettings, null, // rootNoteName (null for standard note colors)\n        intervalSettings, this.audioController, 450 // Max height for a more compact floating view\n        );\n        // The feature's render method adds its own header\n        this.notesFeature.render(this.viewContainer);\n        // The feature's views (like FretboardView) are rendered into a container\n        // that the DisplayController would normally manage. We'll do it manually here.\n        const diagramContainer = document.createElement('div');\n        this.viewContainer.appendChild(diagramContainer);\n        this.notesFeature.views.forEach(view => {\n            view.render(diagramContainer);\n        });\n    }\n    start() {\n        var _a, _b;\n        (_b = (_a = this.notesFeature) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    stop() {\n        var _a, _b;\n        (_b = (_a = this.notesFeature) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    destroy() {\n        var _a, _b;\n        (_b = (_a = this.notesFeature) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.viewContainer) {\n            this.viewContainer.innerHTML = \"\";\n        }\n        this.viewContainer = null;\n    }\n}\nexports.FretboardReferenceView = FretboardReferenceView;\n\n\n//# sourceURL=webpack:///./guitar/views/fretboard_reference_view.ts?");

/***/ }),

/***/ "./guitar/views/fretboard_view.ts":
/*!****************************************!*\
  !*** ./guitar/views/fretboard_view.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FretboardView = void 0;\nconst fretboard_1 = __webpack_require__(/*! ../fretboard */ \"./guitar/fretboard.ts\"); // Import types from fretboard.ts\nconst guitar_utils_1 = __webpack_require__(/*! ../guitar_utils */ \"./guitar/guitar_utils.ts\");\n/**\n * A View that wraps a Fretboard instance, sets up its canvas,\n * and delegates rendering and data updates to it.\n */\nclass FretboardView {\n    /**\n     * Creates a FretboardView.\n     * @param fretboardConfig - The configuration for the fretboard appearance.\n     * @param fretCount - The number of frets to display.\n     */\n    constructor(fretboardConfig, fretCount) {\n        this.canvas = null;\n        this.ctx = null;\n        // Store calculated dimensions (mostly for canvas creation)\n        this.requiredWidth = 0;\n        this.requiredHeight = 0;\n        this.fretboardConfig = fretboardConfig;\n        this.fretCount = fretCount > 0 ? fretCount : 12;\n        // Calculate dimensions needed for the canvas based on config and fret count\n        this.calculateDimensions();\n        // Instantiate the Fretboard logic class\n        // The Fretboard class itself uses START_PX internally for drawing padding\n        this.fretboard = new fretboard_1.Fretboard(this.fretboardConfig, this.fretboardConfig.scaleFactor * guitar_utils_1.START_PX, // Pass scaled start X\n        this.fretboardConfig.scaleFactor * guitar_utils_1.START_PX, // Pass scaled start Y\n        this.fretCount);\n    }\n    /** Calculates the required canvas dimensions. */\n    calculateDimensions() {\n        const config = this.fretboardConfig;\n        const scaleFactor = config.scaleFactor;\n        const scaledNoteRadius = config.noteRadiusPx;\n        const scaledStartPx = guitar_utils_1.START_PX * scaleFactor;\n        const openNoteClearance = scaledNoteRadius * 1.5 + 5 * scaleFactor;\n        const fretboardLinesHeight = this.fretCount * config.fretLengthPx;\n        const bottomClearance = scaledNoteRadius + 5 * scaleFactor;\n        this.requiredWidth =\n            scaledStartPx + config.stringSpacingPx * 5 + scaledStartPx;\n        this.requiredHeight =\n            scaledStartPx +\n                openNoteClearance +\n                fretboardLinesHeight +\n                bottomClearance +\n                scaledStartPx;\n    }\n    /** Creates the canvas and triggers the initial render via the Fretboard instance. */\n    render(container) {\n        if (!this.canvas) {\n            this.createCanvas(container);\n        }\n        else {\n            if (!this.canvas.parentNode) {\n                // Re-attach if detached\n                container.appendChild(this.canvas);\n            }\n        }\n        // Always delegate rendering to the Fretboard instance\n        if (this.ctx) {\n            this.fretboard.render(this.ctx);\n        }\n        else {\n            console.error(\"Canvas context not available for FretboardView render.\");\n        }\n    }\n    /** Creates the canvas element. */\n    createCanvas(container) {\n        const canvasIdSuffix = `fretboard-${Date.now()}`;\n        this.canvas = (0, guitar_utils_1.addCanvas)(container, canvasIdSuffix);\n        this.canvas.width = Math.max(150, this.requiredWidth);\n        this.canvas.height = Math.max(150, this.requiredHeight);\n        this.canvas.classList.add(\"fretboard-view-canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        if (!this.ctx) {\n            console.error(\"Failed to get 2D context for FretboardView.\");\n            this.canvas = null;\n        }\n    }\n    // --- Public Methods to Pass Data to Fretboard Instance ---\n    setNotes(notes) {\n        this.fretboard.setNotes(notes);\n        this.redrawIfReady(); // Trigger redraw after data update\n    }\n    setLines(lines) {\n        this.fretboard.setLines(lines);\n        this.redrawIfReady();\n    }\n    clearMarkings() {\n        this.fretboard.clearMarkings();\n        this.redrawIfReady();\n    }\n    /** Helper to redraw the canvas content via the Fretboard instance. */\n    redrawIfReady() {\n        var _a;\n        if (this.ctx && ((_a = this.canvas) === null || _a === void 0 ? void 0 : _a.parentNode)) {\n            // Use rAF for potentially smoother updates if rapid changes occur\n            requestAnimationFrame(() => {\n                if (this.ctx)\n                    this.fretboard.render(this.ctx);\n            });\n        }\n    }\n    // --- Expose Methods/Properties (Optional) ---\n    // May not be needed if Fretboard handles all drawing\n    getFretboard() {\n        return this.fretboard;\n    }\n    getCanvasElement() {\n        return this.canvas;\n    }\n    // --- View Lifecycle Methods ---\n    start() { } // No dynamic behavior\n    stop() { } // No dynamic behavior\n    destroy() {\n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n        this.canvas = null;\n        this.ctx = null;\n        this.fretboard.clearMarkings(); // Clear data in underlying fretboard\n    }\n}\nexports.FretboardView = FretboardView;\n\n\n//# sourceURL=webpack:///./guitar/views/fretboard_view.ts?");

/***/ }),

/***/ "./guitar/views/metronome_view.ts":
/*!****************************************!*\
  !*** ./guitar/views/metronome_view.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetronomeView = void 0;\n// Define beat states\nvar BeatState;\n(function (BeatState) {\n    BeatState[BeatState[\"Silent\"] = 0] = \"Silent\";\n    BeatState[BeatState[\"Normal\"] = 1] = \"Normal\";\n    BeatState[BeatState[\"Accent\"] = 2] = \"Accent\";\n})(BeatState || (BeatState = {}));\nconst COMMON_TIME_SIGNATURES = [\n    { beats: 4, subdivision: 4, label: \"4/4\" },\n    { beats: 3, subdivision: 4, label: \"3/4\" },\n    { beats: 2, subdivision: 4, label: \"2/4\" },\n    { beats: 6, subdivision: 8, label: \"6/8\" },\n    { beats: 5, subdivision: 4, label: \"5/4\" },\n    { beats: 7, subdivision: 8, label: \"7/8\" },\n];\n/**\n * A View that functions as a metronome with interactive visualization,\n * tempo control, time signature selection, accent control, and mute functionality.\n * Assumes 8th note level interaction for beat toggling.\n */\nclass MetronomeView {\n    constructor(bpm, audioController) {\n        this.intervalId = null;\n        this.container = null;\n        // State\n        this.isRunning = false;\n        this.currentTimeSignature = COMMON_TIME_SIGNATURES[0]; // Default to 4/4\n        this.currentSubdivisionLevel = 8; // Currently fixed to show 8th notes visually\n        this.numberOfVisualBeats = 8; // Visual beats shown (e.g., 8 for 4/4 @ 8th notes)\n        this.beatStates = []; // Stores state (Silent, Normal, Accent) for each visual beat\n        this.currentTickIndex = -1; // Tracks the current metronome tick (0 to numberOfVisualBeats - 1)\n        this.isMuted = false;\n        // UI Elements\n        this.viewWrapper = null;\n        this.visualizerContainer = null;\n        this.beatsContainer = null;\n        this.beatElements = [];\n        this.controlsContainer = null;\n        this.timeSigSelect = null;\n        this.bpmSlider = null;\n        this.bpmDisplay = null;\n        this.playPauseButton = null;\n        this.muteButton = null;\n        this.bpm = bpm > 0 ? bpm : 60;\n        this.audioController = audioController;\n        this.updateNumberOfVisualBeats(); // Calculate initial visual beats\n        this.initializeBeatStates(); // Initialize beat states based on default time sig\n    }\n    /** Calculates the number of visual subdivisions based on the time signature. */\n    updateNumberOfVisualBeats() {\n        // Calculate visual beats assuming 8th note display level\n        if (this.currentTimeSignature.subdivision === 8) {\n            this.numberOfVisualBeats = this.currentTimeSignature.beats;\n        }\n        else {\n            // Assume quarter note beat or other\n            this.numberOfVisualBeats = this.currentTimeSignature.beats * 2;\n        }\n        // Ensure beatStates array is compatible, resetting with new defaults\n        const currentLength = this.beatStates.length;\n        if (currentLength !== this.numberOfVisualBeats) {\n            // Don't try to preserve old states when number of beats changes drastically\n            this.initializeBeatStates(); // Re-initialize with new defaults\n        }\n    }\n    /** Sets the initial beat states based on the current time signature. */\n    initializeBeatStates() {\n        this.beatStates = new Array(this.numberOfVisualBeats);\n        // Calculate how many visual ticks represent one main beat\n        const step = this.currentSubdivisionLevel / this.currentTimeSignature.subdivision;\n        for (let i = 0; i < this.numberOfVisualBeats; i++) {\n            // Check if this visual tick falls ON a main beat\n            if (i % step === 0) {\n                // It's a main beat (downbeat)\n                this.beatStates[i] = i === 0 ? BeatState.Accent : BeatState.Normal; // Accent beat 1, Normal others\n            }\n            else {\n                // It's an off-beat subdivision\n                this.beatStates[i] = BeatState.Silent;\n            }\n        }\n        // Ensure beat 1 is always accented if array isn't empty\n        if (this.beatStates.length > 0 && this.beatStates[0] !== BeatState.Accent) {\n            this.beatStates[0] = BeatState.Accent;\n        }\n    }\n    render(container) {\n        this.container = container;\n        this.cleanupVisuals(); // Remove any previous visuals\n        this.viewWrapper = document.createElement(\"div\");\n        this.viewWrapper.classList.add(\"metronome-view\");\n        // Apply styles from CSS\n        this.visualizerContainer = document.createElement(\"div\");\n        this.visualizerContainer.classList.add(\"metronome-visualizer\");\n        // --- Beat Visualizer ---\n        this.beatsContainer = document.createElement(\"div\");\n        this.beatsContainer.classList.add(\"metronome-beats-container\");\n        this.rebuildVisualizer(); // Build initial beats based on state\n        this.visualizerContainer.appendChild(this.beatsContainer);\n        this.viewWrapper.appendChild(this.visualizerContainer);\n        this.controlsContainer = document.createElement(\"div\");\n        this.controlsContainer.classList.add(\"metronome-controls\");\n        const leftControls = document.createElement(\"div\");\n        const rightControls = document.createElement(\"div\");\n        rightControls.style.flexGrow = \"1\"; // Allow BPM section to take space\n        rightControls.style.justifyContent = \"flex-end\";\n        rightControls.style.display = \"flex\";\n        rightControls.style.alignItems = \"center\";\n        rightControls.style.gap = \"8px\";\n        // Time Signature Select\n        const timeSigWrapper = document.createElement(\"div\");\n        timeSigWrapper.classList.add(\"select\", \"is-small\");\n        this.timeSigSelect = document.createElement(\"select\");\n        this.timeSigSelect.setAttribute(\"aria-label\", \"Time Signature\");\n        COMMON_TIME_SIGNATURES.forEach((sig) => {\n            const option = new Option(sig.label, sig.label);\n            if (sig.label === this.currentTimeSignature.label)\n                option.selected = true;\n            this.timeSigSelect.appendChild(option);\n        });\n        this.timeSigSelect.addEventListener(\"change\", this.handleTimeSigChange.bind(this));\n        timeSigWrapper.appendChild(this.timeSigSelect);\n        leftControls.appendChild(timeSigWrapper);\n        this.playPauseButton = document.createElement(\"button\");\n        this.playPauseButton.type = \"button\";\n        this.playPauseButton.classList.add(\"button\", \"is-small\", \"play-pause-btn\");\n        this.playPauseButton.innerHTML = `<span class=\"material-icons\">play_arrow</span>`;\n        this.playPauseButton.title = \"Play/Pause Metronome\";\n        this.playPauseButton.addEventListener('click', () => {\n            if (this.isRunning) {\n                this.stop();\n            }\n            else {\n                this.start();\n            }\n        });\n        leftControls.appendChild(this.playPauseButton);\n        // Mute Button\n        this.muteButton = document.createElement(\"button\");\n        this.muteButton.type = \"button\";\n        this.muteButton.classList.add(\"button\", \"is-small\", \"metronome-mute-btn\");\n        this.muteButton.style.minWidth = \"65px\";\n        this.muteButton.addEventListener(\"click\", this.toggleMute.bind(this));\n        leftControls.appendChild(this.muteButton);\n        // BPM Slider\n        this.bpmSlider = document.createElement(\"input\");\n        this.bpmSlider.type = \"range\";\n        this.bpmSlider.min = \"20\";\n        this.bpmSlider.max = \"240\";\n        this.bpmSlider.value = String(this.bpm);\n        this.bpmSlider.classList.add(\"metronome-bpm-slider\");\n        this.bpmSlider.addEventListener(\"input\", this.handleSliderInput.bind(this));\n        rightControls.appendChild(this.bpmSlider);\n        // BPM Display\n        this.bpmDisplay = document.createElement(\"span\");\n        this.bpmDisplay.classList.add(\"metronome-bpm-display\", \"is-size-7\");\n        rightControls.appendChild(this.bpmDisplay);\n        this.controlsContainer.appendChild(leftControls);\n        this.controlsContainer.appendChild(rightControls);\n        this.viewWrapper.appendChild(this.controlsContainer);\n        this.container.appendChild(this.viewWrapper);\n        this.updateBpmDisplay();\n        this.updateMuteButtonState();\n        this.updateAllBeatStyles();\n        console.log(`MetronomeView rendered at ${this.bpm} BPM, ${this.currentTimeSignature.label}`);\n    }\n    rebuildVisualizer() {\n        if (!this.beatsContainer)\n            return;\n        this.beatsContainer.innerHTML = \"\";\n        this.beatElements = [];\n        const step = this.currentSubdivisionLevel / this.currentTimeSignature.subdivision;\n        for (let i = 0; i < this.numberOfVisualBeats; i++) {\n            const beatElement = document.createElement(\"div\");\n            beatElement.classList.add(\"metronome-beat\");\n            beatElement.dataset.index = String(i);\n            if (i % step === 0) {\n                beatElement.classList.add(\"beat-downbeat\");\n            }\n            else {\n                beatElement.classList.add(\"beat-subdivision\");\n            }\n            beatElement.addEventListener(\"click\", this.handleBeatClick.bind(this));\n            this.beatElements.push(beatElement);\n            this.beatsContainer.appendChild(beatElement);\n        }\n        this.updateAllBeatStyles(); // Apply styles based on current beatStates\n    }\n    handleTimeSigChange(event) {\n        const select = event.target;\n        const newLabel = select.value;\n        const newSig = COMMON_TIME_SIGNATURES.find((sig) => sig.label === newLabel);\n        if (newSig && newSig.label !== this.currentTimeSignature.label) {\n            console.log(\"Time Signature changed to:\", newLabel);\n            this.currentTimeSignature = newSig;\n            this.stopInterval();\n            this.updateNumberOfVisualBeats(); // Resets beatStates via initializeBeatStates call\n            this.rebuildVisualizer();\n            this.currentTickIndex = -1;\n            if (this.isRunning) {\n                this.startInterval();\n            }\n        }\n    }\n    start() {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            this.startInterval();\n        }\n        this.updateMuteButtonState();\n    }\n    stop() {\n        if (this.isRunning) {\n            this.isRunning = false;\n            this.stopInterval();\n        }\n        this.updateMuteButtonState();\n    }\n    startInterval() {\n        if (this.intervalId !== null || this.bpm <= 0)\n            return;\n        const ticksPerBeat = this.currentSubdivisionLevel / this.currentTimeSignature.subdivision;\n        const intervalMillis = (60 / this.bpm / ticksPerBeat) * 1000;\n        console.log(`Metronome starting: ${this.bpm} BPM, ${this.currentTimeSignature.label}, Interval: ${intervalMillis.toFixed(2)}ms`);\n        this.intervalId = window.setInterval(() => {\n            this.tick();\n        }, intervalMillis);\n    }\n    stopInterval() {\n        if (this.intervalId !== null) {\n            window.clearInterval(this.intervalId);\n            this.intervalId = null;\n            console.log(\"Metronome interval stopped.\");\n            this.resetCurrentBeatStyle();\n        }\n    }\n    toggleMute() {\n        this.isMuted = !this.isMuted;\n        this.updateMuteButtonState();\n    }\n    updateMuteButtonState() {\n        if (!this.muteButton)\n            return;\n        this.muteButton.textContent = this.isMuted ? \"Unmute\" : \"Mute\";\n        this.muteButton.classList.toggle(\"is-warning\", this.isMuted);\n    }\n    destroy() {\n        this.stopInterval();\n        this.cleanupVisuals();\n        this.container = null;\n    }\n    handleSliderInput(event) {\n        const target = event.target;\n        this.setBpm(parseInt(target.value, 10));\n    }\n    handleBeatClick(event) {\n        const target = event.currentTarget;\n        const indexStr = target.dataset.index;\n        if (indexStr === undefined)\n            return;\n        const index = parseInt(indexStr, 10);\n        if (isNaN(index) || index < 0 || index >= this.numberOfVisualBeats)\n            return;\n        const currentState = this.beatStates[index];\n        let nextState;\n        if (currentState === BeatState.Normal)\n            nextState = BeatState.Accent;\n        else if (currentState === BeatState.Accent)\n            nextState = BeatState.Silent;\n        else\n            nextState = BeatState.Normal; // Silent -> Normal\n        this.beatStates[index] = nextState;\n        this.applyBeatStyle(target, index);\n        console.log(`Beat ${index} state set to: ${BeatState[nextState]}`);\n    }\n    /** The metronome tick logic */\n    tick() {\n        this.resetCurrentBeatStyle();\n        this.currentTickIndex =\n            (this.currentTickIndex + 1) % this.numberOfVisualBeats;\n        const currentElement = this.beatElements[this.currentTickIndex];\n        if (currentElement) {\n            currentElement.classList.add(\"beat-current\");\n        }\n        const currentState = this.beatStates[this.currentTickIndex];\n        if (!this.isMuted) {\n            if (currentState === BeatState.Accent)\n                this.audioController.playAccentMetronomeClick();\n            else if (currentState === BeatState.Normal)\n                this.audioController.playMetronomeClick();\n        }\n    }\n    resetCurrentBeatStyle() {\n        if (this.currentTickIndex >= 0 &&\n            this.beatElements[this.currentTickIndex]) {\n            this.beatElements[this.currentTickIndex].classList.remove(\"beat-current\");\n        }\n    }\n    updateAllBeatStyles() {\n        this.beatElements.forEach((element, index) => {\n            this.applyBeatStyle(element, index);\n        });\n    }\n    /** Applies the appropriate style to a single beat element */\n    applyBeatStyle(element, index) {\n        element.classList.remove(\"beat-normal\", \"beat-accent\", \"beat-silent\", \"beat-current\");\n        switch (this.beatStates[index]) {\n            case BeatState.Accent:\n                element.classList.add(\"beat-accent\");\n                break;\n            case BeatState.Silent:\n                element.classList.add(\"beat-silent\");\n                break;\n            case BeatState.Normal:\n            default:\n                element.classList.add(\"beat-normal\");\n                break;\n        }\n        if (index === this.currentTickIndex) {\n            element.classList.add(\"beat-current\");\n        }\n    }\n    /** Removes the metronome UI elements from the DOM */\n    cleanupVisuals() {\n        if (this.viewWrapper && this.viewWrapper.parentNode) {\n            this.viewWrapper.parentNode.removeChild(this.viewWrapper);\n        }\n        this.viewWrapper = null;\n        this.visualizerContainer = null;\n        this.beatsContainer = null;\n        this.controlsContainer = null;\n        this.beatElements = [];\n        this.timeSigSelect = null;\n        this.bpmSlider = null;\n        this.bpmDisplay = null;\n        this.muteButton = null;\n    }\n    /** Updates the BPM and restarts the interval if running */\n    setBpm(newBpm) {\n        if (newBpm >= 20 && newBpm <= 240) {\n            const changed = this.bpm !== newBpm;\n            this.bpm = newBpm;\n            this.updateBpmDisplay();\n            if (changed && this.isRunning) {\n                this.stopInterval();\n                this.startInterval();\n            }\n        }\n    }\n    updateBpmDisplay() {\n        if (this.bpmDisplay) {\n            this.bpmDisplay.textContent = `${this.bpm} BPM`;\n        }\n    }\n}\nexports.MetronomeView = MetronomeView;\n\n\n//# sourceURL=webpack:///./guitar/views/metronome_view.ts?");

/***/ }),

/***/ "./main.ts":
/*!*****************!*\
  !*** ./main.ts ***!
  \*****************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Main = void 0;\n// ts/main.ts\nconst audio_controller_1 = __webpack_require__(/*! ./audio_controller */ \"./audio_controller.ts\");\nconst display_controller_1 = __webpack_require__(/*! ./display_controller */ \"./display_controller.ts\");\nconst schedule_editor_1 = __webpack_require__(/*! ./schedule/editor/schedule_editor */ \"./schedule/editor/schedule_editor.ts\");\n// --- Use new registry functions ---\nconst feature_registry_1 = __webpack_require__(/*! ./feature_registry */ \"./feature_registry.ts\");\nconst guitar_category_1 = __webpack_require__(/*! ./guitar/guitar_category */ \"./guitar/guitar_category.ts\");\n// Import settings functions and types\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./settings.ts\");\n// Other imports\nconst schedule_load_modal_1 = __webpack_require__(/*! ./schedule/schedule_load_modal */ \"./schedule/schedule_load_modal.ts\");\nconst floating_view_manager_1 = __webpack_require__(/*! ./floating_views/floating_view_manager */ \"./floating_views/floating_view_manager.ts\");\nconst floating_view_registry_1 = __webpack_require__(/*! ./floating_views/floating_view_registry */ \"./floating_views/floating_view_registry.ts\");\n// --- Constants ---\nconst DEFAULT_MAX_CANVAS_HEIGHT = 650;\nconst CATEGORY_SETTINGS_CONTAINER_ID = \"category-settings-container\";\nclass Main {\n    constructor() {\n        this.currentSchedule = null;\n        // Removed handleFloatingViewDestroyed method\n        // Bound function to remove listener correctly\n        this.handleClickOutsideDropdown = (event) => {\n            if (this.floatingViewDropdownContainerEl && !this.floatingViewDropdownContainerEl.contains(event.target)) {\n                this.floatingViewDropdownContainerEl.classList.remove('is-active');\n                document.removeEventListener('click', this.handleClickOutsideDropdown, true);\n            }\n        };\n        console.log(\"Initializing Main Application...\");\n        // --- Register Categories ---\n        (0, feature_registry_1.registerCategory)(new guitar_category_1.GuitarCategory());\n        // Register other categories here\n        // Load settings - uses the now-populated registry for defaults\n        this.settings = (0, settings_1.loadSettings)();\n        // --- Instantiate Floating View Manager ---\n        this.floatingViewManager = new floating_view_manager_1.FloatingViewManager(this.settings);\n        // --- End Instantiate ---\n        if (!this.ensureElementsExist())\n            return;\n        this.applySettings(); // Apply theme initially\n        // Initialize Controllers\n        this.audioController = new audio_controller_1.AudioController(document.querySelector(\"#intro-end-sound\"), document.querySelector(\"#interval-end-sound\"), document.querySelector(\"#metronome-sound\"), document.querySelector(\"#metronome-accent-sound\"));\n        this.displayController = new display_controller_1.DisplayController(document.querySelector(\"#timer\"), document.querySelector(\"#total-timer\"), document.querySelector(\"#task-wrapper\"), document.querySelector(\"#task\"), document.querySelector(\"#diagram\"), document.querySelector(\"#status\"), document.querySelector(\"#upcoming\"), document.querySelector(\"#start-control\"));\n        // Initialize Schedule Editor\n        const editorContainer = document.querySelector(\"#schedule-editor-container\");\n        if (editorContainer) {\n            this.scheduleEditor = new schedule_editor_1.ScheduleEditor(editorContainer, () => this.reset(), this.audioController);\n        }\n        else {\n            console.error(\"CRITICAL: Schedule editor container not found!\");\n            alert(\"Error: Schedule editor failed to load.\");\n            return; // Stop initialization if editor fails\n        }\n        // Initialize Load/Save Modal\n        const loadModalElement = document.querySelector(\"#load-schedule-modal\");\n        if (loadModalElement && this.scheduleEditor) {\n            this.scheduleLoadModal = new schedule_load_modal_1.ScheduleLoadModal(loadModalElement, this.scheduleEditor, settings_1.RECENT_SCHEDULES_JSON_KEY);\n            console.log(\"ScheduleLoadModal initialized.\");\n        }\n        else {\n            console.warn(\"Load schedule modal element or ScheduleEditor not found. Load functionality unavailable.\");\n        }\n        this.addControlHandlers();\n        this.addSettingsModalHandlers(); // Attaches the updated handlers\n        this.addAccordionHandlers();\n        this.addFloatingViewDropdownHandlers(); // Add handlers for the new dropdown\n        // --- Restore Floating Views AFTER manager is initialized ---\n        this.floatingViewManager.restoreViewsFromState();\n        // --- End Restore ---\n        // Load last run schedule (logic remains similar, relies on editor/serializer updates later)\n        let loadedFromStorage = false; // Declare here\n        const lastRunJSON = localStorage.getItem(settings_1.LAST_RUN_SCHEDULE_JSON_KEY);\n        if (lastRunJSON) {\n            try {\n                console.log(\"Found last run schedule (JSON) in localStorage. Attempting to load...\");\n                this.scheduleEditor.setScheduleJSON(lastRunJSON, true); // skipSync=true\n                loadedFromStorage = true;\n                console.log(\"Last run schedule (JSON) loaded successfully into editor.\");\n                this.reset(); // Trigger reset manually AFTER successful load\n            }\n            catch (e) {\n                console.error(\"Error loading or setting last run schedule JSON:\", e);\n                localStorage.removeItem(settings_1.LAST_RUN_SCHEDULE_JSON_KEY); // Remove invalid data\n                this.reset(); // Fallback to default reset\n            }\n        }\n        if (!loadedFromStorage) {\n            console.log(\"No last run schedule JSON found or loading failed. Performing initial reset.\");\n            this.reset();\n        }\n        // Populate dropdown initially (optional, it populates on open anyway)\n        // this.populateFloatingViewDropdown();\n        console.log(\"Initialization complete.\");\n    }\n    // Updated: Remove specific guitar setting IDs\n    ensureElementsExist() {\n        const requiredIds = [\n            // Core UI\n            \"#timer\", \"#total-timer\", \"#task-wrapper\", \"#task\", \"#diagram\",\n            \"#status\", \"#upcoming\", \"#start-control\", \"#skip-control\", \"#reset-control\",\n            // Audio\n            \"#intro-end-sound\", \"#interval-end-sound\", \"#metronome-sound\", \"#metronome-accent-sound\",\n            // Editor & Name\n            \"#schedule-editor-container\", \"#schedule-accordion\",\n            \"#schedule-name-display\", \"#edit-schedule-name-btn\",\n            // Settings Modal Core\n            \"#settings-button\", \"#settings-modal\", \"#settings-save-button\",\n            \"#settings-cancel-button\", \"#settings-modal-close\",\n            \"#theme-select\", \"#warmup-input\", // Global settings inputs\n            `#${CATEGORY_SETTINGS_CONTAINER_ID}`, // Container for dynamic settings *MUST EXIST*\n            // Load/save modal (Optional check)\n            \"#load-schedule-button\", \"#load-schedule-modal\",\n            // Floating Views (Add new elements)\n            '#floating-view-button',\n            '#floating-view-area',\n            '#floating-view-dropdown-container', // New dropdown container\n            '#floating-view-dropdown-content', // New dropdown content area\n        ];\n        let allFound = true;\n        requiredIds.forEach((id) => {\n            const element = document.querySelector(id);\n            if (!element) {\n                // Adjust warnings/errors based on criticality\n                if (id === \"#load-schedule-modal\" || id === \"#load-schedule-button\") {\n                    console.warn(`Optional HTML element not found: ${id}. Load/Save functionality might be unavailable.`);\n                }\n                else if (id === \"#schedule-name-display\" || id === \"#edit-schedule-name-btn\") {\n                    console.warn(`Optional HTML element not found: ${id}. Schedule naming UI disabled.`);\n                }\n                else if (id === `#${CATEGORY_SETTINGS_CONTAINER_ID}`) {\n                    console.error(`CRITICAL ERROR: Category settings container not found: ${id}`);\n                    allFound = false;\n                }\n                else if (id === '#floating-view-button' || id === '#floating-view-area' || id === '#floating-view-dropdown-container' || id === '#floating-view-dropdown-content') {\n                    console.warn(`Optional HTML element not found: ${id}. Floating view functionality might be unavailable.`);\n                    // Don't set allFound to false for optional elements unless critical\n                }\n                else {\n                    console.error(`CRITICAL ERROR: Required HTML element not found: ${id}`);\n                    allFound = false;\n                }\n            }\n        });\n        if (allFound) {\n            // Assign core elements needed by methods that were validated above\n            this.settingsModalEl = document.querySelector(\"#settings-modal\");\n            this.scheduleAccordionEl = document.querySelector(\"#schedule-accordion\");\n            this.scheduleAccordionHeaderEl = this.scheduleAccordionEl.querySelector(\".accordion-header\");\n            this.loadScheduleButtonEl = document.querySelector(\"#load-schedule-button\"); // May be null\n            this.floatingViewButtonEl = document.querySelector('#floating-view-button'); // Assign new button\n            this.floatingViewDropdownContainerEl = document.querySelector('#floating-view-dropdown-container');\n            this.floatingViewDropdownContentEl = document.querySelector('#floating-view-dropdown-content');\n            // Ensure header was found if accordion was\n            if (this.scheduleAccordionEl && !this.scheduleAccordionHeaderEl) {\n                console.error(\"CRITICAL ERROR: Accordion header not found inside accordion element.\");\n                allFound = false;\n            }\n        }\n        if (!allFound && !document.querySelector(`#${CATEGORY_SETTINGS_CONTAINER_ID}`)) {\n            alert(\"Error: Critical page element missing (Category Settings Container). Application cannot function correctly.\");\n        }\n        else if (!allFound && document.querySelector('#floating-view-button')) { // Check if it was just the floating view elements missing\n            console.warn(\"Some non-critical page elements were not found. Application might not work correctly.\");\n        }\n        else if (!allFound) {\n            alert(\"Error: Some required page elements could not be found. The application might not work correctly.\");\n        }\n        return allFound;\n    }\n    addControlHandlers() {\n        const startBtn = document.querySelector(\"#start-control\");\n        const skipBtn = document.querySelector(\"#skip-control\");\n        const resetBtn = document.querySelector(\"#reset-control\");\n        this.settingsButtonEl = document.querySelector(\"#settings-button\");\n        this.loadScheduleButtonEl = document.querySelector(\"#load-schedule-button\"); // May be null\n        if (!startBtn || !skipBtn || !resetBtn || !this.settingsButtonEl) {\n            console.error(\"Core control or Settings buttons not found!\");\n            return;\n        }\n        this.controlButtonEl = startBtn;\n        this.skipButtonEl = skipBtn;\n        this.controlButtonEl.onclick = () => this.toggleCountdown();\n        this.skipButtonEl.onclick = () => this.skipCurrentTask();\n        resetBtn.onclick = () => this.reset();\n        this.settingsButtonEl.onclick = () => this.openSettingsModal();\n        // Attach handler for load/save button only if modal is available\n        if (this.loadScheduleButtonEl && this.scheduleLoadModal) {\n            this.loadScheduleButtonEl.onclick = () => {\n                var _a;\n                if ((_a = this.currentSchedule) === null || _a === void 0 ? void 0 : _a.isRunning()) {\n                    alert(\"Please stop the timer before loading or saving schedules.\");\n                    return;\n                }\n                this.scheduleLoadModal.show();\n            };\n        }\n        else if (this.loadScheduleButtonEl) {\n            this.loadScheduleButtonEl.setAttribute(\"disabled\", \"true\");\n            this.loadScheduleButtonEl.setAttribute(\"title\", \"Load modal failed to initialize.\");\n        }\n        // Note: Floating View button handler is moved to addFloatingViewDropdownHandlers\n    }\n    // --- Method for Dropdown Handling (Updated) ---\n    addFloatingViewDropdownHandlers() {\n        if (!this.floatingViewButtonEl || !this.floatingViewDropdownContainerEl) {\n            console.warn(\"Floating view button or dropdown container not found, handler not attached.\");\n            return;\n        }\n        // Toggle dropdown visibility\n        this.floatingViewButtonEl.onclick = (event) => {\n            event.stopPropagation(); // Prevent body click handler from closing immediately\n            const isActive = this.floatingViewDropdownContainerEl.classList.toggle('is-active');\n            if (isActive) {\n                this.populateFloatingViewDropdown(); // Refresh content when opening\n                // Add listener to close dropdown when clicking outside\n                document.addEventListener('click', this.handleClickOutsideDropdown, true);\n            }\n            else {\n                document.removeEventListener('click', this.handleClickOutsideDropdown, true);\n            }\n        };\n        // Remove the 'floating-view-destroyed' listener as it's no longer needed for checkbox sync\n        // document.removeEventListener('floating-view-destroyed', this.handleFloatingViewDestroyed);\n    }\n    // --- Updated to create buttons instead of checkboxes ---\n    populateFloatingViewDropdown() {\n        if (!this.floatingViewDropdownContentEl)\n            return;\n        this.floatingViewDropdownContentEl.innerHTML = ''; // Clear previous items\n        const availableViews = (0, floating_view_registry_1.getAvailableFloatingViews)();\n        if (availableViews.length === 0) {\n            const noViewsItem = document.createElement('p');\n            noViewsItem.classList.add('dropdown-item', 'is-size-7', 'has-text-grey');\n            noViewsItem.textContent = 'No views available';\n            this.floatingViewDropdownContentEl.appendChild(noViewsItem);\n            return;\n        }\n        availableViews.forEach(desc => {\n            const viewId = desc.viewId;\n            const displayName = desc.displayName;\n            const categoryName = desc.categoryName;\n            // Create a clickable link/button for each view\n            const dropdownItem = document.createElement('a');\n            dropdownItem.classList.add('dropdown-item');\n            dropdownItem.href = \"#\"; // Make it behave like a link\n            // Combine display name and category\n            const itemText = document.createElement('span');\n            itemText.textContent = displayName;\n            const categorySpan = document.createElement('span');\n            categorySpan.textContent = ` (${categoryName})`;\n            categorySpan.classList.add('is-size-7', 'has-text-grey', 'ml-1');\n            dropdownItem.appendChild(itemText);\n            dropdownItem.appendChild(categorySpan);\n            // Attach onclick to spawn the view\n            dropdownItem.onclick = (e) => {\n                e.preventDefault(); // Prevent default link behavior\n                console.log(`Spawning view: ${viewId}`);\n                this.floatingViewManager.spawnView(viewId);\n                // Optionally close the dropdown after spawning\n                this.floatingViewDropdownContainerEl.classList.remove('is-active');\n                document.removeEventListener('click', this.handleClickOutsideDropdown, true);\n            };\n            this.floatingViewDropdownContentEl.appendChild(dropdownItem);\n        });\n    }\n    // --- END Changes ---\n    /** Saves the complete AppSettings object to localStorage */\n    saveSettings(newSettings) {\n        try {\n            // Update the manager's reference BEFORE saving\n            if (this.floatingViewManager) {\n                this.floatingViewManager.appSettings = newSettings; // Update public member\n                console.log(\"[saveSettings] Updated FloatingViewManager settings reference.\");\n            }\n            console.log(\"[saveSettings] Attempting to save:\", JSON.stringify(newSettings));\n            localStorage.setItem(settings_1.SETTINGS_STORAGE_KEY, JSON.stringify(newSettings));\n            this.settings = newSettings; // Update the Main instance's settings\n            console.log(\"[saveSettings] Settings object updated in Main instance.\");\n            // --- Settings Change Notification for Floating Views ---\n            if (this.floatingViewManager) {\n                const activeViews = this.floatingViewManager['activeViews']; // Access private map\n                activeViews.forEach(wrapper => {\n                    var _a, _b, _c;\n                    const viewInstance = wrapper['viewInstance'];\n                    // Check if the view instance has an onSettingsChange method\n                    if (viewInstance && typeof viewInstance.onSettingsChange === 'function') {\n                        try {\n                            console.log(`Notifying view instance ${(_a = wrapper['state']) === null || _a === void 0 ? void 0 : _a.instanceId} of settings change.`);\n                            viewInstance.onSettingsChange(newSettings);\n                        }\n                        catch (e) {\n                            console.error(\"Error calling onSettingsChange for view:\", (_b = wrapper['state']) === null || _b === void 0 ? void 0 : _b.viewId, e);\n                        }\n                    }\n                    // Re-render the legend view specifically if it exists, as it depends directly on settings\n                    else if (((_c = wrapper['state']) === null || _c === void 0 ? void 0 : _c.viewId) === 'guitar_color_legend') {\n                        const contentElement = wrapper['contentElement'];\n                        if (contentElement && viewInstance && typeof viewInstance.render === 'function') {\n                            console.log(\"Re-rendering color legend due to settings change.\");\n                            viewInstance.render(contentElement); // Call render directly\n                        }\n                    }\n                });\n            }\n            // --- End Notification ---\n        }\n        catch (e) {\n            console.error(\"Failed to save settings to localStorage:\", e);\n            alert(\"Error saving settings.\");\n        }\n    }\n    /** Applies global settings (like theme) */\n    applySettings() {\n        if (this.settings.theme === \"dark\") {\n            document.body.classList.add(\"dark-theme\");\n        }\n        else {\n            document.body.classList.remove(\"dark-theme\");\n        }\n        console.log(\"Global settings applied.\");\n    }\n    /** Helper to get merged category settings using string name */\n    getCategorySettings(categoryName) {\n        var _a, _b, _c;\n        const defaults = (_a = (0, feature_registry_1.getDefaultGlobalSettingsForCategory)(categoryName)) !== null && _a !== void 0 ? _a : {};\n        const stored = (_c = (_b = this.settings.categorySettings) === null || _b === void 0 ? void 0 : _b[categoryName]) !== null && _c !== void 0 ? _c : {};\n        return Object.assign(Object.assign({}, defaults), stored);\n    }\n    /** Populates and opens the settings modal dynamically */\n    openSettingsModal() {\n        var _a;\n        if ((_a = this.currentSchedule) === null || _a === void 0 ? void 0 : _a.isRunning()) {\n            alert(\"Please stop the timer before changing settings.\");\n            return;\n        }\n        if (!this.settingsModalEl)\n            return;\n        // Populate Global Settings (Theme, Warmup)\n        document.getElementById(\"theme-select\").value = this.settings.theme;\n        document.getElementById(\"warmup-input\").value = String(this.settings.warmupPeriod);\n        // Populate Dynamic Category Settings\n        const container = this.settingsModalEl.querySelector(`#${CATEGORY_SETTINGS_CONTAINER_ID}`);\n        if (!container) {\n            console.error(\"Cannot find category settings container in modal!\");\n            return;\n        }\n        container.innerHTML = \"\"; // Clear previous dynamic content\n        const categories = (0, feature_registry_1.getAvailableCategories)();\n        console.log(`Found ${categories.length} registered categories.`);\n        categories.forEach((categoryInstance) => {\n            var _a;\n            if (typeof categoryInstance.getGlobalSettingsUISchema === \"function\") {\n                const schemaItems = categoryInstance.getGlobalSettingsUISchema();\n                const categoryName = categoryInstance.getName();\n                console.log(`Processing category: ${categoryName}, Schema items: ${(_a = schemaItems === null || schemaItems === void 0 ? void 0 : schemaItems.length) !== null && _a !== void 0 ? _a : 0}`);\n                if (schemaItems && schemaItems.length > 0) {\n                    const currentCategorySettings = this.getCategorySettings(categoryName);\n                    // Create Category Header\n                    const categoryHeader = document.createElement(\"h5\");\n                    categoryHeader.textContent = `${categoryInstance.getDisplayName()} Settings`;\n                    categoryHeader.classList.add(\"title\", \"is-6\", \"category-settings-header\", \"mt-4\");\n                    container.appendChild(categoryHeader);\n                    // Create UI elements from schema\n                    schemaItems.forEach((item) => {\n                        const fieldDiv = document.createElement(\"div\");\n                        fieldDiv.classList.add(\"field\", \"is-horizontal\");\n                        const fieldLabel = document.createElement(\"div\");\n                        fieldLabel.classList.add(\"field-label\", \"is-normal\");\n                        const label = document.createElement(\"label\");\n                        label.classList.add(\"label\");\n                        label.textContent = item.label;\n                        if (item.description)\n                            label.title = item.description;\n                        fieldLabel.appendChild(label);\n                        const fieldBody = document.createElement(\"div\");\n                        fieldBody.classList.add(\"field-body\");\n                        const fieldInner = document.createElement(\"div\");\n                        fieldInner.classList.add(\"field\");\n                        const control = document.createElement(\"div\");\n                        control.classList.add(\"control\", \"is-expanded\");\n                        let inputElement = null;\n                        const inputId = `setting-${categoryName}-${item.key}`;\n                        const currentValue = currentCategorySettings === null || currentCategorySettings === void 0 ? void 0 : currentCategorySettings[item.key];\n                        if (item.type === \"select\" && item.options) {\n                            const selectElement = document.createElement(\"select\");\n                            selectElement.id = inputId;\n                            const selectWrapper = document.createElement(\"div\");\n                            selectWrapper.classList.add(\"select\", \"is-fullwidth\");\n                            item.options.forEach((opt) => {\n                                const option = document.createElement(\"option\");\n                                option.value = opt.value;\n                                option.textContent = opt.text;\n                                if (currentValue !== undefined && String(currentValue) === opt.value) {\n                                    option.selected = true;\n                                }\n                                selectElement.appendChild(option);\n                            });\n                            selectWrapper.appendChild(selectElement);\n                            control.appendChild(selectWrapper);\n                            inputElement = selectElement;\n                        }\n                        else if (item.type === \"checkbox\") {\n                            const checkboxElement = document.createElement(\"input\");\n                            checkboxElement.id = inputId;\n                            checkboxElement.type = \"checkbox\";\n                            checkboxElement.classList.add(\"checkbox\");\n                            checkboxElement.checked = !!currentValue;\n                            const checkboxLabel = document.createElement(\"label\");\n                            checkboxLabel.classList.add(\"checkbox\");\n                            checkboxLabel.style.paddingTop = \"calc(0.5em - 1px)\";\n                            checkboxLabel.appendChild(checkboxElement);\n                            control.appendChild(checkboxLabel);\n                            inputElement = checkboxElement;\n                        }\n                        else {\n                            const textInputElement = document.createElement(\"input\");\n                            textInputElement.id = inputId;\n                            textInputElement.type = item.type === \"number\" ? \"number\" : \"text\";\n                            textInputElement.classList.add(\"input\");\n                            textInputElement.value = currentValue !== undefined ? String(currentValue) : \"\";\n                            if (item.placeholder)\n                                textInputElement.placeholder = item.placeholder;\n                            if (item.min !== undefined)\n                                textInputElement.min = String(item.min);\n                            if (item.max !== undefined)\n                                textInputElement.max = String(item.max);\n                            if (item.step !== undefined)\n                                textInputElement.step = String(item.step);\n                            control.appendChild(textInputElement);\n                            inputElement = textInputElement;\n                        }\n                        if (inputElement) {\n                            inputElement.dataset.category = categoryName;\n                            inputElement.dataset.setting = item.key;\n                            label.htmlFor = inputId;\n                        }\n                        else {\n                            console.warn(`Could not create input element for setting: ${categoryName}.${item.key}`);\n                        }\n                        fieldInner.appendChild(control);\n                        fieldBody.appendChild(fieldInner);\n                        fieldDiv.appendChild(fieldLabel);\n                        fieldDiv.appendChild(fieldBody);\n                        container.appendChild(fieldDiv);\n                    });\n                }\n            }\n            else {\n                console.log(`Category ${categoryInstance.getName()} does not provide a global settings UI schema.`);\n            }\n        });\n        this.settingsModalEl.classList.add(\"is-active\");\n    }\n    /** Closes the settings modal */\n    closeSettingsModal() {\n        if (!this.settingsModalEl)\n            return;\n        this.settingsModalEl.classList.remove(\"is-active\");\n    }\n    /** Attaches handlers for the settings modal buttons */\n    addSettingsModalHandlers() {\n        var _a;\n        const saveBtn = document.getElementById(\"settings-save-button\");\n        const cancelBtn = document.getElementById(\"settings-cancel-button\");\n        const closeBtn = document.getElementById(\"settings-modal-close\"); // Standard Bulma modal close\n        if (!saveBtn || !cancelBtn || !closeBtn || !this.settingsModalEl)\n            return;\n        saveBtn.onclick = () => {\n            const newSettings = JSON.parse(JSON.stringify(this.settings));\n            // 1. Update global settings (Theme, Warmup)\n            newSettings.theme = document.getElementById(\"theme-select\").value;\n            newSettings.warmupPeriod = Math.max(0, parseInt(document.getElementById(\"warmup-input\").value, 10) || 0);\n            // 2. Update Category Settings Dynamically\n            const container = this.settingsModalEl.querySelector(`#${CATEGORY_SETTINGS_CONTAINER_ID}`);\n            if (container) {\n                const settingElements = container.querySelectorAll(\"input[data-setting], select[data-setting]\");\n                settingElements.forEach((element) => {\n                    var _a;\n                    const categoryName = element.dataset.category;\n                    const settingKey = element.dataset.setting;\n                    if (categoryName && settingKey) {\n                        if (!newSettings.categorySettings[categoryName]) {\n                            const defaults = (_a = (0, feature_registry_1.getDefaultGlobalSettingsForCategory)(categoryName)) !== null && _a !== void 0 ? _a : {};\n                            newSettings.categorySettings[categoryName] = Object.assign({}, defaults);\n                        }\n                        let value;\n                        if (element.type === \"checkbox\")\n                            value = element.checked;\n                        else if (element.type === \"number\") {\n                            const numVal = parseFloat(element.value);\n                            value = isNaN(numVal) ? 0 : numVal;\n                            const min = element.getAttribute(\"min\");\n                            const max = element.getAttribute(\"max\");\n                            if (min !== null)\n                                value = Math.max(parseFloat(min), value);\n                            if (max !== null)\n                                value = Math.min(parseFloat(max), value);\n                        }\n                        else\n                            value = element.value;\n                        newSettings.categorySettings[categoryName][settingKey] = value;\n                    }\n                    else {\n                        console.warn(\"Found settings input missing category or setting data attribute:\", element);\n                    }\n                });\n            }\n            else {\n                console.error(\"Category settings container not found during save operation!\");\n            }\n            // 3. Save, Apply, Close, Reset\n            this.saveSettings(newSettings);\n            this.applySettings();\n            this.closeSettingsModal(); // Call the method to close\n            this.reset();\n        };\n        // Add handlers to close the modal\n        cancelBtn.onclick = () => this.closeSettingsModal();\n        closeBtn.onclick = () => this.closeSettingsModal();\n        (_a = this.settingsModalEl.querySelector(\".modal-background\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", () => this.closeSettingsModal());\n    }\n    // addAccordionHandlers, toggleScheduleAccordion remain the same\n    addAccordionHandlers() {\n        if (!this.scheduleAccordionHeaderEl)\n            return;\n        this.scheduleAccordionHeaderEl.onclick = () => {\n            const isCollapsed = this.scheduleAccordionEl.classList.contains(\"collapsed\");\n            this.toggleScheduleAccordion(!isCollapsed);\n        };\n    }\n    toggleScheduleAccordion(collapse) {\n        if (!this.scheduleAccordionEl)\n            return;\n        this.scheduleAccordionEl.classList.toggle(\"collapsed\", collapse);\n    }\n    // toggleCountdown, skipCurrentTask remain the same conceptually\n    toggleCountdown() {\n        var _a, _b, _c;\n        if ((_a = this.settingsModalEl) === null || _a === void 0 ? void 0 : _a.classList.contains(\"is-active\")) {\n            console.warn(\"Settings modal is open.\");\n            return;\n        }\n        if ((_b = this.scheduleLoadModal) === null || _b === void 0 ? void 0 : _b.isOpen()) {\n            console.warn(\"Load Schedule modal is open.\");\n            return;\n        }\n        if (!this.currentSchedule) {\n            this.reset();\n            if (!this.currentSchedule) {\n                console.error(\"Cannot start timer: Reset failed.\");\n                return;\n            }\n        }\n        if (this.currentSchedule.isFinished()) {\n            this.reset();\n        }\n        else if (this.currentSchedule.isRunning()) {\n            this.currentSchedule.pause();\n            this.toggleScheduleAccordion(false);\n        }\n        else {\n            try {\n                const scheduleJSON = this.scheduleEditor.getScheduleJSON();\n                let isValidToSave = false;\n                try {\n                    const parsed = JSON.parse(scheduleJSON);\n                    isValidToSave = parsed && Array.isArray(parsed.items) && parsed.items.length > 0;\n                }\n                catch (_d) { }\n                if (isValidToSave) {\n                    localStorage.setItem(settings_1.LAST_RUN_SCHEDULE_JSON_KEY, scheduleJSON);\n                    console.log(\"Saved current schedule as last run schedule (JSON).\");\n                    // Update Recent List (logic remains same)\n                    const stored = localStorage.getItem(settings_1.RECENT_SCHEDULES_JSON_KEY);\n                    let recentSchedules = [];\n                    if (stored) {\n                        try {\n                            const p = JSON.parse(stored);\n                            if (Array.isArray(p) && p.every((s) => typeof s === \"string\"))\n                                recentSchedules = p;\n                        }\n                        catch (e) {\n                            console.error(e);\n                        }\n                    }\n                    recentSchedules = recentSchedules.filter((item) => item !== scheduleJSON);\n                    recentSchedules.unshift(scheduleJSON);\n                    if (recentSchedules.length > settings_1.MAX_RECENT_SCHEDULES)\n                        recentSchedules.length = settings_1.MAX_RECENT_SCHEDULES;\n                    localStorage.setItem(settings_1.RECENT_SCHEDULES_JSON_KEY, JSON.stringify(recentSchedules));\n                    if ((_c = this.scheduleLoadModal) === null || _c === void 0 ? void 0 : _c.isOpen())\n                        this.scheduleLoadModal.refreshRecentList();\n                }\n                else {\n                    console.log(\"Skipping save for empty or invalid schedule JSON.\");\n                }\n            }\n            catch (storageError) {\n                console.error(\"Error saving schedule JSON to localStorage:\", storageError);\n            }\n            this.currentSchedule.start();\n            this.toggleScheduleAccordion(true);\n        }\n    }\n    skipCurrentTask() {\n        var _a, _b;\n        if (!this.currentSchedule || this.currentSchedule.isFinished()) {\n            console.warn(\"Cannot skip: No active schedule or schedule finished.\");\n            return;\n        }\n        if (((_a = this.settingsModalEl) === null || _a === void 0 ? void 0 : _a.classList.contains(\"is-active\")) || ((_b = this.scheduleLoadModal) === null || _b === void 0 ? void 0 : _b.isOpen())) {\n            alert(\"Please close any open modals before skipping.\");\n            return;\n        }\n        this.currentSchedule.skip();\n        this.toggleScheduleAccordion(this.currentSchedule.isRunning());\n    }\n    /** Resets the schedule using the editor and current settings */\n    reset() {\n        var _a, _b, _c, _d, _e;\n        console.log(\"Resetting schedule using current editor state and settings...\");\n        (_a = this.currentSchedule) === null || _a === void 0 ? void 0 : _a.pause(); // Pause any existing schedule\n        (_c = (_b = this.scheduleEditor) === null || _b === void 0 ? void 0 : _b.errorDisplay) === null || _c === void 0 ? void 0 : _c.removeMessage(); // Clear previous errors\n        try {\n            const diagramContainer = document.getElementById(\"diagram\");\n            const maxCanvasHeight = (diagramContainer === null || diagramContainer === void 0 ? void 0 : diagramContainer.clientHeight) && diagramContainer.clientHeight > 50\n                ? diagramContainer.clientHeight\n                : DEFAULT_MAX_CANVAS_HEIGHT;\n            // getSchedule uses the builder which uses the registry\n            this.currentSchedule = this.scheduleEditor.getSchedule(this.displayController, this.settings, maxCanvasHeight);\n            if (this.currentSchedule && this.currentSchedule.intervals.length > 0) {\n                this.currentSchedule.prepare();\n                this.displayController.setStart();\n                this.displayController.setStatus(display_controller_1.Status.Pause);\n                console.log(\"Schedule reset and prepared.\");\n            }\n            else if (!this.scheduleEditor.errorDisplay.hasMessage()) {\n                console.warn(\"Reset resulted in an empty schedule.\");\n                this.displayController.setTask(\"Load/Create Schedule\", \"lightgrey\");\n                this.displayController.setTime(0);\n                this.displayController.setTotalTime(0, 0);\n                this.displayController.setUpcoming([], true);\n                this.displayController.setStatus(display_controller_1.Status.Stop);\n                this.displayController.setStart();\n                this.displayController.clearFeature();\n                this.currentSchedule = null;\n            }\n            else {\n                console.error(\"Schedule reset failed due to errors during build.\");\n                this.displayController.setTask(\"Error During Build\", \"red\");\n                this.displayController.setTime(0);\n                this.displayController.setTotalTime(0, 0);\n                this.displayController.setUpcoming([], true);\n                this.displayController.setStatus(display_controller_1.Status.Stop);\n                this.displayController.setStart();\n                this.displayController.clearFeature();\n                this.currentSchedule = null;\n            }\n        }\n        catch (error) {\n            console.error(\"Unexpected error during reset:\", error);\n            (_e = (_d = this.scheduleEditor) === null || _d === void 0 ? void 0 : _d.errorDisplay) === null || _e === void 0 ? void 0 : _e.showMessage(`Unexpected reset error: ${error}`);\n            this.displayController.setTask(\"Unexpected Error\", \"red\");\n            this.displayController.setTime(0);\n            this.displayController.setTotalTime(0, 0);\n            this.displayController.setUpcoming([], true);\n            this.displayController.setStatus(display_controller_1.Status.Stop);\n            this.displayController.setStart();\n            this.displayController.clearFeature();\n            this.currentSchedule = null;\n        }\n        // Collapse accordion when paused/reset\n        this.toggleScheduleAccordion(false);\n    }\n}\nexports.Main = Main;\n// --- App Initialization --- (Remains the same)\nfunction initializeApp() {\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", () => new Main());\n    }\n    else {\n        new Main();\n    }\n}\ninitializeApp();\n\n\n//# sourceURL=webpack:///./main.ts?");

/***/ }),

/***/ "./schedule/editor/clipboard_manager.ts":
/*!**********************************************!*\
  !*** ./schedule/editor/clipboard_manager.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClipboardManager = void 0;\n// Import registry functions for generic handling\nconst feature_registry_1 = __webpack_require__(/*! ../../feature_registry */ \"./feature_registry.ts\"); // Use getIntervalSettingsParser\n// Import the builder for interval rows\nconst interval_row_ui_1 = __webpack_require__(/*! ./interval/interval_row_ui */ \"./schedule/editor/interval/interval_row_ui.ts\");\n// --- Removed direct import of GuitarIntervalSettings ---\n// --- Removed FeatureCategoryName import ---\nclass ClipboardManager {\n    constructor(selectionManager, rowManager, onClipboardChangeCallback) {\n        this.clipboardData = [];\n        this.selectionManager = selectionManager;\n        this.rowManager = rowManager;\n        this.onClipboardChangeCallback = onClipboardChangeCallback;\n    }\n    /** Clears the internal clipboard data. */\n    clearClipboard() {\n        this.clipboardData = [];\n        console.log(\"Internal clipboard cleared.\");\n        this.onClipboardChangeCallback(this.hasCopiedData());\n    }\n    /** Copies the currently selected rows' data to the internal clipboard. */\n    copySelectedRows() {\n        const selectedRows = this.selectionManager.getSelectedElementsInDomOrder();\n        if (selectedRows.length === 0) {\n            console.log(\"Nothing selected to copy.\");\n            return;\n        }\n        // Use RowManager.getRowData which now includes categoryName string\n        this.clipboardData = selectedRows\n            .map((row) => this.rowManager.getRowData(row))\n            .filter((data) => data !== null);\n        console.log(`Copied ${this.clipboardData.length} rows to internal clipboard:`, JSON.stringify(this.clipboardData));\n        this.onClipboardChangeCallback(this.hasCopiedData());\n    }\n    /** Pastes rows from the internal clipboard after the last selected element. */\n    pasteRows() {\n        if (!this.hasCopiedData()) {\n            console.log(\"Clipboard is empty, nothing to paste.\");\n            return;\n        }\n        console.log(`Pasting ${this.clipboardData.length} rows...`);\n        const insertAfterElement = this.selectionManager.getLastSelectedElementInDomOrder();\n        let lastPastedElement = insertAfterElement;\n        this.clipboardData.forEach((rowDataJSON) => {\n            let newRowElement = null;\n            try {\n                if (rowDataJSON.rowType === \"group\") {\n                    // Pasting group data (no category needed)\n                    const groupUIData = Object.assign({}, rowDataJSON);\n                    newRowElement = this.rowManager.addGroupRow(groupUIData.level, groupUIData.name, lastPastedElement);\n                }\n                else if (rowDataJSON.rowType === \"interval\") {\n                    // Pasting interval data\n                    const intervalJsonData = rowDataJSON;\n                    const categoryName = intervalJsonData.categoryName; // Get category name string\n                    // Validate category exists\n                    if (!(0, feature_registry_1.getCategory)(categoryName)) {\n                        console.warn(`Cannot paste interval row: Category \"${categoryName}\" not registered. Skipping row.`);\n                        return; // Skip this row if category invalid\n                    }\n                    // --- Create Settings Instance using Parser ---\n                    let settingsInstance;\n                    const settingsParser = (0, feature_registry_1.getIntervalSettingsParser)(categoryName); // Get parser\n                    const settingsJsonData = intervalJsonData.intervalSettings;\n                    if (settingsParser) {\n                        try {\n                            settingsInstance = settingsParser(settingsJsonData); // Use parser\n                        }\n                        catch (parseError) {\n                            console.error(`Error parsing pasted interval settings for ${categoryName}. Using default.`, parseError);\n                            const factory = this.rowManager[\"getIntervalSettingsFactory\"](categoryName); // Access factory via RowManager or registry\n                            settingsInstance = factory ? factory() : { toJSON: () => ({}) }; // Fallback\n                        }\n                    }\n                    else {\n                        console.error(`Cannot paste settings: No parser for category ${categoryName}. Using basic object.`);\n                        settingsInstance = { toJSON: () => settingsJsonData || {} };\n                        if (settingsJsonData) {\n                            Object.assign(settingsInstance, settingsJsonData);\n                        }\n                    }\n                    // --- End Settings Instance Creation ---\n                    // Create the UI data structure expected by buildIntervalRowElement\n                    const intervalUIData = {\n                        rowType: \"interval\",\n                        duration: intervalJsonData.duration,\n                        task: intervalJsonData.task,\n                        categoryName: categoryName, // Use category name string\n                        featureTypeName: intervalJsonData.featureTypeName,\n                        featureArgsList: intervalJsonData.featureArgsList,\n                        intervalSettings: settingsInstance, // Use created instance\n                    };\n                    // Build the element, passing the category name string\n                    newRowElement = (0, interval_row_ui_1.buildIntervalRowElement)(intervalUIData, categoryName);\n                    this.rowManager.insertRowElement(newRowElement, lastPastedElement); // Insert it\n                }\n                if (newRowElement) {\n                    lastPastedElement = newRowElement; // Update insertion point\n                }\n            }\n            catch (error) {\n                console.error(\"Error pasting row:\", rowDataJSON, error);\n            }\n        });\n        this.selectionManager.clearSelection();\n        this.rowManager.updateAllRowIndentation();\n    }\n    /** Checks if there is data in the internal clipboard. */\n    hasCopiedData() {\n        return this.clipboardData.length > 0;\n    }\n}\nexports.ClipboardManager = ClipboardManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/clipboard_manager.ts?");

/***/ }),

/***/ "./schedule/editor/drag_drop_manager.ts":
/*!**********************************************!*\
  !*** ./schedule/editor/drag_drop_manager.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DragDropManager = void 0;\nclass DragDropManager {\n    constructor(containerEl, selectionManager, rowManager) {\n        this.draggedElements = [];\n        this.isMultiDrag = false;\n        this.containerEl = containerEl;\n        this.selectionManager = selectionManager;\n        this.rowManager = rowManager;\n        this._initialize();\n    }\n    _initialize() {\n        this.containerEl.addEventListener(\"dragstart\", this._handleDragStart.bind(this));\n        this.containerEl.addEventListener(\"dragend\", this._handleDragEnd.bind(this));\n        this.containerEl.addEventListener(\"dragover\", this._handleDragOver.bind(this));\n        this.containerEl.addEventListener(\"drop\", this._handleDrop.bind(this));\n        this.containerEl.addEventListener(\"dragleave\", this._handleDragLeave.bind(this));\n        console.log(\"DnD Manager Initialized.\");\n    }\n    _handleDragStart(e) {\n        const originalTarget = e.target;\n        // *** ADD DEBUG LOGGING HERE ***\n        console.log(\"[DEBUG] DragStart Event Target:\", originalTarget);\n        const dragHandle = originalTarget.closest('.drag-handle-cell');\n        console.log(\"[DEBUG] Found Drag Handle (.closest('.drag-handle-cell')):\", dragHandle);\n        // *** END DEBUG LOGGING ***\n        // Check if the drag started on the handle\n        if (!dragHandle) {\n            // Prevent the row drag operation if not started on handle\n            e.preventDefault();\n            console.log(\"DragStart prevented: Not initiated on drag handle.\"); // This is the log you're seeing\n            return;\n        }\n        // --- If drag started on handle, proceed ---\n        const rowToDrag = dragHandle.closest(\".schedule-row\");\n        if (!rowToDrag || !e.dataTransfer) {\n            e.preventDefault();\n            return;\n        }\n        // Check selection state\n        this.isMultiDrag = this.selectionManager.getSelectedElements().has(rowToDrag);\n        if (this.isMultiDrag) {\n            this.draggedElements = this.selectionManager.getSelectedElementsInDomOrder();\n            if (!this.draggedElements.includes(rowToDrag)) {\n                this.draggedElements.push(rowToDrag);\n            }\n            this.draggedElements.forEach((el) => el.classList.add(\"dragging-selected\"));\n            console.log(`Drag Start: Multi-drag initiated with ${this.draggedElements.length} elements.`);\n            e.dataTransfer.setData(\"application/x-schedule-multidrag\", \"true\");\n        }\n        else {\n            this.selectionManager.selectSingleRow(rowToDrag);\n            this.draggedElements = [rowToDrag];\n            rowToDrag.classList.add(\"dragging\");\n            console.log(\"Drag Start: Single element drag initiated via handle.\");\n        }\n        e.dataTransfer.effectAllowed = \"move\";\n        setTimeout(() => {\n            this.draggedElements.forEach((el) => (el.style.opacity = \"0.5\"));\n        }, 0);\n    }\n    _handleDragEnd(e) {\n        this.draggedElements.forEach((el) => {\n            el.classList.remove(\"dragging\", \"dragging-selected\");\n            el.style.opacity = \"\";\n        });\n        this._clearDragOverStyles();\n        this.draggedElements = [];\n        this.isMultiDrag = false;\n        console.log(\"Drag End.\");\n    }\n    _handleDragOver(e) {\n        e.preventDefault();\n        if (this.draggedElements.length === 0)\n            return;\n        if (e.dataTransfer)\n            e.dataTransfer.dropEffect = \"move\";\n        const afterElement = this._getDragAfterElement(e.clientY);\n        this._clearDragOverStyles();\n        this._applyDragOverStyle(afterElement);\n    }\n    _handleDrop(e) {\n        e.preventDefault();\n        this._clearDragOverStyles();\n        if (this.draggedElements.length === 0)\n            return;\n        const afterElement = this._getDragAfterElement(e.clientY);\n        console.log(`Drop: Moving ${this.draggedElements.length} elements ${afterElement ? \"before target\" : \"to the end\"}.`);\n        this.draggedElements.forEach((el) => {\n            let currentTarget = afterElement;\n            while (currentTarget && this.draggedElements.includes(currentTarget)) {\n                currentTarget = currentTarget.nextElementSibling;\n            }\n            if (currentTarget === null) {\n                this.containerEl.appendChild(el);\n            }\n            else {\n                this.containerEl.insertBefore(el, currentTarget);\n            }\n        });\n        this.rowManager.updateAllRowIndentation();\n    }\n    _handleDragLeave(e) {\n        if (!this.containerEl.contains(e.relatedTarget)) {\n            this._clearDragOverStyles();\n        }\n    }\n    _getDragAfterElement(y) {\n        const draggableElements = Array.from(this.containerEl.querySelectorAll(\".schedule-row:not(.dragging):not(.dragging-selected)\"));\n        return draggableElements.reduce((closest, child) => {\n            const box = child.getBoundingClientRect();\n            const offset = y - box.top - box.height / 2;\n            if (offset < 0 && offset > closest.offset) {\n                return { offset: offset, element: child };\n            }\n            else {\n                return closest;\n            }\n        }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;\n    }\n    _clearDragOverStyles() {\n        this.containerEl\n            .querySelectorAll(\".schedule-row\")\n            .forEach((el) => {\n            el.style.borderTop = \"\";\n            el.style.borderBottom = \"\";\n        });\n        this.containerEl.style.borderBottom = \"\";\n        this.containerEl.style.borderTop = \"\";\n    }\n    _applyDragOverStyle(afterElement) {\n        const borderStyle = \"3px dashed var(--clr-link)\";\n        if (afterElement) {\n            afterElement.style.borderTop = borderStyle;\n        }\n        else {\n            this.containerEl.style.borderBottom = borderStyle;\n        }\n    }\n}\nexports.DragDropManager = DragDropManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/drag_drop_manager.ts?");

/***/ }),

/***/ "./schedule/editor/editor_ui_manager.ts":
/*!**********************************************!*\
  !*** ./schedule/editor/editor_ui_manager.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// ts/schedule/editor/editor_ui_manager.ts\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorUIManager = void 0;\nclass EditorUIManager {\n    constructor(containerEl) {\n        if (!containerEl)\n            throw new Error(\"EditorUIManager: Container element is required.\");\n        this.containerEl = containerEl;\n        this._renderBaseHTML();\n    }\n    _renderBaseHTML() {\n        this.containerEl.innerHTML = \"\"; // Clear container\n        // --- Text Editor ---\n        // ... (text editor setup remains the same) ...\n        this.textEditorWrapperEl = document.createElement(\"div\");\n        this.textEditorWrapperEl.id = \"text-editor-wrapper\";\n        this.textEditorWrapperEl.style.padding = \"10px\";\n        this.textEditorWrapperEl.style.border = \"1px solid #ccc\";\n        this.textEditorWrapperEl.style.marginBottom = \"10px\";\n        this.textEl = document.createElement(\"textarea\");\n        this.textEl.id = \"schedule-text-editor\";\n        this.textEl.classList.add(\"textarea\");\n        this.textEl.rows = 15;\n        this.textEl.placeholder =\n            \"Enter schedule text here (e.g., 5:00, Warmup, Notes)\";\n        this.textEditorWrapperEl.appendChild(this.textEl);\n        this.containerEl.appendChild(this.textEditorWrapperEl);\n        // --- Config Editor ---\n        // ... (config editor setup remains the same) ...\n        this.configEditorWrapperEl = document.createElement(\"div\");\n        this.configEditorWrapperEl.id = \"config-editor-wrapper\";\n        this.containerEl.appendChild(this.configEditorWrapperEl);\n        this.configEntriesContainerEl = document.createElement(\"div\");\n        this.configEntriesContainerEl.id = \"config-entries-container\";\n        this.configEntriesContainerEl.setAttribute(\"tabindex\", \"-1\");\n        this.configEntriesContainerEl.style.outline = \"none\";\n        this.configEditorWrapperEl.appendChild(this.configEntriesContainerEl);\n        // --- Editor Controls ---\n        this.editorControlsContainerEl = document.createElement(\"div\");\n        this.editorControlsContainerEl.id = \"editor-controls\";\n        this.editorControlsContainerEl.style.display = \"flex\";\n        this.editorControlsContainerEl.style.flexWrap = \"wrap\"; // Allow buttons to wrap on smaller screens\n        this.editorControlsContainerEl.style.gap = \"10px\";\n        this.editorControlsContainerEl.style.marginTop = \"10px\";\n        this.containerEl.appendChild(this.editorControlsContainerEl);\n        // --- Create Buttons ---\n        this.modeToggleEl = this._createButton(\"mode-toggle\", \"Switch Mode\", // Text updated dynamically later\n        [\"is-outlined\"], \"Switch between Config and Text Editor\");\n        // *** Create the New Schedule button ***\n        this.newScheduleButtonEl = this._createButton(\"new-schedule\", \"<span>New</span>\", [\"is-outlined\", \"is-danger\"], // Use danger color for reset action\n        \"Clear editor and start a new schedule\");\n        this.addConfigEntryButtonEl = this._createButton(\"add-config-entry\", \"<span>+ Interval</span>\", [\"is-outlined\"], \"Add Interval\");\n        this.addGroupButtonEl = this._createButton(\"add-group-entry\", \"<span>+ Group</span>\", [\"is-outlined\"], \"Add Group Header\");\n        this.loadSaveButtonEl = this._createButton(\"load-schedule-button\", \"<span>Load/Save</span>\", [\"is-info\", \"is-outlined\"], \"Load/Save Schedules\");\n        this.copyButtonEl = this._createButton(\"copy-schedule-rows\", \"<span>Copy</span>\", [\"is-outlined\"], \"Copy Selected Rows (Ctrl+C)\");\n        this.pasteButtonEl = this._createButton(\"paste-schedule-rows\", \"<span>Paste</span>\", [\"is-outlined\"], \"Paste Copied Rows (Ctrl+V)\");\n        this.setScheduleButtonEl = this._createButton(\"set-schedule-control\", \"Set Schedule & Reset Timer\", [\"is-primary\"]);\n        this.setScheduleButtonEl.style.marginLeft = \"auto\"; // Pushes it to the right\n        // --- Append Buttons in Order ---\n        this.editorControlsContainerEl.append(this.modeToggleEl, this.newScheduleButtonEl, // <-- Add new button here\n        this.addConfigEntryButtonEl, this.addGroupButtonEl, this.loadSaveButtonEl, this.copyButtonEl, this.pasteButtonEl, \n        // Spacer div (optional, if marginLeft on Set button isn't enough)\n        // this._createSpacer(),\n        this.setScheduleButtonEl);\n        this.updateCopyPasteButtonState(false, false); // Initialize button states\n    }\n    // _createButton method remains the same\n    _createButton(id, innerHTML, bulmaClasses = [], title = \"\") {\n        const button = document.createElement(\"button\");\n        button.id = id;\n        button.classList.add(\"button\", \"is-small\", ...bulmaClasses);\n        button.innerHTML = innerHTML;\n        if (title)\n            button.title = title;\n        return button;\n    }\n    // setModeUI method remains the same\n    setModeUI(isTextMode) {\n        this.textEditorWrapperEl.style.display = isTextMode ? \"block\" : \"none\";\n        this.configEditorWrapperEl.style.display = isTextMode ? \"none\" : \"block\";\n        this.modeToggleEl.textContent = isTextMode\n            ? \"Switch to Config Editor\"\n            : \"Switch to Text Editor\";\n        // Also toggle visibility of config-only buttons\n        this.newScheduleButtonEl.style.display = isTextMode\n            ? \"none\"\n            : \"inline-block\";\n        this.addConfigEntryButtonEl.style.display = isTextMode\n            ? \"none\"\n            : \"inline-block\";\n        this.addGroupButtonEl.style.display = isTextMode ? \"none\" : \"inline-block\";\n        this.copyButtonEl.style.display = isTextMode ? \"none\" : \"inline-block\";\n        this.pasteButtonEl.style.display = isTextMode ? \"none\" : \"inline-block\";\n    }\n    // updateCopyPasteButtonState remains the same\n    updateCopyPasteButtonState(canCopy, canPaste) {\n        this.copyButtonEl.toggleAttribute(\"disabled\", !canCopy);\n        this.pasteButtonEl.toggleAttribute(\"disabled\", !canPaste);\n    }\n    // populateConfigUI remains the same\n    populateConfigUI(buildRowCallback, rowDataArray) {\n        // ... (implementation unchanged) ...\n        while (this.configEntriesContainerEl.firstChild) {\n            this.configEntriesContainerEl.removeChild(this.configEntriesContainerEl.firstChild);\n        }\n        rowDataArray.forEach((rowData) => {\n            const rowElement = buildRowCallback(rowData);\n            if (rowElement) {\n                this.configEntriesContainerEl.appendChild(rowElement);\n            }\n        });\n    }\n}\nexports.EditorUIManager = EditorUIManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/editor_ui_manager.ts?");

/***/ }),

/***/ "./schedule/editor/error_display.ts":
/*!******************************************!*\
  !*** ./schedule/editor/error_display.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorDisplay = void 0;\nclass ErrorDisplay {\n    constructor(containerEl, controlsContainerEl) {\n        this.messageElement = null; // Keep track of the message element\n        this.containerEl = containerEl;\n        this.controlsContainerEl = controlsContainerEl;\n    }\n    showMessage(message, type = \"error\") {\n        this.removeMessage(); // Remove any existing message first\n        const butterbar = document.createElement(\"div\");\n        butterbar.textContent = message;\n        butterbar.classList.add(\"butterbar-message\", `is-${type}`); // Use this class to check existence\n        butterbar.style.padding = \"8px 15px\";\n        butterbar.style.marginBottom = \"10px\";\n        butterbar.style.borderRadius = \"4px\";\n        butterbar.style.border = \"1px solid transparent\";\n        butterbar.style.fontWeight = \"bold\";\n        // Basic styling based on type (can be moved to CSS)\n        switch (type) {\n            case \"error\":\n                butterbar.style.backgroundColor = \"#fdecea\";\n                butterbar.style.borderColor = \"#f14668\";\n                butterbar.style.color = \"#cc0f35\";\n                break;\n            case \"warning\":\n                butterbar.style.backgroundColor = \"#fffbeb\";\n                butterbar.style.borderColor = \"#ffdd57\";\n                butterbar.style.color = \"#947600\";\n                break;\n            case \"info\":\n                butterbar.style.backgroundColor = \"#eff5fb\";\n                butterbar.style.borderColor = \"#3e8ed0\";\n                butterbar.style.color = \"#296fa8\";\n                break;\n        }\n        this.messageElement = butterbar; // Store reference\n        if (this.controlsContainerEl && this.containerEl) {\n            // Insert the message before the controls container\n            this.containerEl.insertBefore(this.messageElement, this.controlsContainerEl);\n        }\n        else if (this.containerEl) {\n            // Fallback: append to the main container if controls aren't found\n            this.containerEl.appendChild(this.messageElement);\n            console.warn(\"ErrorDisplay: Controls container not found, appending message to end.\");\n        }\n        else {\n            console.error(\"ErrorDisplay: Cannot find container to add message:\", message);\n            this.messageElement = null; // Failed to add\n        }\n    }\n    removeMessage() {\n        if (this.messageElement && this.messageElement.parentNode) {\n            this.messageElement.parentNode.removeChild(this.messageElement);\n        }\n        this.messageElement = null; // Clear reference\n    }\n    /**\n     * Checks if an error/warning/info message is currently displayed.\n     * @returns {boolean} True if a message is visible, false otherwise.\n     */\n    hasMessage() {\n        // Check if we have a stored reference and if it's still in the DOM\n        return !!(this.messageElement && this.messageElement.parentNode);\n        // Alternative: Query the DOM directly each time\n        // return !!this.containerEl?.querySelector(\".butterbar-message\");\n    }\n}\nexports.ErrorDisplay = ErrorDisplay;\n\n\n//# sourceURL=webpack:///./schedule/editor/error_display.ts?");

/***/ }),

/***/ "./schedule/editor/interval/common_ui_elements.ts":
/*!********************************************************!*\
  !*** ./schedule/editor/interval/common_ui_elements.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createCell = createCell;\nexports.createCellWithInput = createCellWithInput;\nexports.createTextInput = createTextInput;\nexports.createNumberInput = createNumberInput;\nexports.createDropdownInput = createDropdownInput;\nexports.createToggleButtonInput = createToggleButtonInput;\nexports.createEllipsisDropdown = createEllipsisDropdown;\nexports.populateEllipsisDropdownContent = populateEllipsisDropdownContent;\nexports.createVariadicInputElement = createVariadicInputElement;\nexports.createDragHandleCell = createDragHandleCell;\nexports.createCopyButtonCell = createCopyButtonCell;\nexports.createRemoveButtonElement = createRemoveButtonElement;\nexports.applyIndentation = applyIndentation;\nexports.clearAllChildren = clearAllChildren;\n// --- Generic UI Element Creation Functions ---\nfunction createCell(...classes) {\n    const div = document.createElement(\"div\");\n    div.classList.add(\"config-cell\", ...classes);\n    return div;\n}\nfunction createCellWithInput(type, value, placeholder, inputClasses) {\n    const cellDiv = createCell(...inputClasses.map((c) => c.replace(\"config-\", \"\") + \"-cell\"));\n    const input = document.createElement(\"input\");\n    input.type = type;\n    input.placeholder = placeholder;\n    input.value = value;\n    input.classList.add(\"input\", \"is-small\", ...inputClasses);\n    cellDiv.appendChild(input);\n    return cellDiv;\n}\nfunction createTextInput(name, value, placeholder) {\n    const input = document.createElement(\"input\");\n    input.type = \"text\";\n    input.classList.add(\"input\", \"is-small\", \"config-feature-arg\");\n    input.placeholder = placeholder || name;\n    input.value = value !== null && value !== void 0 ? value : \"\";\n    input.name = name; // Set name attribute for potential form use or identification\n    return input;\n}\nfunction createNumberInput(name, value, placeholder) {\n    const input = document.createElement(\"input\");\n    input.type = \"number\";\n    input.classList.add(\"input\", \"is-small\", \"config-feature-arg\");\n    input.placeholder = placeholder || name;\n    input.value = value !== null && value !== void 0 ? value : \"\";\n    input.name = name; // Set name attribute\n    return input;\n}\nfunction createDropdownInput(name, options, selectedValue) {\n    const wrapper = document.createElement(\"div\");\n    wrapper.classList.add(\"select\", \"is-small\", \"is-fullwidth\");\n    const select = document.createElement(\"select\");\n    select.classList.add(\"config-feature-arg\"); // Keep class for potential selection\n    select.name = name; // Set name attribute\n    options.forEach((optionValue) => {\n        const option = new Option(optionValue, optionValue);\n        if (optionValue === selectedValue)\n            option.selected = true;\n        select.appendChild(option);\n    });\n    wrapper.appendChild(select);\n    return wrapper;\n}\n/** Creates the toggle button UI for selecting multiple discrete options */\nfunction createToggleButtonInput(container, arg, initialSelection // Array of initially selected values\n) {\n    var _a;\n    container.style.display = \"flex\";\n    container.style.flexWrap = \"wrap\";\n    container.style.gap = \"5px\";\n    container.style.width = \"100%\"; // Ensure container takes width\n    const selectionSet = new Set(initialSelection); // Efficient lookup\n    // Get labels from uiComponentData, default to empty array\n    const buttonLabels = ((_a = arg.uiComponentData) === null || _a === void 0 ? void 0 : _a.buttonLabels) || [];\n    if (buttonLabels.length === 0) {\n        console.warn(`ToggleButtonInput: No buttonLabels provided for arg \"${arg.name}\".`);\n        container.textContent = \"[No options configured]\";\n        return;\n    }\n    buttonLabels.forEach((label) => {\n        const button = document.createElement(\"button\");\n        button.type = \"button\"; // Important for forms\n        button.classList.add(\"button\", \"is-small\", \"is-outlined\", \"numeral-toggle-btn\");\n        button.textContent = label;\n        button.dataset.value = label; // Store the value associated with the button\n        button.title = `Toggle ${label}`; // Accessibility\n        // Set initial active state\n        if (selectionSet.has(label)) {\n            button.classList.add(\"is-active\", \"is-info\");\n        }\n        // Toggle logic\n        button.onclick = () => {\n            button.classList.toggle(\"is-active\");\n            button.classList.toggle(\"is-info\");\n            // Optional: Trigger a change event on the container or a hidden input\n            // if needed for external data binding or validation frameworks.\n        };\n        container.appendChild(button);\n    });\n}\n/** Creates the ellipsis dropdown UI for nested settings */\nfunction createEllipsisDropdown(arg, \n// Expect the generic IntervalSettings instance\ncurrentSettingsInstance) {\n    if (!arg.nestedSchema) {\n        console.warn(`EllipsisDropdown: No nestedSchema provided for arg \"${arg.name}\".`);\n        const p = document.createElement(\"span\");\n        p.textContent = \"[No nested settings]\";\n        p.classList.add(\"has-text-grey-light\", \"is-italic\", \"is-size-7\");\n        return p;\n    }\n    const dropdownDiv = document.createElement(\"div\");\n    dropdownDiv.classList.add(\"dropdown\", \"config-ellipsis-dropdown\");\n    const triggerDiv = document.createElement(\"div\");\n    triggerDiv.classList.add(\"dropdown-trigger\");\n    const button = document.createElement(\"button\");\n    button.type = \"button\";\n    button.classList.add(\"button\", \"is-small\", \"is-outlined\", \"config-ellipsis-button\");\n    button.setAttribute(\"aria-haspopup\", \"true\");\n    const uniqueId = `dropdown-menu-${arg.name.replace(/\\s+/g, \"-\")}-${Math.random().toString(36).substring(2, 7)}`;\n    button.setAttribute(\"aria-controls\", uniqueId);\n    button.innerHTML = \"<span>...</span>\";\n    button.title = arg.description || \"Advanced Settings\";\n    triggerDiv.appendChild(button);\n    dropdownDiv.appendChild(triggerDiv);\n    const menuDiv = document.createElement(\"div\");\n    menuDiv.classList.add(\"dropdown-menu\");\n    menuDiv.id = uniqueId;\n    menuDiv.setAttribute(\"role\", \"menu\");\n    dropdownDiv.appendChild(menuDiv);\n    const contentDiv = document.createElement(\"div\");\n    contentDiv.classList.add(\"dropdown-content\");\n    contentDiv.style.padding = \"10px\";\n    contentDiv.style.minWidth = \"200px\";\n    menuDiv.appendChild(contentDiv);\n    // --- Dropdown Toggle Logic ---\n    const toggleDropdown = (event) => {\n        event === null || event === void 0 ? void 0 : event.stopPropagation();\n        const isActive = dropdownDiv.classList.toggle(\"is-active\");\n        if (isActive) {\n            // Populate content only when opening, pass the generic settings instance\n            populateEllipsisDropdownContent(contentDiv, arg.nestedSchema, currentSettingsInstance); // Pass generic instance\n            document.addEventListener(\"click\", handleClickOutside, true);\n        }\n        else {\n            document.removeEventListener(\"click\", handleClickOutside, true);\n        }\n    };\n    const handleClickOutside = (event) => {\n        if (!dropdownDiv.contains(event.target)) {\n            dropdownDiv.classList.remove(\"is-active\");\n            document.removeEventListener(\"click\", handleClickOutside, true);\n        }\n    };\n    button.addEventListener(\"click\", toggleDropdown);\n    // --- End Dropdown Logic ---\n    return dropdownDiv;\n}\n/** Populates the content of an ellipsis dropdown based on nested schema */\nfunction populateEllipsisDropdownContent(contentContainer, nestedSchema, \n// Expect the generic IntervalSettings instance\nsettingsInstance) {\n    contentContainer.innerHTML = \"\"; // Clear previous content\n    nestedSchema.forEach((nestedArg) => {\n        const fieldDiv = document.createElement(\"div\");\n        fieldDiv.classList.add(\"field\");\n        const label = document.createElement(\"label\");\n        label.classList.add(\"label\", \"is-small\");\n        label.textContent = nestedArg.name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim();\n        label.title = nestedArg.description || \"\";\n        fieldDiv.appendChild(label);\n        const controlDiv = document.createElement(\"div\");\n        controlDiv.classList.add(\"control\");\n        // Access properties using index signature on the generic type.\n        const currentValue = settingsInstance[nestedArg.name];\n        const currentValueStr = (currentValue !== undefined && currentValue !== null) ? String(currentValue) : \"\";\n        let inputElement = null;\n        // Create appropriate input based on nested schema type\n        // This logic is already generic\n        if (nestedArg.enum) {\n            inputElement = createDropdownInput(nestedArg.name, nestedArg.enum, currentValueStr);\n        }\n        else if (nestedArg.type === \"number\") {\n            inputElement = createNumberInput(nestedArg.name, currentValueStr, nestedArg.description);\n        }\n        else if (nestedArg.type === \"boolean\") {\n            inputElement = createDropdownInput(nestedArg.name, [\"true\", \"false\"], currentValueStr || \"false\");\n        }\n        else { // Default to string/text input\n            inputElement = createTextInput(nestedArg.name, currentValueStr, nestedArg.description);\n        }\n        if (inputElement) {\n            const inputField = (inputElement.tagName === \"DIV\") ? inputElement.querySelector(\"select, input\") : inputElement;\n            if (inputField) {\n                // Add event listener to update the settings INSTANCE directly on change\n                inputField.addEventListener(\"change\", (e) => {\n                    const target = e.target;\n                    let newValue = target.value;\n                    // Convert value type based on schema\n                    if (nestedArg.type === \"number\") {\n                        newValue = parseInt(target.value, 10);\n                        if (isNaN(newValue))\n                            newValue = 0;\n                    }\n                    else if (nestedArg.type === \"boolean\") {\n                        newValue = target.value === \"true\";\n                    }\n                    // Update the INSTANCE directly using the nestedArg name as key\n                    settingsInstance[nestedArg.name] = newValue;\n                    console.log(`Updated setting '${nestedArg.name}' to:`, newValue, settingsInstance); // Log generic instance\n                });\n            }\n            controlDiv.appendChild(inputElement);\n        }\n        fieldDiv.appendChild(controlDiv);\n        contentContainer.appendChild(fieldDiv);\n    });\n}\n/** Creates a variadic input element wrapper allowing adding/removing inputs. */\nfunction createVariadicInputElement(arg, container, currentValues) {\n    // Container for the vertical group of inputs\n    const variadicGroupContainer = document.createElement(\"div\");\n    variadicGroupContainer.classList.add(\"variadic-group-container\");\n    variadicGroupContainer.style.display = \"flex\";\n    variadicGroupContainer.style.flexDirection = \"column\";\n    variadicGroupContainer.style.gap = \"3px\"; // Space between input rows\n    variadicGroupContainer.style.width = \"100%\"; // Take available width\n    /** --- Inner function to add a single input row --- */\n    const addInputRow = (value) => {\n        const inputWrapper = document.createElement(\"div\");\n        inputWrapper.classList.add(\"variadic-input-wrapper\"); // Used for styling/grouping\n        inputWrapper.style.display = \"flex\";\n        inputWrapper.style.alignItems = \"center\";\n        inputWrapper.style.gap = \"5px\";\n        let inputElement = null;\n        // Create appropriate input based on schema (handles enum within variadic now)\n        if (arg.enum) {\n            inputElement = createDropdownInput(arg.name, arg.enum, value);\n        }\n        else if (arg.type === \"number\") {\n            inputElement = createNumberInput(arg.name, value);\n        }\n        else { // Default to text\n            inputElement = createTextInput(arg.name, value, arg.example);\n        }\n        if (inputElement) {\n            inputElement.style.flexGrow = \"1\"; // Allow input/select to take space\n            // Adjust width for select wrapper to accommodate button\n            if (inputElement.tagName === 'DIV' && inputElement.classList.contains('select')) {\n                inputElement.style.width = 'calc(100% - 35px)'; // Heuristic width adjustment\n            }\n            inputWrapper.appendChild(inputElement);\n            // --- Add \"[-]\" Remove Button ---\n            const removeButton = document.createElement(\"button\");\n            removeButton.type = \"button\";\n            removeButton.classList.add(\"button\", \"is-small\", \"is-danger\", \"is-outlined\", \"remove-variadic-arg-btn\");\n            removeButton.innerHTML = \"&minus;\"; // Use minus symbol (or icon font)\n            removeButton.title = `Remove ${arg.name}`;\n            removeButton.style.flexShrink = \"0\"; // Prevent button from shrinking\n            removeButton.onclick = () => {\n                inputWrapper.remove();\n                // Optional: Disable remove button if only one input remains?\n            };\n            inputWrapper.appendChild(removeButton);\n            variadicGroupContainer.appendChild(inputWrapper); // Add the row to the container\n        }\n    };\n    /** --- End inner function --- */\n    // Add initial input rows based on currentValues\n    if (currentValues && currentValues.length > 0) {\n        currentValues.forEach(val => addInputRow(val));\n    }\n    else {\n        addInputRow(); // Add at least one empty input row initially\n    }\n    container.appendChild(variadicGroupContainer); // Add the group of inputs\n    // --- Add \"[+]\" Add More Button ---\n    const addButton = document.createElement(\"button\");\n    addButton.type = \"button\";\n    addButton.classList.add(\"button\", \"is-small\", \"is-outlined\", \"is-info\", \"add-variadic-btn\"); // Use distinct class\n    let buttonTextName = arg.name;\n    // Simple heuristic to singularize for button text\n    if (buttonTextName.endsWith('es')) {\n        buttonTextName = buttonTextName.slice(0, -2);\n    }\n    else if (buttonTextName.endsWith('s') && buttonTextName.length > 1) { // Avoid making 's' an empty string\n        buttonTextName = buttonTextName.slice(0, -1);\n    }\n    addButton.textContent = `+ ${buttonTextName}`; // Use potentially singularized name\n    addButton.title = `Add another ${arg.name}`;\n    addButton.style.marginTop = \"5px\";\n    addButton.style.alignSelf = 'flex-start'; // Align button left\n    addButton.onclick = () => {\n        addInputRow(); // Add a new empty input row to the group\n    };\n    container.appendChild(addButton); // Add below the group of inputs\n}\nfunction createDragHandleCell() {\n    const cellDiv = createCell(\"drag-handle-cell\");\n    cellDiv.draggable = true; // Make the handle draggable\n    cellDiv.style.cursor = \"grab\";\n    cellDiv.style.padding = \"0 5px\"; // Adjust padding as needed\n    cellDiv.innerHTML = \"&#x2630;\"; // Hamburger icon\n    cellDiv.title = \"Drag to reorder\";\n    // Style to vertically center the icon\n    cellDiv.style.display = \"flex\";\n    cellDiv.style.alignItems = \"center\";\n    cellDiv.style.justifyContent = \"center\";\n    cellDiv.style.color = \"var(--clr-text-subtle)\"; // Use subtle color\n    return cellDiv;\n}\nfunction createCopyButtonCell() {\n    const copyButton = document.createElement(\"button\");\n    copyButton.type = \"button\";\n    copyButton.classList.add(\"button\", \"is-small\", \"is-info\", // Or another suitable color\n    \"is-outlined\", \"copy-row-btn\" // Specific class for targeting\n    );\n    // Use a copy icon (e.g., Unicode or an icon font)\n    copyButton.innerHTML = \"&#x2398;\"; // Example: Document icon (can change)\n    copyButton.title = \"Copy Row\";\n    return copyButton;\n}\nfunction createRemoveButtonElement(rowElement) {\n    const removeButton = document.createElement(\"button\");\n    removeButton.type = \"button\";\n    removeButton.classList.add(\"button\", \"is-small\", \"is-danger\", \"is-outlined\", \"remove-row-btn\" // Specific class\n    );\n    removeButton.innerHTML = \"&#10005;\"; // Cross symbol (or icon font)\n    removeButton.title = \"Remove Row\";\n    removeButton.onclick = (e) => {\n        e.stopPropagation(); // Prevent row selection when clicking button\n        rowElement.remove();\n        // Optionally, dispatch a custom event to notify RowManager or Editor about the deletion\n        // rowElement.dispatchEvent(new CustomEvent('row-removed', { bubbles: true }));\n    };\n    return removeButton;\n}\n/** Applies indentation style based on level */\nfunction applyIndentation(element, level) {\n    const indentSize = 15; // Pixels per level\n    // Group levels start at 1, but visual indent starts from level 0 (no indent)\n    // Indent level 1 group like a level 0 item, level 2 like level 1 item, etc.\n    // Interval rows under a level N group get indent level N.\n    const effectiveLevel = Math.max(0, level); // Ensure non-negative level\n    element.style.marginLeft = `${effectiveLevel * indentSize}px`;\n    // Maybe add padding instead of margin if it interacts better with borders/backgrounds\n    // element.style.paddingLeft = `${effectiveLevel * indentSize}px`;\n}\n/** Clears all child elements from a given HTML element */\nfunction clearAllChildren(element) {\n    while (element.firstChild) {\n        element.removeChild(element.firstChild);\n    }\n}\n\n\n//# sourceURL=webpack:///./schedule/editor/interval/common_ui_elements.ts?");

/***/ }),

/***/ "./schedule/editor/interval/group_row_ui.ts":
/*!**************************************************!*\
  !*** ./schedule/editor/interval/group_row_ui.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildGroupRowElement = buildGroupRowElement;\nconst common_ui_elements_1 = __webpack_require__(/*! ./common_ui_elements */ \"./schedule/editor/interval/common_ui_elements.ts\");\n/**\n * Builds and returns the HTMLElement for a group header row.\n */\nfunction buildGroupRowElement(initialData) {\n    const groupDiv = document.createElement(\"div\");\n    groupDiv.classList.add(\"group-row\", \"schedule-row\");\n    groupDiv.dataset.rowType = \"group\";\n    groupDiv.dataset.level = String(initialData.level); // Store level for indentation logic\n    groupDiv.draggable = false; // Draggable is false on the row itself\n    // Basic Styling\n    groupDiv.style.display = \"flex\";\n    groupDiv.style.alignItems = \"center\";\n    groupDiv.style.padding = \"5px 8px\"; // Padding inside the group row\n    groupDiv.style.backgroundColor = \"var(--clr-tertiary-light)\"; // Use CSS variable\n    groupDiv.style.marginBottom = \"2px\"; // Small gap below group row\n    groupDiv.style.border = \"1px solid var(--clr-border-light)\"; // Use CSS variable\n    groupDiv.style.borderRadius = \"4px\";\n    groupDiv.style.gap = \"5px\"; // Gap between elements (handle, input, actions)\n    // Drag Handle\n    const handleDiv = (0, common_ui_elements_1.createDragHandleCell)();\n    groupDiv.appendChild(handleDiv);\n    // Group Name Input\n    const nameInput = document.createElement(\"input\");\n    nameInput.type = \"text\";\n    nameInput.value = initialData.name;\n    nameInput.placeholder = `Group Name (Level ${initialData.level})`;\n    nameInput.classList.add(\"input\", \"is-small\", \"group-name-input\"); // Specific class for identification\n    nameInput.style.flexGrow = \"1\"; // Allow input to take remaining space\n    // Make input look less like a standard input field\n    nameInput.style.border = \"none\";\n    nameInput.style.boxShadow = \"none\";\n    nameInput.style.backgroundColor = \"transparent\";\n    nameInput.style.fontWeight = \"bold\"; // Make group name stand out\n    groupDiv.appendChild(nameInput);\n    // Actions Cell (Copy, Remove)\n    const actionsDiv = document.createElement(\"div\");\n    actionsDiv.classList.add(\"config-cell\", \"action-cell\"); // Reuse action-cell class potentially\n    actionsDiv.style.display = \"flex\";\n    actionsDiv.style.alignItems = \"center\";\n    actionsDiv.style.gap = \"3px\"; // Gap between buttons\n    const copyButton = (0, common_ui_elements_1.createCopyButtonCell)(); // Reuse copy button\n    actionsDiv.appendChild(copyButton);\n    const removeButton = (0, common_ui_elements_1.createRemoveButtonElement)(groupDiv); // Reuse remove button\n    removeButton.title = \"Remove Group\"; // Specific title\n    actionsDiv.appendChild(removeButton);\n    groupDiv.appendChild(actionsDiv); // Append actions to the group row\n    // Apply initial indentation based on the group's level\n    // Note: applyIndentation now indents based on the *parent* group level visually.\n    // A level 1 group gets indent 0, level 2 gets indent 1, etc. This might need adjustment\n    // if nested groups are implemented later, but follows current logic.\n    (0, common_ui_elements_1.applyIndentation)(groupDiv, initialData.level);\n    return groupDiv;\n}\n\n\n//# sourceURL=webpack:///./schedule/editor/interval/group_row_ui.ts?");

/***/ }),

/***/ "./schedule/editor/interval/interval_row_ui.ts":
/*!*****************************************************!*\
  !*** ./schedule/editor/interval/interval_row_ui.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildIntervalRowElement = buildIntervalRowElement;\nconst feature_registry_1 = __webpack_require__(/*! ../../../feature_registry */ \"./feature_registry.ts\");\n// Import UI helpers\nconst common_ui_elements_1 = __webpack_require__(/*! ./common_ui_elements */ \"./schedule/editor/interval/common_ui_elements.ts\");\n/**\n * Builds and returns the HTMLElement for a single interval configuration row.\n * Expects initialData.intervalSettings to be an instance implementing IntervalSettings.\n * Requires the categoryName (string) to determine available features and settings.\n */\nfunction buildIntervalRowElement(initialData, categoryName // **** CHANGED: Expect string name ****\n) {\n    const entryDiv = document.createElement(\"div\");\n    entryDiv.classList.add(\"config-entry-row\", \"schedule-row\");\n    entryDiv.dataset.rowType = \"interval\";\n    entryDiv.dataset.categoryName = categoryName; // **** Store category name ****\n    entryDiv.draggable = false; // Dragging starts from handle\n    // --- Get or Create IntervalSettings Instance ---\n    let settingsInstance;\n    if (initialData.intervalSettings &&\n        typeof initialData.intervalSettings.toJSON === \"function\") {\n        settingsInstance = initialData.intervalSettings;\n    }\n    else {\n        const settingsFactory = (0, feature_registry_1.getIntervalSettingsFactory)(categoryName); // Use name string\n        if (settingsFactory) {\n            console.log(`Creating default interval settings using factory for category: ${categoryName}`);\n            settingsInstance = settingsFactory();\n        }\n        else {\n            console.error(`No IntervalSettings factory registered for category: ${categoryName}. Using plain object fallback.`);\n            // Provide a minimal fallback that adheres to the interface\n            settingsInstance = { toJSON: () => ({}) };\n        }\n    }\n    // Store the resolved instance on the element\n    entryDiv._intervalSettings = settingsInstance;\n    // --- Create Row Structure and Cells ---\n    entryDiv.style.display = \"flex\";\n    entryDiv.style.alignItems = \"center\";\n    entryDiv.style.gap = \"5px\";\n    entryDiv.style.padding = \"2px 0\";\n    entryDiv.style.position = \"relative\";\n    const handleDiv = (0, common_ui_elements_1.createDragHandleCell)();\n    entryDiv.appendChild(handleDiv);\n    const contentWrapper = document.createElement(\"div\");\n    contentWrapper.style.display = \"grid\";\n    contentWrapper.style.flexGrow = \"1\";\n    // Adjusted grid for better layout flexibility\n    contentWrapper.style.gridTemplateColumns = \"80px 1fr 1fr minmax(200px, 2fr)\";\n    contentWrapper.style.gap = \"5px\";\n    contentWrapper.style.alignItems = \"center\";\n    const durationDiv = (0, common_ui_elements_1.createCellWithInput)(\"text\", initialData.duration, \"Time\", [\"config-duration\"]);\n    const taskDiv = (0, common_ui_elements_1.createCellWithInput)(\"text\", initialData.task, \"Task Name\", [\n        \"config-task\",\n    ]);\n    // Pass category name string to dropdown builder\n    const featureTypeDiv = createFeatureTypeDropdownCell(initialData.featureTypeName, categoryName);\n    const featureArgsDiv = (0, common_ui_elements_1.createCell)(\"feature-args-cell\", \"config-feature-args-container\");\n    featureArgsDiv.style.alignSelf = \"start\"; // Align args container top\n    contentWrapper.appendChild(durationDiv);\n    contentWrapper.appendChild(taskDiv);\n    contentWrapper.appendChild(featureTypeDiv);\n    contentWrapper.appendChild(featureArgsDiv);\n    entryDiv.appendChild(contentWrapper);\n    // Actions Cell\n    const actionsDiv = document.createElement(\"div\");\n    actionsDiv.classList.add(\"config-cell\", \"action-cell\");\n    actionsDiv.style.display = \"flex\";\n    actionsDiv.style.alignItems = \"center\";\n    actionsDiv.style.gap = \"3px\";\n    actionsDiv.appendChild((0, common_ui_elements_1.createCopyButtonCell)());\n    actionsDiv.appendChild((0, common_ui_elements_1.createRemoveButtonElement)(entryDiv));\n    entryDiv.appendChild(actionsDiv);\n    // --- Event Listener & Initial Population ---\n    const featureTypeSelect = featureTypeDiv.querySelector(\"select\");\n    featureTypeSelect.addEventListener(\"change\", () => {\n        // Pass category name string and settings instance\n        updateArgsSection(featureTypeSelect, featureArgsDiv, settingsInstance, categoryName, // Pass name string\n        [] // Clear initial args on type change\n        );\n    });\n    // Initial Population: Pass category name string, settings instance, and initial args\n    updateArgsSection(featureTypeSelect, featureArgsDiv, settingsInstance, categoryName, // Pass name string\n    initialData.featureArgsList // Use the list from the loaded data\n    );\n    (0, common_ui_elements_1.applyIndentation)(entryDiv, 0); // Apply initial indentation\n    return entryDiv;\n}\n/** Creates the specific feature type dropdown cell for a given category name */\nfunction createFeatureTypeDropdownCell(selectedTypeName, categoryName // **** CHANGED: Expect string name ****\n) {\n    var _a;\n    const cellDiv = (0, common_ui_elements_1.createCell)(\"feature-type-cell\");\n    const selectWrapper = document.createElement(\"div\");\n    selectWrapper.classList.add(\"select\", \"is-small\", \"is-fullwidth\");\n    const select = document.createElement(\"select\");\n    select.classList.add(\"config-feature-type\");\n    select.appendChild(new Option(\"None\", \"\"));\n    // Populate with available feature types for the SPECIFIED category name\n    const availableTypes = (0, feature_registry_1.getAvailableFeatureTypes)(categoryName); // Use name string\n    const category = (0, feature_registry_1.getCategory)(categoryName); // Get category for display name fallback\n    if (availableTypes.length === 0) {\n        console.warn(`No feature types found registered for category: ${categoryName}`);\n        select.disabled = true;\n        select.appendChild(new Option(`No ${(_a = category === null || category === void 0 ? void 0 : category.getDisplayName()) !== null && _a !== void 0 ? _a : categoryName} features`, \"\"));\n    }\n    else {\n        availableTypes.forEach((featureType) => {\n            const option = new Option(featureType.displayName, featureType.typeName);\n            if (featureType.typeName === selectedTypeName) {\n                option.selected = true;\n            }\n            select.appendChild(option);\n        });\n    }\n    selectWrapper.appendChild(select);\n    cellDiv.appendChild(selectWrapper);\n    return cellDiv;\n}\n/** Updates the content of the feature arguments container based on selected feature */\nfunction updateArgsSection(featureTypeSelect, argsContainer, currentSettingsInstance, // Expect generic instance\ncategoryName, // **** CHANGED: Expect string name ****\ninitialArgs // **** Expect the loaded featureArgsList here ****\n) {\n    const selectedTypeName = featureTypeSelect.value;\n    argsContainer.innerHTML = \"\"; // Clear previous content\n    if (selectedTypeName) {\n        // Use the category name string to get the descriptor\n        const descriptor = (0, feature_registry_1.getFeatureTypeDescriptor)(categoryName, selectedTypeName); // Use name string\n        if (descriptor) {\n            const schema = descriptor.getConfigurationSchema();\n            if (typeof schema === \"object\" &&\n                \"args\" in schema &&\n                Array.isArray(schema.args)) {\n                // Pass the loaded initialArgs to populateArgsFromSchema\n                populateArgsFromSchema(argsContainer, schema.args, initialArgs || [], // Pass the loaded arguments here\n                currentSettingsInstance);\n            }\n            else if (typeof schema === \"string\") {\n                // Handle schema as a simple description string\n                const infoSpan = document.createElement(\"span\");\n                infoSpan.classList.add(\"has-text-grey-light\", \"is-italic\", \"is-size-7\");\n                infoSpan.textContent = schema;\n                argsContainer.appendChild(infoSpan);\n            }\n            else {\n                // Handle case with no configurable arguments (or unexpected schema type)\n                const infoSpan = document.createElement(\"span\");\n                infoSpan.classList.add(\"has-text-grey-light\", \"is-italic\", \"is-size-7\");\n                infoSpan.textContent = \"No configurable arguments\";\n                argsContainer.appendChild(infoSpan);\n            }\n        }\n        else {\n            console.error(`Error: Feature descriptor for \"${selectedTypeName}\" in category \"${categoryName}\" not found.`);\n            const errorSpan = document.createElement(\"span\");\n            errorSpan.classList.add(\"has-text-danger\", \"is-size-7\");\n            errorSpan.textContent = `Error: Feature descriptor not found.`;\n            argsContainer.appendChild(errorSpan);\n        }\n    }\n    else {\n        // No feature selected\n        argsContainer.innerHTML =\n            '<span class=\"has-text-grey-light is-italic is-size-7\">No feature selected</span>';\n    }\n}\n/** Populates the arguments container based on a schema object. */\nfunction populateArgsFromSchema(container, schemaArgs, currentValues, // These are the initial values from featureArgsList\ncurrentSettingsInstance // Expect generic instance\n) {\n    let valueIndex = 0; // Tracks the current position in the currentValues array\n    container.innerHTML = \"\"; // Clear container\n    const argsInnerContainer = document.createElement(\"div\");\n    argsInnerContainer.classList.add(\"feature-args-inner-container\");\n    argsInnerContainer.style.display = \"flex\";\n    argsInnerContainer.style.flexWrap = \"wrap\";\n    argsInnerContainer.style.gap = \"10px\"; // Gap between arg groups\n    schemaArgs.forEach((arg) => {\n        const argWrapper = document.createElement(\"div\");\n        argWrapper.classList.add(\"feature-arg-wrapper\");\n        argWrapper.dataset.argName = arg.name;\n        // --- Create Label ---\n        const label = document.createElement(\"label\");\n        label.classList.add(\"label\", \"is-small\");\n        const labelText = arg.name\n            .replace(/([A-Z])/g, \" $1\")\n            .replace(/^./, (str) => str.toUpperCase())\n            .trim();\n        label.textContent = labelText;\n        label.title = (arg.description || \"\") + (arg.required ? \" (Required)\" : \"\");\n        argWrapper.appendChild(label);\n        // --- Create Inputs Container ---\n        const inputsContainer = document.createElement(\"div\");\n        inputsContainer.classList.add(\"feature-arg-inputs-container\");\n        inputsContainer.dataset.argType = arg.type;\n        if (arg.uiComponentType)\n            inputsContainer.dataset.uiComponentType = arg.uiComponentType;\n        // We rely on the schema's isVariadic flag, not dataset for initial build\n        argWrapper.appendChild(inputsContainer);\n        const uiType = arg.uiComponentType;\n        const isVariadic = arg.isVariadic; // Check schema flag directly\n        // --- Determine which type of input to create and consume values ---\n        if (uiType === \"toggle_button_selector\" ||\n            (isVariadic && uiType !== \"ellipsis\")) {\n            // --- Handle Variadic Types (Toggle Buttons or Generic Variadic) ---\n            const variadicValues = currentValues.slice(valueIndex); // Consume remaining values\n            if (uiType === \"toggle_button_selector\") {\n                (0, common_ui_elements_1.createToggleButtonInput)(inputsContainer, arg, variadicValues);\n            }\n            else {\n                (0, common_ui_elements_1.createVariadicInputElement)(arg, inputsContainer, variadicValues);\n            }\n            valueIndex = currentValues.length; // Mark all remaining values as consumed\n        }\n        else if (uiType === \"ellipsis\") {\n            // --- Handle Ellipsis (Nested Settings) ---\n            if (arg.nestedSchema) {\n                inputsContainer.appendChild((0, common_ui_elements_1.createEllipsisDropdown)(arg, currentSettingsInstance));\n            }\n            else {\n                console.warn(`Ellipsis UI specified for arg \"${arg.name}\" but no nestedSchema provided.`);\n                const errorSpan = document.createElement(\"span\");\n                errorSpan.textContent = \"[Config Error]\";\n                errorSpan.classList.add(\"has-text-danger\", \"is-size-7\");\n                inputsContainer.appendChild(errorSpan);\n            }\n            // Ellipsis does NOT consume values from currentValues array\n        }\n        else {\n            // --- Handle Standard Single-Value Input ---\n            const currentValue = valueIndex < currentValues.length ? currentValues[valueIndex] : \"\";\n            switch (arg.type) {\n                case \"enum\":\n                    inputsContainer.appendChild((0, common_ui_elements_1.createDropdownInput)(arg.name, arg.enum || [], currentValue));\n                    break;\n                case \"number\":\n                    inputsContainer.appendChild((0, common_ui_elements_1.createNumberInput)(arg.name, currentValue));\n                    break;\n                case \"boolean\":\n                    inputsContainer.appendChild((0, common_ui_elements_1.createDropdownInput)(arg.name, [\"true\", \"false\"], currentValue || \"false\"));\n                    break;\n                default: // 'string' or unspecified defaults to text\n                    inputsContainer.appendChild((0, common_ui_elements_1.createTextInput)(arg.name, currentValue, arg.example));\n                    break;\n            }\n            // Increment valueIndex ONLY after consuming a value for a standard argument\n            valueIndex++;\n        }\n        argsInnerContainer.appendChild(argWrapper);\n    });\n    container.appendChild(argsInnerContainer);\n}\n\n\n//# sourceURL=webpack:///./schedule/editor/interval/interval_row_ui.ts?");

/***/ }),

/***/ "./schedule/editor/keyboard_shortcut_manager.ts":
/*!******************************************************!*\
  !*** ./schedule/editor/keyboard_shortcut_manager.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyboardShortcutManager = void 0;\nclass KeyboardShortcutManager {\n    constructor(targetElement, clipboardManager, rowManager, isEnabled) {\n        this.targetElement = targetElement;\n        this.clipboardManager = clipboardManager;\n        this.rowManager = rowManager;\n        this.isEnabled = isEnabled;\n        this._initialize();\n    }\n    _initialize() {\n        this.targetElement.addEventListener(\"keydown\", this._handleKeyDown.bind(this));\n    }\n    _handleKeyDown(e) {\n        // Check if shortcuts are enabled (e.g., editor is in config mode)\n        if (!this.isEnabled())\n            return;\n        // Ignore shortcuts if focus is inside an input/textarea/select\n        const target = e.target;\n        if (target.tagName === \"INPUT\" ||\n            target.tagName === \"TEXTAREA\" ||\n            target.tagName === \"SELECT\") {\n            // Allow default browser behavior (like Ctrl+C/V in text fields)\n            return;\n        }\n        const isCtrlPressed = e.ctrlKey || e.metaKey; // metaKey for macOS\n        if (isCtrlPressed && e.key.toLowerCase() === \"c\") {\n            e.preventDefault();\n            this.clipboardManager.copySelectedRows();\n            console.log(\"Keyboard shortcut: Copied selected rows\");\n        }\n        else if (isCtrlPressed && e.key.toLowerCase() === \"v\") {\n            e.preventDefault();\n            this.clipboardManager.pasteRows();\n            console.log(\"Keyboard shortcut: Pasted rows\");\n        }\n        else if (e.key === \"Delete\" || e.key === \"Backspace\") {\n            // Prevent Backspace from navigating back in browser\n            e.preventDefault();\n            this.rowManager.deleteSelectedRows();\n            console.log(\"Keyboard shortcut: Deleted selected rows\");\n        }\n        // Add other shortcuts here (e.g., Ctrl+X for cut, Ctrl+D for duplicate)\n    }\n}\nexports.KeyboardShortcutManager = KeyboardShortcutManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/keyboard_shortcut_manager.ts?");

/***/ }),

/***/ "./schedule/editor/row_manager.ts":
/*!****************************************!*\
  !*** ./schedule/editor/row_manager.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowManager = void 0;\nconst group_row_ui_1 = __webpack_require__(/*! ./interval/group_row_ui */ \"./schedule/editor/interval/group_row_ui.ts\");\nconst interval_row_ui_1 = __webpack_require__(/*! ./interval/interval_row_ui */ \"./schedule/editor/interval/interval_row_ui.ts\");\nconst common_ui_elements_1 = __webpack_require__(/*! ./interval/common_ui_elements */ \"./schedule/editor/interval/common_ui_elements.ts\");\nconst feature_registry_1 = __webpack_require__(/*! ../../feature_registry */ \"./feature_registry.ts\");\nclass RowManager {\n    constructor(configEntriesContainerEl, selectionManager) {\n        this.configEntriesContainerEl = configEntriesContainerEl;\n        this.selectionManager = selectionManager;\n        this._addRowCopyHandler();\n    }\n    /**\n     * Creates the data structure for a new, empty interval row.\n     * @param categoryName The name of the category for the new row.\n     * @returns An IntervalRowData object or null if the category is invalid.\n     */\n    createEmptyIntervalUIData(categoryName) {\n        const settingsFactory = (0, feature_registry_1.getIntervalSettingsFactory)(categoryName);\n        if (!settingsFactory) {\n            console.error(`Cannot create empty row data: No IntervalSettings factory found for category \"${categoryName}\".`);\n            return null; // Indicate failure\n        }\n        const defaultSettings = settingsFactory();\n        // Create Row Data using the created default settings instance\n        const newRowUIData = {\n            rowType: \"interval\",\n            duration: \"3:00\", // Default duration\n            task: \"\",\n            categoryName: categoryName, // Assign the category name string\n            featureTypeName: \"\",\n            featureArgsList: [],\n            intervalSettings: defaultSettings, // Assign instance from factory\n        };\n        return newRowUIData;\n    }\n    /** Adds an empty interval row to the UI for a specific category */\n    addEmptyIntervalRow(categoryName, insertAfterElement) {\n        // Return null on failure\n        // Create the data structure using the new helper method\n        const newRowUIData = this.createEmptyIntervalUIData(categoryName);\n        if (!newRowUIData) {\n            return null; // Failed to create data (e.g., invalid category)\n        }\n        // Pass the category name string and data to the builder function\n        const newRowElement = (0, interval_row_ui_1.buildIntervalRowElement)(newRowUIData, categoryName);\n        this.insertRowElement(newRowElement, insertAfterElement); // Insert into DOM\n        return newRowElement;\n    }\n    /** Adds a group row to the UI */\n    addGroupRow(level = 1, name = \"\", insertAfterElement) {\n        const newRowUIData = {\n            rowType: \"group\",\n            level: Math.max(1, level),\n            name: name || `New Group Level ${level}`,\n        };\n        const newRowElement = (0, group_row_ui_1.buildGroupRowElement)(newRowUIData);\n        this.insertRowElement(newRowElement, insertAfterElement);\n        return newRowElement;\n    }\n    /** Inserts a row element into the container */\n    insertRowElement(newRowElement, insertAfterElement) {\n        let effectiveInsertAfter = insertAfterElement;\n        if (!effectiveInsertAfter) {\n            effectiveInsertAfter =\n                this.selectionManager.getLastSelectedElementInDomOrder();\n        }\n        if (effectiveInsertAfter &&\n            effectiveInsertAfter.parentNode === this.configEntriesContainerEl) {\n            this.configEntriesContainerEl.insertBefore(newRowElement, effectiveInsertAfter.nextSibling);\n        }\n        else {\n            this.configEntriesContainerEl.appendChild(newRowElement);\n        }\n        this.updateAllRowIndentation();\n    }\n    /** Deletes all currently selected rows */\n    deleteSelectedRows() {\n        const selectedRows = this.selectionManager.getSelectedElementsInDomOrder();\n        if (selectedRows.length === 0)\n            return;\n        selectedRows.forEach((row) => row.remove());\n        this.selectionManager.clearSelection();\n        this.updateAllRowIndentation();\n    }\n    /** Recalculates and applies indentation to all rows */\n    updateAllRowIndentation() {\n        const rows = Array.from(this.configEntriesContainerEl.querySelectorAll(\".schedule-row\"));\n        const levelStack = [0];\n        rows.forEach((row) => {\n            const rowType = row.dataset.rowType;\n            let currentIndentLevel = levelStack[levelStack.length - 1];\n            if (rowType === \"group\") {\n                const groupLevel = parseInt(row.dataset.level || \"1\", 10);\n                while (levelStack.length > 1 &&\n                    levelStack[levelStack.length - 1] >= groupLevel) {\n                    levelStack.pop();\n                }\n                currentIndentLevel = levelStack[levelStack.length - 1];\n                (0, common_ui_elements_1.applyIndentation)(row, currentIndentLevel);\n                levelStack.push(groupLevel);\n            }\n            else {\n                (0, common_ui_elements_1.applyIndentation)(row, currentIndentLevel);\n            }\n        });\n    }\n    /**\n     * Extracts data from a single row element into a JSON-compatible structure.\n     * Includes the categoryName string for interval rows.\n     * Correctly extracts variadic arguments like toggle button selections.\n     * @param rowElement - The HTML element for the schedule row (.schedule-row).\n     * @returns {ScheduleRowJSONData | null} Plain data object or null if extraction fails.\n     */\n    getRowData(rowElement) {\n        var _a;\n        const rowType = rowElement.dataset.rowType;\n        try {\n            if (rowType === \"group\") {\n                // --- Group Row Data Extraction (Unchanged) ---\n                const level = parseInt(rowElement.dataset.level || \"1\", 10);\n                const nameInput = rowElement.querySelector(\".group-name-input\");\n                const name = (nameInput === null || nameInput === void 0 ? void 0 : nameInput.value.trim()) || \"\";\n                return { rowType: \"group\", level, name };\n            }\n            else if (rowType === \"interval\") {\n                // --- Interval Row Data Extraction ---\n                const durationInput = rowElement.querySelector(\".config-duration\");\n                const taskInput = rowElement.querySelector(\".config-task\");\n                const featureTypeSelect = rowElement.querySelector(\".config-feature-type\");\n                const categoryName = rowElement.dataset.categoryName;\n                if (!categoryName) {\n                    console.error(\"Failed to get row data: Interval row missing 'data-category-name'.\", rowElement);\n                    return null;\n                }\n                const duration = (durationInput === null || durationInput === void 0 ? void 0 : durationInput.value.trim()) || \"0:00\";\n                const task = (taskInput === null || taskInput === void 0 ? void 0 : taskInput.value.trim()) || \"\";\n                const featureTypeName = (featureTypeSelect === null || featureTypeSelect === void 0 ? void 0 : featureTypeSelect.value.trim()) || \"\";\n                // Get Settings Instance & Serialize\n                const intervalSettingsInstance = (_a = rowElement._intervalSettings) !== null && _a !== void 0 ? _a : null;\n                const intervalSettingsJSON = intervalSettingsInstance === null || intervalSettingsInstance === void 0 ? void 0 : intervalSettingsInstance.toJSON();\n                // --- Extract Feature Arguments ---\n                const featureArgsList = [];\n                const argsContainer = rowElement.querySelector(\".config-feature-args-container .feature-args-inner-container\");\n                if (argsContainer && featureTypeName) {\n                    // Only extract args if a feature is selected\n                    const descriptor = (0, feature_registry_1.getFeatureTypeDescriptor)(categoryName, featureTypeName);\n                    const schema = descriptor === null || descriptor === void 0 ? void 0 : descriptor.getConfigurationSchema();\n                    if (typeof schema === \"object\" &&\n                        \"args\" in schema &&\n                        Array.isArray(schema.args)) {\n                        const schemaArgs = schema.args;\n                        let schemaArgIndex = 0; // Track position in schema\n                        const argWrappers = argsContainer.querySelectorAll(\":scope > .feature-arg-wrapper\");\n                        argWrappers.forEach((wrapper) => {\n                            var _a, _b;\n                            const currentSchemaArg = schemaArgs[schemaArgIndex];\n                            if (!currentSchemaArg) {\n                                console.warn(\"More arg wrappers found in UI than in schema for\", featureTypeName);\n                                return;\n                            }\n                            const inputsContainer = wrapper.querySelector(\".feature-arg-inputs-container\");\n                            if (!inputsContainer)\n                                return;\n                            const uiType = inputsContainer.dataset.uiComponentType;\n                            const isVariadic = currentSchemaArg.isVariadic; // Check schema, not just dataset\n                            if (uiType === \"toggle_button_selector\") {\n                                // **** START: Toggle Button Logic ****\n                                const activeButtons = inputsContainer.querySelectorAll(\".numeral-toggle-btn.is-active\");\n                                const selectedValues = Array.from(activeButtons)\n                                    .map((btn) => btn.dataset.value || \"\")\n                                    .filter((v) => v);\n                                featureArgsList.push(...selectedValues);\n                                // Toggle button consumes all remaining args if variadic\n                                if (isVariadic)\n                                    schemaArgIndex = schemaArgs.length;\n                                // **** END: Toggle Button Logic ****\n                            }\n                            else if (uiType === \"ellipsis\") {\n                                // Settings handled by intervalSettingsJSON, consume schema arg\n                                schemaArgIndex++;\n                            }\n                            else if (isVariadic) {\n                                // **** START: General Variadic Logic ****\n                                const variadicInputs = inputsContainer.querySelectorAll(\".config-feature-arg, .select > select\");\n                                variadicInputs.forEach((input) => {\n                                    var _a;\n                                    // Add value only if it's not empty/whitespace\n                                    const value = (_a = input.value) === null || _a === void 0 ? void 0 : _a.trim();\n                                    if (value) {\n                                        featureArgsList.push(value);\n                                    }\n                                });\n                                // Variadic argument consumes the rest of the schema (usually only one variadic arg)\n                                schemaArgIndex = schemaArgs.length;\n                                // **** END: General Variadic Logic ****\n                            }\n                            else {\n                                // **** START: Standard Single Argument Logic ****\n                                const inputElement = inputsContainer.querySelector(\".config-feature-arg, .select > select\");\n                                featureArgsList.push((_b = (_a = inputElement === null || inputElement === void 0 ? void 0 : inputElement.value) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\");\n                                schemaArgIndex++;\n                                // **** END: Standard Single Argument Logic ****\n                            }\n                        });\n                    }\n                    else {\n                        // Handle cases where schema is just a string or feature has no args\n                        console.log(`Feature '${featureTypeName}' has no structured args or schema is a string.`);\n                    }\n                }\n                else if (!featureTypeName) {\n                    // No feature selected, args list should be empty\n                }\n                else {\n                    console.warn(`Args container not found for interval row:`, rowElement);\n                }\n                const intervalData = {\n                    rowType: \"interval\",\n                    duration,\n                    task,\n                    categoryName,\n                    featureTypeName,\n                    featureArgsList, // Use the extracted list\n                };\n                // Add settings only if they are not default (toJSON returns undefined if default)\n                if (intervalSettingsJSON) {\n                    intervalData.intervalSettings = intervalSettingsJSON;\n                }\n                return intervalData;\n            }\n            else {\n                console.warn(\"Unknown row type found during getRowData:\", rowType, rowElement);\n                return null;\n            }\n        }\n        catch (error) {\n            console.error(\"Error getting data for row:\", rowElement, error);\n            return null;\n        }\n    }\n    /** Attaches event listener for row copy buttons */\n    _addRowCopyHandler() {\n        this.configEntriesContainerEl.addEventListener(\"click\", (e) => {\n            const targetElement = e.target;\n            const copyButton = targetElement.closest(\".copy-row-btn\");\n            if (copyButton) {\n                e.stopPropagation();\n                const rowToCopy = targetElement.closest(\".schedule-row\");\n                if (rowToCopy) {\n                    // Select the row visually for feedback\n                    this.selectionManager.selectSingleRow(rowToCopy);\n                    // Flash effect\n                    rowToCopy.style.transition = \"background-color 0.1s ease-out\";\n                    rowToCopy.style.backgroundColor = \"rgba(72, 199, 116, 0.3)\";\n                    setTimeout(() => {\n                        rowToCopy.style.backgroundColor = \"\";\n                        rowToCopy.style.transition = \"\";\n                    }, 250);\n                    // ClipboardManager will handle the actual data copy via SelectionManager\n                }\n            }\n        });\n    }\n    /** Helper to get IntervalSettingsFactory for a category */\n    getIntervalSettingsFactory(categoryName) {\n        return (0, feature_registry_1.getIntervalSettingsFactory)(categoryName);\n    }\n}\nexports.RowManager = RowManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/row_manager.ts?");

/***/ }),

/***/ "./schedule/editor/schedule_builder.ts":
/*!*********************************************!*\
  !*** ./schedule/editor/schedule_builder.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScheduleBuilder = void 0;\nconst schedule_1 = __webpack_require__(/*! ../schedule */ \"./schedule/schedule.ts\");\n// Import registry functions for generic handling\nconst feature_registry_1 = __webpack_require__(/*! ../../feature_registry */ \"./feature_registry.ts\");\nconst time_utils_1 = __webpack_require__(/*! ../../time_utils */ \"./time_utils.ts\");\nclass ScheduleBuilder {\n    constructor(rowManager, errorDisplay, configEntriesContainerEl) {\n        this.rowManager = rowManager;\n        this.errorDisplay = errorDisplay;\n        this.configEntriesContainerEl = configEntriesContainerEl;\n    }\n    /**\n     * Builds the Schedule object from the current state of the config editor UI rows.\n     * Uses the feature registry for generic feature/settings instantiation.\n     * @returns A new Schedule instance or null if errors occur.\n     */\n    buildSchedule(displayController, audioController, settings, maxCanvasHeight) {\n        console.log(\"[ScheduleBuilder] Starting buildSchedule...\");\n        this.errorDisplay.removeMessage(); // Clear previous errors\n        const schedule = new schedule_1.Schedule(displayController, audioController);\n        const rows = this.configEntriesContainerEl.querySelectorAll(\".schedule-row\");\n        let hasErrors = false;\n        let totalDurationSeconds = 0;\n        const MAX_TOTAL_DURATION_SECONDS = 3 * 60 * 60; // 3 hours\n        rows.forEach((rowElement, index) => {\n            if (hasErrors)\n                return; // Stop processing if an error occurred\n            // Get row data using RowManager (which now includes categoryName)\n            const rowData = this.rowManager.getRowData(rowElement);\n            if (!rowData) {\n                console.warn(`[ScheduleBuilder] Skipping row ${index + 1} due to data extraction error.`);\n                // Optionally report this as an error? For now, just skip.\n                // this.errorDisplay.showMessage(`Error reading data for row ${index + 1}.`);\n                // hasErrors = true;\n                return;\n            }\n            if (rowData.rowType === \"interval\") {\n                // Type assertion is safe here because rowType is checked\n                const intervalData = rowData;\n                const categoryName = intervalData.categoryName; // Get category name string\n                console.log(`[ScheduleBuilder] Processing interval ${index + 1}: Cat='${categoryName}', Type='${intervalData.featureTypeName || \"None\"}', Task='${intervalData.task}', Duration='${intervalData.duration}'`);\n                let durationSeconds = 0;\n                let feature = null;\n                let intervalSettings = null;\n                try {\n                    // 1. Parse Duration\n                    durationSeconds = (0, time_utils_1.parseDurationString)(intervalData.duration);\n                    if (durationSeconds < 0)\n                        throw new Error(\"Duration cannot be negative.\");\n                    totalDurationSeconds += durationSeconds;\n                    if (totalDurationSeconds > MAX_TOTAL_DURATION_SECONDS) {\n                        throw new Error(`Total schedule duration exceeds maximum limit (${MAX_TOTAL_DURATION_SECONDS / 3600} hours).`);\n                    }\n                    // 2. Instantiate Interval Settings Generically using Parser from Registry\n                    const settingsParser = (0, feature_registry_1.getIntervalSettingsParser)(categoryName);\n                    if (settingsParser) {\n                        intervalSettings = settingsParser(intervalData.intervalSettings); // Use the parser\n                    }\n                    else {\n                        // Fallback or error if no parser is found for the category\n                        console.warn(`[ScheduleBuilder] No interval settings parser found for category \"${categoryName}\". Using raw data or default fallback.`);\n                        // Create a basic object that satisfies the interface minimally\n                        intervalSettings = {\n                            toJSON: () => intervalData.intervalSettings || {},\n                        };\n                        if (intervalData.intervalSettings) {\n                            Object.assign(intervalSettings, intervalData.intervalSettings); // Attempt generic assignment\n                        }\n                    }\n                    // 3. Create Feature if specified (Generically)\n                    if (intervalData.featureTypeName) {\n                        // Use categoryName string for lookup\n                        const descriptor = (0, feature_registry_1.getFeatureTypeDescriptor)(categoryName, intervalData.featureTypeName);\n                        if (!descriptor) {\n                            throw new Error(`Unknown feature type: \"${intervalData.featureTypeName}\" in category \"${categoryName}\"`);\n                        }\n                        console.log(`[ScheduleBuilder] Found descriptor for '${descriptor.typeName}'. Attempting createFeature...`);\n                        // --- Call createFeature with parsed intervalSettings and categoryName ---\n                        if (intervalSettings) {\n                            feature = descriptor.createFeature(intervalData.featureArgsList, audioController, settings, intervalSettings, // Pass the parsed settings object\n                            maxCanvasHeight, categoryName // Pass category name string\n                            );\n                            console.log(`[ScheduleBuilder] Successfully created feature instance for '${descriptor.typeName}'.`);\n                        }\n                        else {\n                            // This case should be less likely now due to fallback in step 2\n                            throw new Error(`Could not create feature \"${descriptor.typeName}\" due to missing interval settings.`);\n                        }\n                    }\n                    else {\n                        console.log(`[ScheduleBuilder] No feature specified for interval ${index + 1}.`);\n                    }\n                    // 4. Create Interval and add to Schedule\n                    const interval = new schedule_1.Interval(durationSeconds, settings.warmupPeriod, // Use global warmup setting\n                    intervalData.task ||\n                        intervalData.featureTypeName ||\n                        `Interval ${index + 1}`, // Task name fallback\n                    feature // Add the created feature (or null)\n                    );\n                    schedule.addInterval(interval);\n                    console.log(`[ScheduleBuilder] Added interval ${index + 1} to schedule.`);\n                }\n                catch (error) {\n                    const errorMessage = `[ScheduleBuilder] Error processing interval ${index + 1} (${intervalData.task ||\n                        intervalData.featureTypeName ||\n                        intervalData.duration}): ${error.message}`;\n                    console.error(errorMessage, error);\n                    this.errorDisplay.showMessage(errorMessage);\n                    hasErrors = true; // Set flag to stop processing\n                }\n            }\n            else if (rowData.rowType === \"group\") {\n                // Groups are currently ignored during schedule building\n                console.log(`[ScheduleBuilder] Skipping group row ${index + 1}: '${rowData.name}'`);\n            }\n        });\n        if (hasErrors) {\n            console.error(\"[ScheduleBuilder] Schedule building failed due to errors.\");\n            return null; // Return null if any errors occurred\n        }\n        if (schedule.intervals.length === 0) {\n            console.warn(\"[ScheduleBuilder] Schedule built successfully, but contains no intervals.\");\n            this.errorDisplay.showMessage(\"Schedule is empty. Add some intervals.\", \"warning\");\n            // Return the empty schedule or null? Returning schedule for now.\n        }\n        else {\n            console.log(`[ScheduleBuilder] Schedule built successfully with ${schedule.intervals.length} intervals.`);\n        }\n        return schedule;\n    }\n}\nexports.ScheduleBuilder = ScheduleBuilder;\n\n\n//# sourceURL=webpack:///./schedule/editor/schedule_builder.ts?");

/***/ }),

/***/ "./schedule/editor/schedule_editor.ts":
/*!********************************************!*\
  !*** ./schedule/editor/schedule_editor.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScheduleEditor = void 0;\nconst settings_1 = __webpack_require__(/*! ../../settings */ \"./settings.ts\");\n// Use JSON serializer functions\nconst schedule_serializer_1 = __webpack_require__(/*! ./schedule_serializer */ \"./schedule/editor/schedule_serializer.ts\"); // Import ScheduleDocument\nconst interval_row_ui_1 = __webpack_require__(/*! ./interval/interval_row_ui */ \"./schedule/editor/interval/interval_row_ui.ts\");\nconst group_row_ui_1 = __webpack_require__(/*! ./interval/group_row_ui */ \"./schedule/editor/interval/group_row_ui.ts\");\n// Import managers\nconst editor_ui_manager_1 = __webpack_require__(/*! ./editor_ui_manager */ \"./schedule/editor/editor_ui_manager.ts\");\nconst error_display_1 = __webpack_require__(/*! ./error_display */ \"./schedule/editor/error_display.ts\");\nconst selection_manager_1 = __webpack_require__(/*! ./selection_manager */ \"./schedule/editor/selection_manager.ts\");\nconst row_manager_1 = __webpack_require__(/*! ./row_manager */ \"./schedule/editor/row_manager.ts\");\nconst clipboard_manager_1 = __webpack_require__(/*! ./clipboard_manager */ \"./schedule/editor/clipboard_manager.ts\");\nconst drag_drop_manager_1 = __webpack_require__(/*! ./drag_drop_manager */ \"./schedule/editor/drag_drop_manager.ts\");\nconst keyboard_shortcut_manager_1 = __webpack_require__(/*! ./keyboard_shortcut_manager */ \"./schedule/editor/keyboard_shortcut_manager.ts\");\nconst schedule_builder_1 = __webpack_require__(/*! ./schedule_builder */ \"./schedule/editor/schedule_builder.ts\");\nconst feature_registry_1 = __webpack_require__(/*! ../../feature_registry */ \"./feature_registry.ts\"); // Import registry getter and Category type\n// --- Removed FeatureCategoryName import ---\nvar EditorMode;\n(function (EditorMode) {\n    EditorMode[\"JSON\"] = \"json\";\n    EditorMode[\"Config\"] = \"config\";\n})(EditorMode || (EditorMode = {}));\nconst DEFAULT_SCHEDULE_NAME = \"Untitled Schedule\";\n// --- REMOVED: DEFAULT_CATEGORY_FOR_NEW_ROWS constant ---\nclass ScheduleEditor {\n    constructor(containerEl, updateAction, audioController) {\n        this.currentMode = EditorMode.Config;\n        this.scheduleName = DEFAULT_SCHEDULE_NAME;\n        this.defaultCategoryName = null; // Store the determined default category\n        if (!containerEl)\n            throw new Error(\"ScheduleEditor: Container element is required.\");\n        this.containerEl = containerEl;\n        this.updateAction = updateAction;\n        this.audioController = audioController;\n        // --- Determine Default Category ---\n        const availableCategories = (0, feature_registry_1.getAvailableCategories)();\n        if (availableCategories.length > 0) {\n            this.defaultCategoryName = availableCategories[0].getName();\n            console.log(`Using default category: ${this.defaultCategoryName}`);\n        }\n        else {\n            console.error(\"CRITICAL: No categories registered. Cannot determine default category for editor.\");\n            // Optionally disable parts of the editor UI\n        }\n        // --- End Determine Default Category ---\n        this.uiManager = new editor_ui_manager_1.EditorUIManager(this.containerEl);\n        this._findNameEditElements();\n        this.errorDisplay = new error_display_1.ErrorDisplay(this.containerEl, this.uiManager.editorControlsContainerEl);\n        this.selectionManager = new selection_manager_1.SelectionManager(this.uiManager.configEntriesContainerEl, this._onSelectionChange.bind(this));\n        this.rowManager = new row_manager_1.RowManager(this.uiManager.configEntriesContainerEl, this.selectionManager);\n        this.clipboardManager = new clipboard_manager_1.ClipboardManager(this.selectionManager, this.rowManager, this._onClipboardChange.bind(this));\n        this.dndManager = new drag_drop_manager_1.DragDropManager(this.uiManager.configEntriesContainerEl, this.selectionManager, this.rowManager);\n        this.keyboardManager = new keyboard_shortcut_manager_1.KeyboardShortcutManager(this.uiManager.configEntriesContainerEl, this.clipboardManager, this.rowManager, () => this.currentMode === EditorMode.Config);\n        this.scheduleBuilder = new schedule_builder_1.ScheduleBuilder(this.rowManager, this.errorDisplay, this.uiManager.configEntriesContainerEl);\n        this._attachButtonHandlers();\n        this._attachNameEditHandlers();\n        this.setEditorMode(this.currentMode, true);\n        this._loadInitialState(); // Will now use default category's intervals\n        this._updateScheduleNameDisplay();\n        // Ensure config UI reflects loaded state if starting in config mode\n        if (this.currentMode === EditorMode.Config) {\n            if (this.uiManager.textEl.value.trim().length > 0) {\n                this.syncJSONViewToConfig(); // Sync if JSON text area has content\n            }\n            // Add default row ONLY if config view is STILL empty AFTER potential sync AND a default category exists\n            if (this.uiManager.configEntriesContainerEl.childElementCount === 0 &&\n                this.defaultCategoryName) {\n                console.log(\"Config view empty after load/sync, adding default interval row.\");\n                this.rowManager.addEmptyIntervalRow(this.defaultCategoryName);\n            }\n        }\n    }\n    // ... (_findNameEditElements, _updateScheduleNameDisplay, _attachNameEditHandlers unchanged) ...\n    _findNameEditElements() {\n        this.scheduleNameDisplayEl = document.getElementById(\"schedule-name-display\");\n        this.editScheduleNameBtnEl = document.getElementById(\"edit-schedule-name-btn\");\n        if (!this.scheduleNameDisplayEl)\n            console.warn(\"Schedule name display element (#schedule-name-display) not found.\");\n        if (!this.editScheduleNameBtnEl)\n            console.warn(\"Edit schedule name button (#edit-schedule-name-btn) not found.\");\n    }\n    _updateScheduleNameDisplay() {\n        if (this.scheduleNameDisplayEl) {\n            this.scheduleNameDisplayEl.textContent = `Schedule: ${this.scheduleName}`;\n            this.scheduleNameDisplayEl.title = `Current schedule: ${this.scheduleName}. Click Edit button to rename.`;\n        }\n    }\n    _attachNameEditHandlers() {\n        if (!this.editScheduleNameBtnEl || !this.scheduleNameDisplayEl)\n            return;\n        this.editScheduleNameBtnEl.onclick = (event) => {\n            event.stopPropagation(); // Stop propagation\n            const currentName = this.scheduleName;\n            const newName = prompt(\"Enter new schedule name:\", currentName);\n            if (newName !== null && newName.trim() !== \"\") {\n                this.scheduleName = newName.trim();\n                this._updateScheduleNameDisplay();\n                console.log(\"Schedule name updated to:\", this.scheduleName);\n            }\n            else if (newName !== null) {\n                alert(\"Schedule name cannot be empty.\");\n            }\n        };\n    }\n    // --- Mode Switching & Syncing ---\n    toggleMode() {\n        const nextMode = this.currentMode === EditorMode.Config\n            ? EditorMode.JSON\n            : EditorMode.Config;\n        this.setEditorMode(nextMode);\n    }\n    setEditorMode(mode, skipSync = false) {\n        this.currentMode = mode;\n        const isTextMode = mode === EditorMode.JSON;\n        this.uiManager.setModeUI(isTextMode);\n        if (!skipSync) {\n            if (isTextMode)\n                this.syncConfigToJSONView();\n            else\n                this.syncJSONViewToConfig();\n        }\n        console.log(`Editor mode set to ${mode}. Skip sync: ${skipSync}`);\n    }\n    syncConfigToJSONView() {\n        try {\n            const jsonString = this._generateJSONFromConfigView();\n            this.uiManager.textEl.value = jsonString;\n            this.errorDisplay.removeMessage();\n        }\n        catch (error) {\n            console.error(\"Error syncing config to JSON:\", error);\n            this.errorDisplay.showMessage(`Error generating JSON: ${error.message}`);\n        }\n    }\n    syncJSONViewToConfig() {\n        try {\n            const scheduleJSON = this.uiManager.textEl.value;\n            const parsedDoc = (0, schedule_serializer_1.parseScheduleJSON)(scheduleJSON);\n            this.scheduleName = parsedDoc.name || DEFAULT_SCHEDULE_NAME;\n            this._updateScheduleNameDisplay();\n            this.uiManager.populateConfigUI(this._buildRowElement.bind(this), parsedDoc.items);\n            this.rowManager.updateAllRowIndentation();\n            this.selectionManager.clearSelection();\n            this.errorDisplay.removeMessage();\n        }\n        catch (error) {\n            console.error(\"Error parsing schedule JSON:\", error);\n            this.errorDisplay.showMessage(`Error parsing JSON input: ${error.message}`);\n        }\n    }\n    // --- Load/Save/Build ---\n    _loadInitialState() {\n        const lastRunJSON = localStorage.getItem(settings_1.LAST_RUN_SCHEDULE_JSON_KEY);\n        let initialJSON = null;\n        let initialItems = null;\n        let initialName = undefined;\n        if (lastRunJSON) {\n            console.log(\"Found last run schedule (JSON) in localStorage. Attempting to parse...\");\n            try {\n                const parsedDoc = (0, schedule_serializer_1.parseScheduleJSON)(lastRunJSON);\n                initialName = parsedDoc.name;\n                initialItems = parsedDoc.items;\n                initialJSON = lastRunJSON;\n                console.log(\"Successfully parsed last run schedule.\");\n            }\n            catch (e) {\n                console.warn(\"Could not parse last run schedule JSON, removing from storage.\", e);\n                localStorage.removeItem(settings_1.LAST_RUN_SCHEDULE_JSON_KEY);\n            }\n        }\n        if (!initialItems) {\n            console.log(\"Loading default schedule from first registered category...\");\n            const categories = (0, feature_registry_1.getAvailableCategories)();\n            if (categories.length > 0) {\n                const defaultCategory = categories[0];\n                if (typeof defaultCategory.getDefaultIntervals === \"function\") {\n                    initialItems = defaultCategory.getDefaultIntervals();\n                }\n                initialName = `${defaultCategory.getDisplayName()} Default`;\n            }\n            if (!initialItems || initialItems.length === 0) {\n                console.warn(\"Default category did not provide default intervals or no categories registered. Creating single empty interval.\");\n                initialItems = []; // Ensure it's an empty array if fallback needed\n                if (this.defaultCategoryName) {\n                    // *** FIX: Use the new method to get data ***\n                    const emptyRowData = this.rowManager.createEmptyIntervalUIData(this.defaultCategoryName);\n                    if (emptyRowData) {\n                        initialItems.push(emptyRowData);\n                    }\n                    else {\n                        console.error(\"Failed to create empty interval row data for default schedule.\");\n                    }\n                }\n                initialName = DEFAULT_SCHEDULE_NAME;\n            }\n            // Generate JSON from these default items for the text editor view\n            try {\n                // Need to build temporary elements to use getRowData for JSON conversion\n                const tempContainer = document.createElement(\"div\");\n                initialItems.forEach((itemData) => {\n                    const el = this._buildRowElement(itemData);\n                    if (el)\n                        tempContainer.appendChild(el);\n                });\n                const rowElements = Array.from(tempContainer.querySelectorAll(\".schedule-row\"));\n                const jsonItems = rowElements\n                    .map((row) => this.rowManager.getRowData(row))\n                    .filter((d) => d !== null);\n                initialJSON = (0, schedule_serializer_1.generateScheduleJSON)(initialName, jsonItems);\n            }\n            catch (e) {\n                console.error(\"Error generating JSON for default schedule:\", e);\n                initialJSON = JSON.stringify({ name: initialName, items: [] }, null, 2);\n            }\n        }\n        // Set initial state using the determined JSON or parsed data\n        if (initialJSON !== null) {\n            this.setScheduleJSON(initialJSON, true); // skipSync=true initially\n        }\n        else {\n            console.error(\"Failed to determine initial schedule state.\");\n            this.scheduleName = DEFAULT_SCHEDULE_NAME;\n            this._updateScheduleNameDisplay();\n            this._clearConfigEntries();\n            if (this.defaultCategoryName) {\n                this.rowManager.addEmptyIntervalRow(this.defaultCategoryName);\n            }\n        }\n    }\n    /** Helper to build row elements based on data type, passing necessary context */\n    _buildRowElement(rowData) {\n        if (rowData.rowType === \"group\") {\n            return (0, group_row_ui_1.buildGroupRowElement)(rowData);\n        }\n        else if (rowData.rowType === \"interval\") {\n            const intervalData = rowData;\n            const categoryName = intervalData.categoryName;\n            if (!categoryName) {\n                console.error(\"Cannot build interval row: Missing categoryName in rowData\", intervalData);\n                const errorDiv = document.createElement(\"div\");\n                errorDiv.textContent = \"[Error: Missing Category]\";\n                errorDiv.style.color = \"red\";\n                errorDiv.classList.add(\"schedule-row\");\n                return errorDiv;\n            }\n            return (0, interval_row_ui_1.buildIntervalRowElement)(intervalData, categoryName);\n        }\n        console.warn(\"Trying to build unknown row type:\", rowData);\n        return null;\n    }\n    /** Attaches handlers to the main editor control buttons */\n    _attachButtonHandlers() {\n        this.uiManager.modeToggleEl.onclick = () => this.toggleMode();\n        this.uiManager.newScheduleButtonEl.onclick = () => this.newSchedule();\n        this.uiManager.addConfigEntryButtonEl.onclick = () => {\n            if (this.defaultCategoryName) {\n                this.rowManager.addEmptyIntervalRow(this.defaultCategoryName);\n            }\n            else {\n                alert(\"Error: Cannot add interval. No default category found.\");\n            }\n        };\n        this.uiManager.addGroupButtonEl.onclick = () => this.rowManager.addGroupRow();\n        this.uiManager.copyButtonEl.onclick = () => this.clipboardManager.copySelectedRows();\n        this.uiManager.pasteButtonEl.onclick = () => this.clipboardManager.pasteRows();\n        this.uiManager.setScheduleButtonEl.onclick = () => {\n            this.errorDisplay.removeMessage();\n            this.updateAction(); // Trigger the main application update (reset)\n        };\n    }\n    /** Callback when selection changes (passed to SelectionManager) */\n    _onSelectionChange() {\n        const canCopy = this.selectionManager.getSelectedElements().size > 0;\n        this.uiManager.updateCopyPasteButtonState(canCopy, this.clipboardManager.hasCopiedData());\n    }\n    /** Callback when clipboard content changes (passed to ClipboardManager) */\n    _onClipboardChange(canPaste) {\n        const canCopy = this.selectionManager.getSelectedElements().size > 0;\n        this.uiManager.updateCopyPasteButtonState(canCopy, canPaste);\n    }\n    /** Clears the editor content and resets state for a new schedule. */\n    newSchedule() {\n        if (!confirm(\"Clear the current schedule and start a new one?\"))\n            return;\n        console.log(\"Starting new schedule...\");\n        this._clearConfigEntries();\n        this.uiManager.textEl.value = \"\";\n        this.scheduleName = DEFAULT_SCHEDULE_NAME;\n        this._updateScheduleNameDisplay();\n        this.selectionManager.clearSelection(true);\n        this.clipboardManager.clearClipboard();\n        if (this.defaultCategoryName) {\n            this.rowManager.addEmptyIntervalRow(this.defaultCategoryName);\n        }\n        else {\n            console.error(\"Cannot add default row for new schedule: No default category found.\");\n            this.errorDisplay.showMessage(\"Cannot create new schedule: No feature categories registered.\", \"error\");\n        }\n        this.errorDisplay.removeMessage(); // Clear any previous errors specifically\n        if (this.currentMode !== EditorMode.Config) {\n            this.setEditorMode(EditorMode.Config, true);\n        }\n    }\n    /** Removes all row elements from the config view */\n    _clearConfigEntries() {\n        while (this.uiManager.configEntriesContainerEl.firstChild) {\n            this.uiManager.configEntriesContainerEl.removeChild(this.uiManager.configEntriesContainerEl.firstChild);\n        }\n    }\n    /** Gets the current schedule definition as a JSON string */\n    getScheduleJSON() {\n        if (this.currentMode === EditorMode.JSON) {\n            try {\n                (0, schedule_serializer_1.parseScheduleJSON)(this.uiManager.textEl.value);\n                return this.uiManager.textEl.value;\n            }\n            catch (e) {\n                console.warn(\"JSON in text editor is invalid, generating from config view instead.\");\n                this.errorDisplay.showMessage(`JSON Error: ${e instanceof Error ? e.message : String(e)}. Using Config view.`);\n                return this._generateJSONFromConfigView();\n            }\n        }\n        else {\n            return this._generateJSONFromConfigView();\n        }\n    }\n    /** Helper to generate JSON from the config view UI elements (uses updated rowManager) */\n    _generateJSONFromConfigView() {\n        const rows = this.uiManager.configEntriesContainerEl.querySelectorAll(\".schedule-row\");\n        const rowDataArray = Array.from(rows)\n            .map((row) => this.rowManager.getRowData(row))\n            .filter((d) => d !== null);\n        return (0, schedule_serializer_1.generateScheduleJSON)(this.scheduleName, rowDataArray);\n    }\n    /** Sets the editor content from a JSON string (uses updated parser) */\n    setScheduleJSON(jsonString, skipSync = false) {\n        console.log(\"Setting schedule JSON programmatically.\");\n        try {\n            const parsedDoc = (0, schedule_serializer_1.parseScheduleJSON)(jsonString);\n            this.scheduleName = parsedDoc.name || DEFAULT_SCHEDULE_NAME;\n            let prettyJson = jsonString;\n            try {\n                prettyJson = JSON.stringify(JSON.parse(jsonString), null, 2);\n            }\n            catch (_a) { }\n            this.uiManager.textEl.value = prettyJson;\n            this._updateScheduleNameDisplay();\n            this.errorDisplay.removeMessage();\n            if (!skipSync && this.currentMode === EditorMode.Config) {\n                this.syncJSONViewToConfig();\n            }\n            else if (skipSync && this.currentMode === EditorMode.Config) {\n                this.uiManager.populateConfigUI(this._buildRowElement.bind(this), parsedDoc.items);\n                this.rowManager.updateAllRowIndentation();\n                this.selectionManager.clearSelection();\n            }\n            console.log(\"Schedule JSON set and potentially synced to editor view.\");\n        }\n        catch (error) {\n            console.error(\"Failed to set schedule JSON:\", error);\n            this.errorDisplay.showMessage(`Failed to load schedule: ${error.message}`);\n        }\n    }\n    /** Builds and returns the Schedule object for the timer (uses updated builder) */\n    getSchedule(displayController, settings, maxCanvasHeight) {\n        if (this.currentMode === EditorMode.JSON) {\n            this.syncJSONViewToConfig();\n            if (this.errorDisplay.hasMessage()) {\n                console.error(\"Cannot build schedule due to errors during JSON-to-config sync.\");\n                return null;\n            }\n        }\n        return this.scheduleBuilder.buildSchedule(displayController, this.audioController, settings, maxCanvasHeight);\n    }\n}\nexports.ScheduleEditor = ScheduleEditor;\n\n\n//# sourceURL=webpack:///./schedule/editor/schedule_editor.ts?");

/***/ }),

/***/ "./schedule/editor/schedule_serializer.ts":
/*!************************************************!*\
  !*** ./schedule/editor/schedule_serializer.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseScheduleJSON = parseScheduleJSON;\nexports.generateScheduleJSON = generateScheduleJSON;\n// Import registry functions for generic handling\nconst feature_registry_1 = __webpack_require__(/*! ../../feature_registry */ \"./feature_registry.ts\");\n// --- Type Guards for Validation (Remain the same) ---\nfunction isGroupDataJSON(item) {\n    return typeof item === \"object\" && item !== null && item.rowType === \"group\";\n}\nfunction isIntervalDataJSON(item) {\n    // Also check for mandatory categoryName\n    return (typeof item === \"object\" &&\n        item !== null &&\n        item.rowType === \"interval\" &&\n        typeof item.categoryName === \"string\" &&\n        !!item.categoryName);\n}\n// --- Parsing Function ---\n/**\n * Parses a JSON string representing a schedule document into structured row data objects\n * and extracts the schedule name. Uses the feature registry for generic handling.\n */\nfunction parseScheduleJSON(jsonString) {\n    let parsedData;\n    try {\n        parsedData = JSON.parse(jsonString);\n    }\n    catch (error) {\n        throw new Error(`Invalid JSON format: ${error.message}`);\n    }\n    if (typeof parsedData !== \"object\" ||\n        parsedData === null ||\n        !Array.isArray(parsedData.items)) {\n        throw new Error(\"Invalid schedule format: Must be an object with an 'items' array.\");\n    }\n    const name = typeof parsedData.name === \"string\" ? parsedData.name.trim() : undefined;\n    const items = parsedData.items;\n    const rowDataArray = [];\n    items.forEach((item, index) => {\n        if (isGroupDataJSON(item)) {\n            const level = typeof item.level === \"number\" && item.level >= 1 ? item.level : 1;\n            const groupName = typeof item.name === \"string\"\n                ? item.name.trim()\n                : `Group Level ${level}`;\n            rowDataArray.push({ rowType: \"group\", level: level, name: groupName });\n        }\n        else if (isIntervalDataJSON(item)) {\n            // isIntervalDataJSON now checks for categoryName\n            const duration = typeof item.duration === \"string\" ? item.duration.trim() : \"0:00\";\n            const task = typeof item.task === \"string\" ? item.task.trim() : \"\";\n            const categoryName = item.categoryName; // Already validated by type guard\n            // Check if category exists in registry\n            if (!(0, feature_registry_1.getCategory)(categoryName)) {\n                console.warn(`Skipping interval at index ${index}: Category \"${categoryName}\" is not registered.`, item);\n                return; // Skip if category not registered\n            }\n            const featureTypeName = typeof item.featureTypeName === \"string\"\n                ? item.featureTypeName.trim()\n                : \"\";\n            const featureArgsList = Array.isArray(item.featureArgsList)\n                ? item.featureArgsList.map((arg) => String(arg !== null && arg !== void 0 ? arg : \"\"))\n                : [];\n            // ---- Create IntervalSettings Instance using Factory/Parser from Registry ----\n            let intervalSettings;\n            const settingsParser = (0, feature_registry_1.getIntervalSettingsParser)(categoryName);\n            const settingsData = item.intervalSettings;\n            if (settingsParser) {\n                try {\n                    intervalSettings = settingsParser(settingsData);\n                }\n                catch (parseError) {\n                    console.error(`Error parsing interval settings for category \"${categoryName}\" at index ${index}:`, parseError, settingsData);\n                    const defaultFactory = (0, feature_registry_1.getIntervalSettingsFactory)(categoryName);\n                    intervalSettings = defaultFactory\n                        ? defaultFactory()\n                        : { toJSON: () => ({}) };\n                }\n            }\n            else {\n                console.warn(`No settings parser registered for category \"${categoryName}\". Creating basic settings object.`);\n                intervalSettings = { toJSON: () => settingsData || {} };\n                if (settingsData) {\n                    Object.assign(intervalSettings, settingsData);\n                }\n            }\n            // ---- End IntervalSettings Instance Creation ----\n            const intervalData = {\n                rowType: \"interval\",\n                duration,\n                task,\n                categoryName: categoryName, // Assign category name string\n                featureTypeName,\n                featureArgsList,\n                intervalSettings, // Assign instance\n            };\n            rowDataArray.push(intervalData);\n        }\n        else {\n            console.warn(`Skipping invalid schedule item at index ${index}:`, item);\n        }\n    });\n    return { name: name, items: rowDataArray };\n}\n/**\n * Generates a pretty-printed JSON string from schedule name and row data objects.\n * Expects rowDataArray elements to conform to ScheduleRowJSONData structure.\n */\nfunction generateScheduleJSON(scheduleName, rowDataArray) {\n    const scheduleDocument = { items: rowDataArray };\n    if (scheduleName && scheduleName.trim()) {\n        scheduleDocument.name = scheduleName.trim();\n    }\n    try {\n        // The rowDataArray should already be in the correct JSON format\n        return JSON.stringify(scheduleDocument, null, 2);\n    }\n    catch (error) {\n        console.error(\"Error stringifying schedule data:\", error);\n        return JSON.stringify({ name: scheduleName || undefined, items: [] }, null, 2);\n    }\n}\n\n\n//# sourceURL=webpack:///./schedule/editor/schedule_serializer.ts?");

/***/ }),

/***/ "./schedule/editor/selection_manager.ts":
/*!**********************************************!*\
  !*** ./schedule/editor/selection_manager.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectionManager = void 0;\nclass SelectionManager {\n    constructor(configEntriesContainerEl, onSelectionChange) {\n        this.selectedRowElements = new Set();\n        this.lastClickedRow = null;\n        this.configEntriesContainerEl = configEntriesContainerEl;\n        this.onSelectionChange = onSelectionChange;\n        this._addSelectionHandler();\n    }\n    getSelectedElements() {\n        return this.selectedRowElements;\n    }\n    getSelectedElementsInDomOrder() {\n        const allRows = Array.from(this.configEntriesContainerEl.querySelectorAll(\".schedule-row\"));\n        return allRows.filter((row) => this.selectedRowElements.has(row));\n    }\n    getLastClickedRow() {\n        return this.lastClickedRow;\n    }\n    getLastSelectedElementInDomOrder() {\n        const selectedInOrder = this.getSelectedElementsInDomOrder();\n        return selectedInOrder.length > 0\n            ? selectedInOrder[selectedInOrder.length - 1]\n            : null;\n    }\n    clearSelection(resetLastClicked = true) {\n        this.selectedRowElements.forEach((el) => el.classList.remove(\"is-selected\"));\n        this.selectedRowElements.clear();\n        if (resetLastClicked) {\n            this.lastClickedRow = null;\n        }\n        this.onSelectionChange(); // Notify about the change\n    }\n    selectSingleRow(rowElement) {\n        this.clearSelection(false);\n        rowElement.classList.add(\"is-selected\");\n        this.selectedRowElements.add(rowElement);\n        this.lastClickedRow = rowElement;\n        this.onSelectionChange();\n    }\n    _addSelectionHandler() {\n        this.configEntriesContainerEl.addEventListener(\"click\", (e) => {\n            const targetElement = e.target;\n            // --- Ignore clicks on interactive elements/buttons (except drag handle) ---\n            if (targetElement.closest(\"input, select, a, .dropdown, .remove-row-btn, .copy-row-btn, .add-variadic-btn\")) {\n                // Allow clicks directly on the drag handle for potential future use or dnd start\n                if (!targetElement.closest(\".drag-handle-cell\")) {\n                    return;\n                }\n            }\n            // --- Ignore clicks on the ellipsis button itself ---\n            if (targetElement.closest(\".config-ellipsis-button\")) {\n                return;\n            }\n            const clickedRow = targetElement.closest(\".schedule-row\");\n            if (!clickedRow) {\n                this.clearSelection();\n                return;\n            }\n            e.preventDefault(); // Prevent text selection on rows\n            const isCtrlPressed = e.ctrlKey || e.metaKey;\n            const isShiftPressed = e.shiftKey;\n            if (isShiftPressed &&\n                this.lastClickedRow &&\n                this.lastClickedRow !== clickedRow) {\n                // --- Shift Selection ---\n                this.clearSelection(false); // Keep last clicked row reference\n                const rows = Array.from(this.configEntriesContainerEl.querySelectorAll(\".schedule-row\"));\n                const lastClickedIndex = rows.indexOf(this.lastClickedRow);\n                const clickedIndex = rows.indexOf(clickedRow);\n                const startIndex = Math.min(lastClickedIndex, clickedIndex);\n                const endIndex = Math.max(lastClickedIndex, clickedIndex);\n                if (startIndex !== -1 && endIndex !== -1) {\n                    for (let i = startIndex; i <= endIndex; i++) {\n                        rows[i].classList.add(\"is-selected\");\n                        this.selectedRowElements.add(rows[i]);\n                    }\n                }\n                else {\n                    // Fallback if indices are weird, just select the clicked one\n                    clickedRow.classList.add(\"is-selected\");\n                    this.selectedRowElements.add(clickedRow);\n                    this.lastClickedRow = clickedRow; // Update last clicked if range failed\n                }\n            }\n            else if (isCtrlPressed) {\n                // --- Ctrl/Cmd Selection (Toggle) ---\n                if (this.selectedRowElements.has(clickedRow)) {\n                    clickedRow.classList.remove(\"is-selected\");\n                    this.selectedRowElements.delete(clickedRow);\n                    // Update last clicked if the toggled-off row was the last one\n                    if (this.lastClickedRow === clickedRow) {\n                        this.lastClickedRow = this.getLastSelectedElementInDomOrder();\n                    }\n                }\n                else {\n                    clickedRow.classList.add(\"is-selected\");\n                    this.selectedRowElements.add(clickedRow);\n                    this.lastClickedRow = clickedRow; // Set as last clicked\n                }\n            }\n            else {\n                // --- Single Selection ---\n                // Check if the clicked row is already the *only* selected row\n                if (!(this.selectedRowElements.size === 1 &&\n                    this.selectedRowElements.has(clickedRow))) {\n                    this.clearSelection(false); // Keep last clicked reference before setting new one\n                    clickedRow.classList.add(\"is-selected\");\n                    this.selectedRowElements.add(clickedRow);\n                    this.lastClickedRow = clickedRow; // Set as last clicked\n                }\n                // If it *is* the only selected row, do nothing (keep it selected)\n            }\n            this.onSelectionChange();\n        });\n    }\n}\nexports.SelectionManager = SelectionManager;\n\n\n//# sourceURL=webpack:///./schedule/editor/selection_manager.ts?");

/***/ }),

/***/ "./schedule/schedule.ts":
/*!******************************!*\
  !*** ./schedule/schedule.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Interval = exports.Schedule = void 0;\nconst display_controller_1 = __webpack_require__(/*! ../display_controller */ \"./display_controller.ts\");\n// Colors for tasks in intervals.\nconst intervalColors = [\n    '#e7cba9',\n    '#aad9cd',\n    '#e8d595',\n    '#8da47e',\n    '#e9bbb5',\n];\n// An instance of a schedule.\nclass Schedule {\n    constructor(display, audio) {\n        this.display = display;\n        this.audio = audio;\n        this.intervals = [];\n        this.currentIntervalIndex = 0;\n        this.accumulatedSeconds = 0;\n        this.totalDuration = 0;\n        this.color_index = 0;\n    }\n    addInterval(interval) {\n        interval.setCallbacks(this.onIntroEnd.bind(this), this.onTimerUpdate.bind(this), this.onIntervalEnd.bind(this));\n        interval.setColor(intervalColors[this.color_index]);\n        this.color_index = (this.color_index + 1) % intervalColors.length;\n        this.totalDuration += interval.getTotalDuration();\n        this.intervals.push(interval);\n    }\n    isFinished() {\n        return this.currentIntervalIndex >= this.intervals.length;\n    }\n    isRunning() {\n        var _a, _b;\n        // Check if the current interval exists and its timer is running\n        return (_b = (_a = this.getCurrentInterval()) === null || _a === void 0 ? void 0 : _a.isTimerRunning()) !== null && _b !== void 0 ? _b : false;\n    }\n    getCurrentInterval() {\n        return this.isFinished() ?\n            null : this.intervals[this.currentIntervalIndex];\n    }\n    onTimerUpdate(time) {\n        this.display.setTime(time);\n        this.setTotalTime();\n        // Only increment accumulated seconds if the timer is actually running\n        // This prevents accumulation during pauses or skips.\n        // We might need a more robust way if skipping should contribute time.\n        if (this.isRunning()) {\n            this.accumulatedSeconds++;\n        }\n    }\n    onIntroEnd() {\n        this.audio.playIntroEnd();\n        this.setDisplayTask(this.getCurrentInterval());\n        this.display.flashOverlay();\n    }\n    onIntervalEnd() {\n        const endedInterval = this.getCurrentInterval(); // Get interval that just finished\n        // Stop the feature and its views for the interval that just ended\n        endedInterval === null || endedInterval === void 0 ? void 0 : endedInterval.stopFeatureAndViews();\n        endedInterval === null || endedInterval === void 0 ? void 0 : endedInterval.destroyFeatureAndViews(); // Clean up ended interval views/feature\n        this.currentIntervalIndex += 1;\n        this.audio.playIntervalEnd();\n        this.display.flashOverlay();\n        if (!this.isFinished()) {\n            const nextInterval = this.getCurrentInterval();\n            this.setDisplayTask(nextInterval); // Prepare display for the next interval\n            this.updateUpcoming();\n            nextInterval.start(); // Start the next interval timer AND its features/views\n        }\n        else {\n            this.setDisplayFinished();\n            // No need to stop/destroy here, already done for the last interval\n        }\n    }\n    setTotalTime() {\n        this.display.setTotalTime(this.accumulatedSeconds, this.totalDuration);\n    }\n    setDisplayTask(interval) {\n        console.log(\"Setting display for interval:\", interval);\n        const suffix = interval.isIntroActive() ? \" (Warmup)\" : \"\";\n        this.display.setTask(interval.task + suffix, interval.color);\n        if (interval.feature) {\n            // Render feature (which includes its views via DisplayController)\n            this.display.renderFeature(interval.feature);\n        }\n        else {\n            this.display.clearFeature();\n        }\n    }\n    setDisplayFinished() {\n        this.display.setTask('DONE!', '');\n        this.display.setStatus(display_controller_1.Status.Stop);\n        this.display.setStart();\n    }\n    updateUpcoming() {\n        if (this.isFinished()) {\n            this.display.setUpcoming([], true); // Pass true for isEndVisible when finished\n            return;\n        }\n        const upcomingTasks = [];\n        // Change +3 to +6 to potentially include the next 5 intervals\n        const maxSize = Math.min(this.currentIntervalIndex + 6, // Look ahead up to 5 intervals (current + 1 to current + 5)\n        this.intervals.length);\n        for (var i = this.currentIntervalIndex + 1; i < maxSize; i++) {\n            upcomingTasks.push(this.intervals[i]);\n        }\n        // Determine if the loop reached the actual end of the schedule\n        const isEndVisible = (maxSize === this.intervals.length);\n        this.display.setUpcoming(upcomingTasks, isEndVisible); // Pass the flag\n    }\n    start() {\n        const interval = this.getCurrentInterval();\n        if (!interval || this.isFinished()) {\n            console.log(\"Schedule start: No interval or schedule finished.\");\n            return;\n        }\n        if (interval.isTimerRunning()) {\n            console.log(\"Schedule start: Timer already running.\");\n            return; // Avoid double start\n        }\n        console.log(\"Schedule start: Starting interval\", this.currentIntervalIndex);\n        this.display.setPause(); // Set button to PAUSE state\n        this.display.setStatus(display_controller_1.Status.Play);\n        interval.start(); // This now also starts feature/views\n    }\n    // Prepare display for the first interval (or current if paused)\n    prepare() {\n        const interval = this.getCurrentInterval();\n        if (!interval) {\n            console.log(\"Schedule prepare: No intervals.\");\n            this.setDisplayFinished(); // Or some initial state\n            return;\n        }\n        console.log(\"Schedule prepare: Setting up display for interval\", this.currentIntervalIndex);\n        this.display.setTime(interval.getCurrentTimeRemaining());\n        this.setDisplayTask(interval); // Renders feature/views via DisplayController\n        this.setTotalTime();\n        this.updateUpcoming();\n        this.display.setStart(); // Ensure button shows START initially or after pause\n        this.display.setStatus(display_controller_1.Status.Pause); // Show pause icon initially\n    }\n    // Pause the current interval\n    pause() {\n        const interval = this.getCurrentInterval();\n        if (!interval || this.isFinished() || !interval.isTimerRunning()) {\n            console.log(\"Schedule pause: No interval, finished, or not running.\");\n            return;\n        }\n        console.log(\"Schedule pause: Pausing interval\", this.currentIntervalIndex);\n        this.display.setStart(); // Set button to START state\n        this.display.setStatus(display_controller_1.Status.Pause);\n        interval.pause();\n    }\n    // Skip the current interval\n    skip() {\n        console.log(\"Attempting to skip interval\", this.currentIntervalIndex);\n        if (this.isFinished()) {\n            console.warn(\"Cannot skip: Schedule is already finished.\");\n            return;\n        }\n        const currentInterval = this.getCurrentInterval();\n        if (!currentInterval) {\n            console.error(\"Cannot skip: Failed to get current interval.\");\n            return; // Should not happen if not finished, but safety check\n        }\n        // Stop the timer and feature/views of the current interval\n        currentInterval.pause(); // Ensure timer is stopped\n        currentInterval.stopFeatureAndViews();\n        currentInterval.destroyFeatureAndViews();\n        // Advance to the next interval\n        this.currentIntervalIndex += 1;\n        // Play sound and flash overlay like interval end\n        this.audio.playIntervalEnd();\n        this.display.flashOverlay();\n        // Check if the schedule finished after skipping\n        if (this.isFinished()) {\n            console.log(\"Schedule finished after skipping.\");\n            this.setDisplayFinished();\n            // Update accumulated time here? Or leave as is?\n            // For simplicity, skip doesn't add the remaining time to accumulated.\n            this.setTotalTime();\n            this.updateUpcoming();\n        }\n        else {\n            // Prepare and start the next interval\n            const nextInterval = this.getCurrentInterval();\n            console.log(\"Skipped to interval\", this.currentIntervalIndex);\n            this.setDisplayTask(nextInterval); // Set display for the new interval\n            this.updateUpcoming();\n            // Start the next interval and update UI controls\n            nextInterval.start();\n            this.display.setPause(); // Set button to PAUSE state\n            this.display.setStatus(display_controller_1.Status.Play); // Set status to Play\n            // Set timer display to the *start* of the new interval\n            this.display.setTime(nextInterval.getCurrentTimeRemaining());\n            this.setTotalTime(); // Update total time display\n        }\n    }\n}\nexports.Schedule = Schedule;\n// An interval in a schedule.\nclass Interval {\n    constructor(duration, introDuration, task, feature = null) {\n        this.introFinishedCallback = null;\n        this.updateCallback = null;\n        this.finishedCallback = null;\n        this.duration = duration;\n        this.introDuration = introDuration;\n        this.task = task;\n        this.feature = feature;\n        this.timer = new IntervalTimer(duration, introDuration);\n    }\n    setColor(color) {\n        this.color = color;\n    }\n    setCallbacks(introFinishedCallback, updateCallback, finishedCallback) {\n        this.introFinishedCallback = introFinishedCallback;\n        this.updateCallback = updateCallback;\n        this.finishedCallback = finishedCallback;\n        // Pass callbacks to timer\n        this.timer.setCallbacks(() => { var _a; return (_a = this.introFinishedCallback) === null || _a === void 0 ? void 0 : _a.call(this); }, (time) => { var _a; return (_a = this.updateCallback) === null || _a === void 0 ? void 0 : _a.call(this, time); }, () => { var _a; return (_a = this.finishedCallback) === null || _a === void 0 ? void 0 : _a.call(this); });\n    }\n    isIntroActive() {\n        return !this.timer.isIntroFinished;\n    }\n    isTimerRunning() {\n        return this.timer.isRunning();\n    }\n    getTotalDuration() {\n        return this.duration + this.introDuration;\n    }\n    getCurrentTimeRemaining() {\n        if (this.isIntroActive()) {\n            return this.timer.introTimeRemaining;\n        }\n        return this.timer.timeRemaining;\n    }\n    start() {\n        var _a, _b, _c, _d;\n        if (this.timer.isRunning())\n            return; // Prevent double start\n        console.log(`Interval \"${this.task}\" starting timer...`);\n        this.timer.countdown();\n        // Start feature and its views\n        console.log(`   Starting feature and views for \"${this.task}\"...`);\n        (_b = (_a = this.feature) === null || _a === void 0 ? void 0 : _a.prepare) === null || _b === void 0 ? void 0 : _b.call(_a); // Prepare feature before starting\n        (_d = (_c = this.feature) === null || _c === void 0 ? void 0 : _c.start) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    pause() {\n        var _a, _b;\n        if (!this.timer.isRunning())\n            return; // Can't pause if not running\n        console.log(`Interval \"${this.task}\" pausing timer...`);\n        this.timer.pause();\n        // Stop feature and its views\n        console.log(`   Stopping feature and views for \"${this.task}\"...`);\n        (_b = (_a = this.feature) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    stopFeatureAndViews() {\n        var _a, _b;\n        console.log(`Interval \"${this.task}\" explicitly stopping feature/views.`);\n        this.timer.pause(); // Ensure timer is paused when stopping features\n        (_b = (_a = this.feature) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    destroyFeatureAndViews() {\n        var _a, _b;\n        console.log(`Interval \"${this.task}\" explicitly destroying feature/views.`);\n        (_b = (_a = this.feature) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.Interval = Interval;\nclass IntervalTimer {\n    constructor(time, introductionTime) {\n        this.countdownTimerId = null;\n        this.timeRemaining = time;\n        this.introTimeRemaining = introductionTime;\n        this.isIntroFinished = introductionTime == 0 ? true : false;\n    }\n    isRunning() {\n        return this.countdownTimerId !== null;\n    }\n    setCallbacks(introFinishedCallback, updateCallback, finishedCallback) {\n        this.introFinishedCallback = introFinishedCallback;\n        this.updateCallback = updateCallback;\n        this.finishedCallback = finishedCallback;\n    }\n    countdown() {\n        var _a;\n        if (this.countdownTimerId !== null)\n            return; // Already running\n        const tick = () => {\n            var _a, _b, _c, _d, _e;\n            if (this.countdownTimerId === null)\n                return; // Stop if paused externally\n            if (this.introTimeRemaining > 0) {\n                this.introTimeRemaining -= 1;\n                (_a = this.updateCallback) === null || _a === void 0 ? void 0 : _a.call(this, this.introTimeRemaining);\n                this.countdownTimerId = window.setTimeout(tick, 1000);\n            }\n            else {\n                if (!this.isIntroFinished) {\n                    this.isIntroFinished = true;\n                    (_b = this.introFinishedCallback) === null || _b === void 0 ? void 0 : _b.call(this);\n                    // Update timer display immediately after intro finishes\n                    (_c = this.updateCallback) === null || _c === void 0 ? void 0 : _c.call(this, this.timeRemaining);\n                }\n                if (this.timeRemaining > 0) {\n                    this.timeRemaining -= 1;\n                    (_d = this.updateCallback) === null || _d === void 0 ? void 0 : _d.call(this, this.timeRemaining);\n                    this.countdownTimerId = window.setTimeout(tick, 1000);\n                }\n                else {\n                    // Timer finished\n                    this.countdownTimerId = null; // Mark as stopped *before* callback\n                    (_e = this.finishedCallback) === null || _e === void 0 ? void 0 : _e.call(this);\n                }\n            }\n        };\n        // Start the first tick\n        if (this.introTimeRemaining > 0 || this.timeRemaining > 0) {\n            console.log(\"IntervalTimer: Starting countdown...\");\n            this.countdownTimerId = window.setTimeout(tick, 1000); // Initial start with timeout\n        }\n        else {\n            console.log(\"IntervalTimer: Zero duration, calling finished immediately.\");\n            (_a = this.finishedCallback) === null || _a === void 0 ? void 0 : _a.call(this); // Call immediately if zero duration\n        }\n    }\n    pause() {\n        if (this.countdownTimerId !== null) {\n            window.clearTimeout(this.countdownTimerId);\n            this.countdownTimerId = null;\n            console.log(\"IntervalTimer: Paused.\");\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./schedule/schedule.ts?");

/***/ }),

/***/ "./schedule/schedule_load_modal.ts":
/*!*****************************************!*\
  !*** ./schedule/schedule_load_modal.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScheduleLoadModal = void 0;\nclass ScheduleLoadModal {\n    constructor(modalEl, scheduleEditor, recentSchedulesKey) {\n        if (!modalEl)\n            throw new Error(\"Load Schedule Modal element not provided.\");\n        this.modalEl = modalEl;\n        this.scheduleEditor = scheduleEditor;\n        this.recentSchedulesKey = recentSchedulesKey;\n        // Find required elements\n        const requiredSelectors = {\n            recentListEl: \"#recent-schedules-list\",\n            previewEl: \"#recent-schedule-preview\",\n            previewContentEl: \"#recent-schedule-preview-content\",\n            closePreviewButtonEl: \"#close-preview-button\",\n            saveToDiskButtonEl: \"#save-schedule-disk\",\n            loadFromDiskInputEl: \"#load-schedule-input-hidden\",\n            loadScheduleModalCloseButtonEl: \"#load-schedule-modal-close\",\n            loadScheduleModalCancelButtonEl: \"#load-schedule-modal-cancel\",\n        };\n        let allFound = true;\n        for (const key in requiredSelectors) {\n            const element = this.modalEl.querySelector(requiredSelectors[key]);\n            if (!element) {\n                console.error(`Load/Save Modal Error: Element not found for selector \"${requiredSelectors[key]}\"`);\n                allFound = false;\n            }\n            this[key] = element; // Assign element\n        }\n        if (!allFound) {\n            console.error(\"Load/Save modal cannot initialize properly due to missing elements.\");\n            // Optionally disable buttons or throw error\n            return;\n        }\n        this._attachHandlers();\n    }\n    show() {\n        this.refreshRecentList();\n        this._hidePreview();\n        this.modalEl.classList.add(\"is-active\");\n    }\n    hide() {\n        this.modalEl.classList.remove(\"is-active\");\n    }\n    isOpen() {\n        return this.modalEl.classList.contains(\"is-active\");\n    }\n    /** Reloads and displays the recent schedules list from localStorage */\n    refreshRecentList() {\n        if (!this.recentListEl)\n            return;\n        this.recentListEl.innerHTML = \"\"; // Clear existing list\n        const stored = localStorage.getItem(this.recentSchedulesKey);\n        let recentSchedulesJSONStrings = []; // Expect array of JSON strings\n        if (stored) {\n            try {\n                const parsed = JSON.parse(stored);\n                if (Array.isArray(parsed) &&\n                    parsed.every((item) => typeof item === \"string\")) {\n                    recentSchedulesJSONStrings = parsed;\n                }\n            }\n            catch (e) {\n                console.error(\"Error parsing recent schedules JSON from localStorage:\", e);\n            }\n        }\n        if (recentSchedulesJSONStrings.length === 0) {\n            this.recentListEl.innerHTML =\n                '<li class=\"is-disabled\"><a>(No recent schedules saved)</a></li>';\n            return;\n        }\n        recentSchedulesJSONStrings.forEach((scheduleJSONString, index) => {\n            const listItem = document.createElement(\"li\");\n            const link = document.createElement(\"a\");\n            const viewButton = document.createElement(\"button\");\n            // Try to parse JSON to get the name for a better preview title\n            let previewTitle = `Saved Schedule ${index + 1}`; // Default title\n            try {\n                const scheduleDoc = JSON.parse(scheduleJSONString);\n                if (scheduleDoc.name) {\n                    previewTitle = scheduleDoc.name;\n                }\n                else if (scheduleDoc.items && scheduleDoc.items.length > 0) {\n                    // Fallback: Find first task or group name if no schedule name\n                    const firstItem = scheduleDoc.items[0];\n                    if (\"task\" in firstItem && firstItem.task) {\n                        previewTitle = `${firstItem.task.substring(0, 25)}${firstItem.task.length > 25 ? \"...\" : \"\"} (${firstItem.duration || \"N/A\"})`;\n                    }\n                    else if (\"name\" in firstItem && firstItem.name) {\n                        // Group name\n                        previewTitle = `${firstItem.name.substring(0, 30)}${firstItem.name.length > 30 ? \"...\" : \"\"}`;\n                    }\n                }\n            }\n            catch (_a) {\n                /* Ignore parsing errors for title */\n            }\n            link.textContent = previewTitle;\n            link.title = \"Click to load this schedule into the editor\";\n            link.onclick = (e) => {\n                e.preventDefault();\n                // Pass the original JSON string to load\n                this._loadRecentSchedule(scheduleJSONString);\n            };\n            viewButton.textContent = \"View\";\n            viewButton.classList.add(\"button\", \"is-small\", \"is-pulled-right\", \"is-info\", \"is-outlined\");\n            viewButton.style.marginLeft = \"10px\";\n            viewButton.title = \"Preview full schedule content\";\n            viewButton.onclick = (e) => {\n                e.stopPropagation();\n                // Pass the original JSON string to preview\n                this._showPreview(scheduleJSONString);\n            };\n            link.appendChild(viewButton);\n            listItem.appendChild(link);\n            this.recentListEl.appendChild(listItem);\n        });\n    }\n    _attachHandlers() {\n        var _a;\n        // Close modal\n        this.loadScheduleModalCloseButtonEl.onclick = () => this.hide();\n        this.loadScheduleModalCancelButtonEl.onclick = () => this.hide();\n        (_a = this.modalEl\n            .querySelector(\".modal-background\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", () => this.hide());\n        // Save/Load\n        this.saveToDiskButtonEl.onclick = () => this._saveCurrentScheduleToFile();\n        this.loadFromDiskInputEl.onchange = (event) => {\n            var _a, _b;\n            const file = (_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b[0];\n            if (file) {\n                this._loadScheduleFromFile(file);\n                event.target.value = \"\"; // Reset input\n            }\n        };\n        // Preview\n        this.closePreviewButtonEl.onclick = () => this._hidePreview();\n    }\n    _loadRecentSchedule(scheduleJSONString) {\n        if (confirm(\"Load this schedule? This will replace the current content in the editor.\")) {\n            try {\n                this.scheduleEditor.setScheduleJSON(scheduleJSONString); // Load the JSON string\n                this.hide();\n            }\n            catch (e) {\n                console.error(\"Error loading recent schedule:\", e);\n                alert(`Error loading schedule: ${e.message}`);\n            }\n        }\n    }\n    _showPreview(scheduleJSONString) {\n        try {\n            // Parse and pretty-print the JSON for preview\n            const parsedDoc = JSON.parse(scheduleJSONString); // Parse the full document\n            const prettyJSON = JSON.stringify(parsedDoc, null, 2); // Stringify the parsed object\n            this.previewContentEl.textContent = prettyJSON;\n            this.previewEl.style.display = \"block\";\n        }\n        catch (e) {\n            console.error(\"Error parsing JSON for preview:\", e);\n            this.previewContentEl.textContent =\n                \"Error: Could not parse schedule data for preview.\";\n            this.previewEl.style.display = \"block\";\n        }\n    }\n    _hidePreview() {\n        this.previewEl.style.display = \"none\";\n        this.previewContentEl.textContent = \"\";\n    }\n    _saveCurrentScheduleToFile() {\n        try {\n            const scheduleJSONString = this.scheduleEditor.getScheduleJSON(); // Get JSON string\n            // Basic check if it's a valid JSON object structure (more than just \"[]\")\n            if (!scheduleJSONString ||\n                scheduleJSONString.trim().length <= 2 ||\n                !scheduleJSONString.trim().startsWith(\"{\")) {\n                alert(\"Cannot save an empty or invalid schedule.\");\n                return;\n            }\n            // Try to parse to get name for filename suggestion\n            let scheduleName = \"\";\n            try {\n                const scheduleDoc = JSON.parse(scheduleJSONString);\n                scheduleName = scheduleDoc.name || \"\";\n            }\n            catch (_a) { } // Ignore parsing errors for filename\n            // Generate filename\n            const baseName = (scheduleName || \"schedule\")\n                .replace(/[^a-z0-9]/gi, \"_\")\n                .toLowerCase();\n            const filename = `${baseName.substring(0, 25)}.json`; // Use .json extension\n            // Create Blob and trigger download\n            const blob = new Blob([scheduleJSONString], {\n                type: \"application/json;charset=utf-8\",\n            });\n            const link = document.createElement(\"a\");\n            const url = URL.createObjectURL(blob);\n            link.setAttribute(\"href\", url);\n            link.setAttribute(\"download\", filename);\n            link.style.visibility = \"hidden\";\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n        }\n        catch (e) {\n            console.error(\"Error saving schedule to file:\", e);\n            alert(`Error saving schedule: ${e.message}`);\n        }\n    }\n    _loadScheduleFromFile(file) {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            var _a;\n            const content = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n            if (content) {\n                try {\n                    // Validate by parsing into the expected ScheduleDocument structure\n                    const parsedDoc = JSON.parse(content);\n                    // Basic validation: check if 'items' is an array\n                    if (typeof parsedDoc !== \"object\" ||\n                        !Array.isArray(parsedDoc.items)) {\n                        throw new Error(\"Invalid format: Missing 'items' array.\");\n                    }\n                    // If parse succeeds and basic structure is okay, load it\n                    this.scheduleEditor.setScheduleJSON(content); // Load raw string\n                    this.hide();\n                    alert(`Schedule \"${file.name}\" loaded successfully.`);\n                }\n                catch (e) {\n                    console.error(\"Error parsing loaded file:\", e);\n                    alert(`Error loading file \"${file.name}\": Invalid JSON format or structure.\\n(${e.message})`);\n                }\n            }\n            else {\n                alert(`Error loading file \"${file.name}\": Could not read file content.`);\n            }\n        };\n        reader.onerror = (event) => {\n            console.error(\"File reading error:\", event);\n            alert(`Error reading file \"${file.name}\".`);\n        };\n        reader.readAsText(file); // Read as text\n    }\n}\nexports.ScheduleLoadModal = ScheduleLoadModal;\n\n\n//# sourceURL=webpack:///./schedule/schedule_load_modal.ts?");

/***/ }),

/***/ "./settings.ts":
/*!*********************!*\
  !*** ./settings.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MAX_RECENT_SCHEDULES = exports.RECENT_SCHEDULES_JSON_KEY = exports.LAST_RUN_SCHEDULE_JSON_KEY = exports.SETTINGS_STORAGE_KEY = exports.BASE_DEFAULT_SETTINGS = void 0;\nexports.loadSettings = loadSettings;\nexports.getCategorySettings = getCategorySettings;\n// ts/settings.ts\nconst feature_registry_1 = __webpack_require__(/*! ./feature_registry */ \"./feature_registry.ts\");\n/** Initial default values for *global* settings (excluding category-specific ones). */\nexports.BASE_DEFAULT_SETTINGS = {\n    theme: \"light\",\n    warmupPeriod: 0,\n};\n// --- Storage Constants --- (Remain the same)\nexports.SETTINGS_STORAGE_KEY = \"categoryTimerAppSettings\";\nexports.LAST_RUN_SCHEDULE_JSON_KEY = \"lastRunScheduleJSON\";\nexports.RECENT_SCHEDULES_JSON_KEY = \"recentSchedulesJSON\";\nexports.MAX_RECENT_SCHEDULES = 5;\n// --- End Storage Constants ---\n/** Loads settings from localStorage, merging with current defaults from the category registry. */\nfunction loadSettings() {\n    var _a, _b;\n    let loadedSettings = null;\n    // Get defaults from registry (now uses string keys internally)\n    const currentDefaultsByCategory = (0, feature_registry_1.getAllDefaultGlobalSettings)();\n    try {\n        const storedSettingsJson = localStorage.getItem(exports.SETTINGS_STORAGE_KEY);\n        if (storedSettingsJson) {\n            const parsedStored = JSON.parse(storedSettingsJson);\n            // Start with a structure combining base defaults and registry category defaults\n            loadedSettings = Object.assign(Object.assign({}, exports.BASE_DEFAULT_SETTINGS), { \n                // Deep copy defaults initially, using the map returned by the registry\n                categorySettings: JSON.parse(JSON.stringify(currentDefaultsByCategory)) });\n            // Merge stored global settings (theme, warmupPeriod)\n            for (const key in exports.BASE_DEFAULT_SETTINGS) {\n                if (Object.prototype.hasOwnProperty.call(parsedStored, key)) {\n                    // Ensure type compatibility if needed, though basic types are likely fine\n                    loadedSettings[key] = parsedStored[key];\n                }\n            }\n            // Deep merge stored category settings over the current defaults\n            if (parsedStored.categorySettings &&\n                typeof parsedStored.categorySettings === \"object\") {\n                // Iterate over KNOWN categories from the registry's defaults\n                for (const categoryKey in currentDefaultsByCategory) {\n                    if (Object.prototype.hasOwnProperty.call(parsedStored.categorySettings, categoryKey // Check if stored settings contain this category key (string)\n                    ) &&\n                        typeof parsedStored.categorySettings[categoryKey] === \"object\" // Ensure it's an object\n                    ) {\n                        // Merge stored settings for this category onto the defaults\n                        // Ensure the target exists before merging\n                        if (!loadedSettings.categorySettings[categoryKey]) {\n                            loadedSettings.categorySettings[categoryKey] = {}; // Initialize if missing\n                        }\n                        // Merge: Start with current defaults for the category, overlay stored values\n                        loadedSettings.categorySettings[categoryKey] = Object.assign(Object.assign({}, ((_a = currentDefaultsByCategory[categoryKey]) !== null && _a !== void 0 ? _a : {})), ((_b = parsedStored.categorySettings[categoryKey]) !== null && _b !== void 0 ? _b : {}));\n                    }\n                    // If a category exists in defaults but not in storage, it keeps the defaults.\n                    // Categories present only in storage are ignored (prevents orphaned settings).\n                }\n            }\n            console.log(\"Successfully loaded and merged settings from localStorage.\");\n        }\n    }\n    catch (e) {\n        console.error(\"Failed to load or parse settings from localStorage:\", e);\n        loadedSettings = null; // Ensure we fall back to full defaults\n    }\n    // If loading failed or no stored settings, return full defaults\n    if (!loadedSettings) {\n        console.log(\"Using default settings (no valid stored settings found).\");\n        loadedSettings = Object.assign(Object.assign({}, exports.BASE_DEFAULT_SETTINGS), { \n            // Use a fresh copy of defaults from the registry\n            categorySettings: JSON.parse(JSON.stringify(currentDefaultsByCategory)) });\n    }\n    return loadedSettings;\n}\n/**\n * Helper function to safely get category-specific global settings for a given category name.\n * Merges stored settings over registered defaults.\n * @param settings - The current AppSettings object.\n * @param categoryName - The string name of the category (e.g., \"Guitar\").\n * @returns The merged settings object for the category.\n */\nfunction getCategorySettings(settings, categoryName // **** CHANGED: Use string name ****\n) {\n    var _a, _b, _c;\n    // Get the registered defaults for this category name from the registry\n    const defaults = (_a = (0, feature_registry_1.getDefaultGlobalSettingsForCategory)(categoryName)) !== null && _a !== void 0 ? _a : {};\n    // Get the currently stored settings for this category name\n    const storedCategorySettings = (_c = (_b = settings.categorySettings) === null || _b === void 0 ? void 0 : _b[categoryName]) !== null && _c !== void 0 ? _c : {};\n    // Merge: Start with defaults, overlay stored settings\n    // Use a deep copy if settings might be nested, otherwise shallow is fine\n    // return JSON.parse(JSON.stringify({ ...defaults, ...storedCategorySettings }));\n    return Object.assign(Object.assign({}, defaults), storedCategorySettings); // Shallow merge assuming flat settings objects\n}\n\n\n//# sourceURL=webpack:///./settings.ts?");

/***/ }),

/***/ "./time_utils.ts":
/*!***********************!*\
  !*** ./time_utils.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseDurationString = parseDurationString;\nexports.formatDuration = formatDuration;\n/**\n * Parses a duration string (like \"MM:SS\" or \"SS\") into total seconds.\n * @param durationStr - The duration string.\n * @returns Total duration in seconds (integer).\n * @throws {Error} if the format is invalid.\n */\nfunction parseDurationString(durationStr) {\n    if (!durationStr || typeof durationStr !== 'string') {\n        throw new Error(\"Invalid duration input: Must be a non-empty string.\");\n    }\n    const parts = durationStr.trim().split(':');\n    let minutes = 0;\n    let seconds = 0;\n    if (parts.length === 1) {\n        // Only seconds provided (e.g., \"120\")\n        seconds = parseInt(parts[0], 10);\n    }\n    else if (parts.length === 2) {\n        // Minutes and seconds provided (e.g., \"3:45\")\n        minutes = parseInt(parts[0], 10);\n        seconds = parseInt(parts[1], 10);\n    }\n    else {\n        throw new Error(`Invalid duration format: \"${durationStr}\". Use MM:SS or SS.`);\n    }\n    // Validate parsed numbers\n    if (isNaN(minutes) || isNaN(seconds) || minutes < 0 || seconds < 0 || seconds >= 60) {\n        throw new Error(`Invalid time values in duration: \"${durationStr}\". Minutes/seconds must be non-negative, seconds < 60.`);\n    }\n    return minutes * 60 + seconds;\n}\n/** Formats total seconds into a MM:SS string */\nfunction formatDuration(totalSeconds) {\n    if (isNaN(totalSeconds) || totalSeconds < 0) {\n        return \"0:00\";\n    }\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = Math.floor(totalSeconds % 60);\n    const paddedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;\n    return `${minutes}:${paddedSeconds}`;\n}\n\n\n//# sourceURL=webpack:///./time_utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.ts");
/******/ 	
/******/ })()
;